<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="c" width="1500" height="700"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 1500, H = 700;

// ── Utility ──────────────────────────────────────────────
function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
function randF(a, b) { return Math.random() * (b - a) + a; }

// ── Animation state ───────────────────────────────────────
let t = 0;

// Binary rain drops
const drops = Array.from({ length: 90 }, () => ({
  x: randInt(0, W),
  y: randF(0, H),
  speed: randF(0.8, 2.5),
  len: randInt(6, 20),
  chars: Array.from({ length: 25 }, () => (Math.random() < 0.5
    ? String.fromCharCode(randInt(48, 57))
    : String.fromCharCode(randInt(65, 70))
  )),
  alpha: randF(0.04, 0.18),
  col: Math.random() < 0.15 ? '#ff2244' : '#00ff88'
}));

// Floating hex particles
const hexParticles = Array.from({ length: 60 }, () => ({
  x: randF(0, W), y: randF(0, H),
  vx: randF(-0.3, 0.3), vy: randF(-0.2, 0.2),
  size: randF(7, 14),
  alpha: randF(0.05, 0.25),
  col: ['#00ffcc', '#ff3355', '#ffaa00', '#4488ff'][randInt(0, 3)],
  val: '0x' + randInt(0, 255).toString(16).padStart(2, '0').toUpperCase()
}));

// Data stream particles (flowing left→right through the transformation)
const streamParticles = Array.from({ length: 120 }, () => ({
  x: randF(0, W), y: randF(200, 480),
  speed: randF(1.5, 4.5),
  size: randF(2, 5),
  alpha: randF(0.3, 0.9),
  col: Math.random() < 0.5 ? '#00cc88' : '#ff2244',
  trail: []
}));

// Glitch lines
let glitchTimer = 0;
let glitchLines = [];

// ── Draw background ───────────────────────────────────────
function drawBG() {
  // Deep space gradient
  const bg = ctx.createLinearGradient(0, 0, W, H);
  bg.addColorStop(0, '#030508');
  bg.addColorStop(0.4, '#050a10');
  bg.addColorStop(1, '#080308');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(0,200,120,0.03)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += 40) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }
}

// ── Binary rain ───────────────────────────────────────────
function drawRain() {
  drops.forEach(d => {
    ctx.font = '10px monospace';
    for (let i = 0; i < d.len; i++) {
      const alpha = d.alpha * (1 - i / d.len) * (0.7 + 0.3 * Math.sin(t * 0.05 + i));
      ctx.globalAlpha = alpha;
      ctx.fillStyle = d.col;
      if (Math.random() < 0.03) {
        d.chars[i] = (Math.random() < 0.5
          ? String.fromCharCode(randInt(48, 57))
          : String.fromCharCode(randInt(65, 70))
        );
      }
      ctx.fillText(d.chars[i % d.chars.length], d.x, d.y - i * 12);
    }
    ctx.globalAlpha = 1;
    d.y += d.speed;
    if (d.y - d.len * 12 > H) d.y = 0;
  });
}

// ── Stream particles ─────────────────────────────────────
function drawStream() {
  streamParticles.forEach(p => {
    p.trail.push({ x: p.x, y: p.y });
    if (p.trail.length > 12) p.trail.shift();
    // draw trail
    p.trail.forEach((pt, i) => {
      ctx.globalAlpha = (i / p.trail.length) * p.alpha * 0.4;
      ctx.fillStyle = p.col;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, p.size * (i / p.trail.length), 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    p.x += p.speed;
    p.y += Math.sin(t * 0.02 + p.x * 0.01) * 0.8;
    if (p.x > W + 20) { p.x = -10; p.y = randF(200, 480); p.trail = []; }
  });
}

// ── Hex floating particles ────────────────────────────────
function drawHexParticles() {
  ctx.font = '9px monospace';
  hexParticles.forEach(p => {
    ctx.globalAlpha = p.alpha * (0.5 + 0.5 * Math.sin(t * 0.03 + p.x));
    ctx.fillStyle = p.col;
    ctx.fillText(p.val, p.x, p.y);
    ctx.globalAlpha = 1;
    p.x += p.vx; p.y += p.vy;
    if (p.x < -40 || p.x > W + 40) p.vx *= -1;
    if (p.y < -20 || p.y > H + 20) p.vy *= -1;
  });
}

// ── Section 1: Security Solution (LEFT) ─────────────────
function drawSecuritySolution() {
  const cx = 200, cy = 350;

  // Glow aura - shield shaped
  const aura = ctx.createRadialGradient(cx, cy, 10, cx, cy, 160);
  aura.addColorStop(0, 'rgba(0,150,255,0.15)');
  aura.addColorStop(1, 'rgba(0,150,255,0)');
  ctx.fillStyle = aura;
  ctx.fillRect(cx - 160, cy - 160, 320, 320);

  // Shield shape
  ctx.save();
  ctx.translate(cx, cy - 20);

  // Shield body
  function shield(scale, fillColor, strokeColor, sw) {
    ctx.beginPath();
    ctx.moveTo(0, -90 * scale);
    ctx.lineTo(70 * scale, -60 * scale);
    ctx.lineTo(70 * scale, 20 * scale);
    ctx.quadraticCurveTo(70 * scale, 80 * scale, 0, 110 * scale);
    ctx.quadraticCurveTo(-70 * scale, 80 * scale, -70 * scale, 20 * scale);
    ctx.lineTo(-70 * scale, -60 * scale);
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = sw;
    ctx.stroke();
  }

  // Outer glow ring
  shield(1.05, 'rgba(0,120,255,0.08)', `rgba(0,180,255,${0.4 + 0.2 * Math.sin(t * 0.05)})`, 2);
  // Main shield
  const sg = ctx.createLinearGradient(-70, -90, 70, 110);
  sg.addColorStop(0, '#0a2a4a');
  sg.addColorStop(0.5, '#0d3560');
  sg.addColorStop(1, '#071828');
  shield(1, sg, '#1a6aff', 2.5);

  // Shield inner highlight
  shield(0.75, 'rgba(0,80,200,0.15)', 'rgba(80,160,255,0.5)', 1);

  // Lock icon inside shield
  ctx.strokeStyle = `rgba(0,200,255,${0.7 + 0.3 * Math.sin(t * 0.08)})`;
  ctx.lineWidth = 3;
  ctx.fillStyle = 'rgba(0,150,255,0.3)';
  // lock body
  ctx.beginPath();
  ctx.roundRect(-20, 0, 40, 35, 4);
  ctx.fill(); ctx.stroke();
  // lock shackle
  ctx.beginPath();
  ctx.arc(0, -8, 20, Math.PI, 0);
  ctx.stroke();
  // keyhole
  ctx.fillStyle = `rgba(0,200,255,${0.6 + 0.3 * Math.sin(t * 0.1)})`;
  ctx.beginPath(); ctx.arc(0, 12, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-2, 14, 4, 12);

  ctx.restore();

  // Binary code around shield
  ctx.save();
  ctx.translate(cx, cy - 20);
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2 + t * 0.01;
    const r = 100 + Math.sin(t * 0.05 + i) * 5;
    const bx = Math.cos(angle) * r, by = Math.sin(angle) * r;
    ctx.globalAlpha = 0.3 + 0.2 * Math.sin(t * 0.07 + i);
    ctx.fillStyle = '#00aaff';
    ctx.font = '8px monospace';
    ctx.fillText(['10', '01', '11', '00'][i % 4], bx - 6, by + 4);
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // Label
  ctx.save();
  ctx.font = 'bold 13px monospace';
  ctx.fillStyle = '#4499ff';
  ctx.textAlign = 'center';
  ctx.globalAlpha = 0.9;
  ctx.fillText('보안 솔루션', cx, cy + 115);
  ctx.font = '10px monospace';
  ctx.fillStyle = '#336699';
  ctx.fillText('Security Solution Binary', cx, cy + 132);
  ctx.restore();
}

// ── Transformation zone (MIDDLE-LEFT) ────────────────────
function drawInjectionZone() {
  const cx = 560, cy = 340;

  // Chaotic injection aura
  const aura = ctx.createRadialGradient(cx, cy, 5, cx, cy, 180);
  aura.addColorStop(0, 'rgba(255,150,0,0.2)');
  aura.addColorStop(0.5, 'rgba(255,50,0,0.08)');
  aura.addColorStop(1, 'rgba(255,50,0,0)');
  ctx.fillStyle = aura;
  ctx.fillRect(cx - 180, cy - 180, 360, 360);

  // Cracked/breaking shield morphing into code
  ctx.save();
  ctx.translate(cx, cy);

  // Broken shield fragments
  const cracks = [
    [0, -60, 30, -20, 10, 10],
    [0, -60, -25, -30, -5, 15],
    [10, 10, 50, 30, 30, 70],
    [10, 10, -20, 40, 0, 80]
  ];
  cracks.forEach((pts, i) => {
    const pulse = 0.5 + 0.5 * Math.sin(t * 0.08 + i * 1.2);
    ctx.globalAlpha = 0.25 * pulse;
    ctx.strokeStyle = '#ff4400';
    ctx.lineWidth = 1 + pulse;
    ctx.setLineDash([3, 4]);
    ctx.beginPath();
    ctx.moveTo(pts[0], pts[1]);
    ctx.lineTo(pts[2], pts[3]);
    ctx.lineTo(pts[4], pts[5]);
    ctx.stroke();
    ctx.setLineDash([]);
  });
  ctx.globalAlpha = 1;

  // The morph shape - partially shield, partially chaotic blob
  ctx.beginPath();
  for (let a = 0; a < Math.PI * 2; a += 0.15) {
    const rBase = 70;
    const distort = 1 + 0.3 * Math.sin(a * 4 + t * 0.05) + 0.15 * Math.sin(a * 7 - t * 0.08);
    const r = rBase * distort;
    const px = Math.cos(a) * r, py = Math.sin(a) * r;
    a === 0 || a < 0.15 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
  const mg = ctx.createLinearGradient(-70, -80, 70, 80);
  mg.addColorStop(0, 'rgba(20,5,0,0.9)');
  mg.addColorStop(0.5, 'rgba(40,10,0,0.85)');
  mg.addColorStop(1, 'rgba(15,0,5,0.9)');
  ctx.fillStyle = mg;
  ctx.fill();
  const glowG = 50 + 30 * Math.sin(t * 0.06);
  ctx.strokeStyle = `rgba(255,${Math.floor(glowG)},0,0.55)`;
  ctx.lineWidth = 2;
  ctx.stroke();

  // Inject syringe/needle visual
  ctx.save();
  ctx.rotate(-Math.PI / 4 + Math.sin(t * 0.04) * 0.05);
  // needle body
  ctx.strokeStyle = `rgba(255,180,0,${0.6 + 0.3 * Math.sin(t * 0.1)})`;
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(-80, -80); ctx.lineTo(-10, -10); ctx.stroke();
  // needle tip glow
  ctx.fillStyle = `rgba(255,80,0,${0.8 + 0.2 * Math.sin(t * 0.12)})`;
  ctx.beginPath(); ctx.arc(-10, -10, 5, 0, Math.PI * 2); ctx.fill();
  // injection liquid
  ctx.strokeStyle = 'rgba(255,50,0,0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 3]);
  ctx.beginPath(); ctx.moveTo(-8, -8); ctx.lineTo(20, 20); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Hex codes erupting
  const hexList = ['FF', '3C', '4D', '90', '5A', 'E8', 'CC', 'B8', '48', '83'];
  for (let i = 0; i < 8; i++) {
    const a = (i / 8) * Math.PI * 2 + t * 0.03;
    const r = 65 + 20 * Math.sin(t * 0.1 + i);
    const hx = Math.cos(a) * r, hy = Math.sin(a) * r;
    ctx.globalAlpha = 0.5 + 0.4 * Math.sin(t * 0.08 + i * 0.8);
    ctx.fillStyle = i % 2 === 0 ? '#ff4422' : '#ffaa00';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('0x' + hexList[i], hx, hy + 3);
  }

  // "INJECT" label inside
  ctx.globalAlpha = 0.7 + 0.3 * Math.sin(t * 0.1);
  ctx.fillStyle = '#ff4400';
  ctx.font = 'bold 11px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('CODE', 0, -5);
  ctx.fillText('INJECT', 0, 10);

  ctx.globalAlpha = 1;
  ctx.restore();

  // Skull emerging from the code (malware birth)
  ctx.save();
  ctx.translate(cx + 10, cy + 5);
  const skullAlpha = 0.15 + 0.12 * Math.sin(t * 0.06);
  ctx.globalAlpha = skullAlpha;
  // skull circle
  ctx.fillStyle = '#ff1133';
  ctx.beginPath(); ctx.arc(0, -10, 30, 0, Math.PI * 2); ctx.fill();
  // eye sockets
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(-10, -14, 7, 8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10, -14, 7, 8, 0, 0, Math.PI * 2); ctx.fill();
  // jaw
  ctx.fillStyle = '#ff1133';
  ctx.beginPath(); ctx.rect(-22, 10, 44, 18); ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  // Labels
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 12px monospace';
  ctx.fillStyle = '#ff6600';
  ctx.fillText('코드 인젝션', cx, cy + 110);
  ctx.font = '9px monospace';
  ctx.fillStyle = '#994400';
  ctx.fillText('Binary Mutation Zone', cx, cy + 126);
  ctx.restore();
}

// ── Malware (MIDDLE-RIGHT) ────────────────────────────────
function drawMalware() {
  const cx = 920, cy = 340;

  // Red corruption aura
  const aura = ctx.createRadialGradient(cx, cy, 10, cx, cy, 170);
  aura.addColorStop(0, 'rgba(255,0,30,0.22)');
  aura.addColorStop(0.6, 'rgba(180,0,10,0.06)');
  aura.addColorStop(1, 'rgba(100,0,0,0)');
  ctx.fillStyle = aura;
  ctx.fillRect(cx - 170, cy - 170, 340, 340);

  ctx.save();
  ctx.translate(cx, cy);

  // Virus body - spiky blob
  for (let layer = 0; layer < 3; layer++) {
    ctx.beginPath();
    const spikes = 12 + layer * 2;
    for (let i = 0; i <= spikes * 2; i++) {
      const a = (i / spikes) * Math.PI + t * 0.02 * (layer % 2 === 0 ? 1 : -1);
      const outer = i % 2 === 0;
      const r = outer ? (68 - layer * 8) + 8 * Math.sin(t * 0.07 + i + layer) : (42 - layer * 5);
      const px = Math.cos(a) * r, py = Math.sin(a) * r;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (layer === 0) {
      const vg = ctx.createRadialGradient(0, 0, 5, 0, 0, 70);
      vg.addColorStop(0, 'rgba(80,0,10,0.95)');
      vg.addColorStop(1, 'rgba(30,0,5,0.9)');
      ctx.fillStyle = vg;
      ctx.fill();
    }
    ctx.strokeStyle = `rgba(255,${20 + layer * 10},${layer * 5},${0.7 - layer * 0.15})`;
    ctx.lineWidth = 2 - layer * 0.3;
    ctx.stroke();
  }

  // Skull face
  // head
  ctx.fillStyle = 'rgba(200,0,20,0.9)';
  ctx.beginPath(); ctx.ellipse(0, -5, 28, 32, 0, 0, Math.PI * 2); ctx.fill();
  // eyes glow
  const eyePulse = 0.7 + 0.3 * Math.sin(t * 0.15);
  ctx.fillStyle = `rgba(255,50,50,${eyePulse})`;
  ctx.beginPath(); ctx.ellipse(-10, -10, 8, 9, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10, -10, 8, 9, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(-10, -10, 4, 5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(10, -10, 4, 5, 0, 0, Math.PI * 2); ctx.fill();
  // nose
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.beginPath(); ctx.moveTo(-5, 2); ctx.lineTo(5, 2); ctx.lineTo(0, 10); ctx.closePath(); ctx.fill();
  // teeth
  ctx.fillStyle = 'rgba(200,0,20,0.9)';
  ctx.beginPath(); ctx.rect(-22, 18, 44, 15); ctx.fill();
  ctx.fillStyle = 'rgba(255,200,200,0.9)';
  for (let t2 = 0; t2 < 5; t2++) {
    ctx.beginPath(); ctx.rect(-20 + t2 * 10, 18, 8, 12); ctx.fill();
  }

  // Orbiting binary
  for (let i = 0; i < 16; i++) {
    const a = (i / 16) * Math.PI * 2 - t * 0.04;
    const r = 85 + 5 * Math.sin(t * 0.08 + i);
    const bx = Math.cos(a) * r, by = Math.sin(a) * r;
    ctx.globalAlpha = 0.25 + 0.2 * Math.sin(t * 0.1 + i);
    ctx.fillStyle = '#ff2244';
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(i % 2 === 0 ? '1' : '0', bx, by + 3);
  }

  // Virus spores
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 + t * 0.025;
    const dist = 100 + 15 * Math.sin(t * 0.06 + i * 1.1);
    const sx = Math.cos(angle) * dist, sy = Math.sin(angle) * dist;
    ctx.globalAlpha = 0.5 + 0.4 * Math.sin(t * 0.12 + i);
    ctx.fillStyle = '#ff0033';
    ctx.beginPath(); ctx.arc(sx, sy, 5 + 2 * Math.sin(t * 0.1 + i), 0, Math.PI * 2); ctx.fill();
    // connector
    ctx.strokeStyle = 'rgba(255,0,30,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(sx, sy); ctx.stroke();
  }

  ctx.globalAlpha = 1;
  ctx.restore();

  // Labels
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 13px monospace';
  ctx.fillStyle = '#ff2244';
  ctx.shadowColor = '#ff0022'; ctx.shadowBlur = 8;
  ctx.fillText('악성코드', cx, cy + 125);
  ctx.shadowBlur = 0;
  ctx.font = '9px monospace';
  ctx.fillStyle = '#881122';
  ctx.fillText('Malware Binary (Mutated)', cx, cy + 140);
  ctx.restore();
}

// ── Reverser figure (RIGHT) ───────────────────────────────
function drawReverser() {
  const cx = 1260, cy = 380;
  ctx.save();
  ctx.translate(cx, cy);

  // Desk glow
  const dg = ctx.createRadialGradient(0, 50, 10, 0, 50, 250);
  dg.addColorStop(0, 'rgba(0,200,150,0.12)');
  dg.addColorStop(1, 'rgba(0,100,80,0)');
  ctx.fillStyle = dg;
  ctx.fillRect(-250, -150, 500, 300);

  // Multiple monitors
  // Main monitor
  ctx.fillStyle = '#0a0f14';
  ctx.strokeStyle = '#336655';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.roundRect(-90, -180, 180, 120, 4); ctx.fill(); ctx.stroke();
  // Screen glow
  const screenG = ctx.createLinearGradient(-85, -175, 85, -65);
  screenG.addColorStop(0, 'rgba(0,50,30,0.95)');
  screenG.addColorStop(1, 'rgba(0,20,15,0.95)');
  ctx.fillStyle = screenG;
  ctx.beginPath(); ctx.roundRect(-86, -176, 172, 116, 2); ctx.fill();

  // Disassembly on screen
  ctx.font = '6px monospace';
  const asmLines = [
    { c: '#00ff88', t: '0x401A30  PUSH EBP' },
    { c: '#00cc66', t: '0x401A31  MOV EBP,ESP' },
    { c: '#00ff88', t: '0x401A34  CALL VirtualAlloc' },
    { c: '#ffaa00', t: '0x401A39  ; <-- INJECT POINT' },
    { c: '#ff4466', t: '0x401A3C  PUSH payload_addr' },
    { c: '#ff2244', t: '0x401A41  CALL WriteProcessMem' },
    { c: '#ff4466', t: '0x401A46  JMP shellcode' },
    { c: '#aaffcc', t: '0x401A4B  MOV EAX,0' },
    { c: '#00ff88', t: '0x401A50  POP EBP' },
    { c: '#00ff88', t: '0x401A51  RET' }
  ];
  asmLines.forEach((line, i) => {
    ctx.globalAlpha = (i === 3 || i === 4 || i === 5) ? 1 : 0.7;
    ctx.fillStyle = line.c;
    if (i === 3 || i === 4 || i === 5) {
      ctx.fillStyle = 'rgba(255,80,0,0.15)';
      ctx.fillRect(-85, -170 + i * 14, 170, 13);
      ctx.fillStyle = line.c;
    }
    ctx.fillText(line.t, -82, -162 + i * 14);
  });

  // Cursor blink
  if (Math.floor(t * 0.07) % 2 === 0) {
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(-82, -162 + 3 * 14 + 1, 5, 9);
  }
  ctx.globalAlpha = 1;

  // Side monitor (smaller)
  ctx.fillStyle = '#080c10';
  ctx.strokeStyle = '#224433';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(105, -160, 110, 90, 3); ctx.fill(); ctx.stroke();

  // Hex dump on side screen
  ctx.font = '5.5px monospace';
  const hexRows = ['4D 5A 90 00', '03 00 00 00', 'FF FF 00 00', 'E8 FF 00 00', '40 00 00 00'];
  hexRows.forEach((row, i) => {
    ctx.fillStyle = i === 0 ? '#ffaa00' : '#336655';
    ctx.globalAlpha = 0.8;
    ctx.fillText(row, 110, -148 + i * 16);
  });
  // highlight
  ctx.fillStyle = 'rgba(255,50,50,0.2)';
  ctx.fillRect(106, -163 + 3 * 16, 108, 14);
  ctx.fillStyle = '#ff4444';
  ctx.globalAlpha = 0.9;
  ctx.fillText('E8 FF 00 00', 110, -163 + 3 * 16 + 10);
  ctx.globalAlpha = 1;

  // Monitor stand
  ctx.fillStyle = '#1a2a22';
  ctx.fillRect(-8, -55, 16, 20);
  ctx.fillRect(-30, -38, 60, 6);

  // Keyboard
  ctx.fillStyle = '#0d1a12';
  ctx.strokeStyle = '#1a3322';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(-80, 10, 160, 28, 3); ctx.fill(); ctx.stroke();
  for (let k = 0; k < 16; k++) {
    ctx.fillStyle = `rgba(0,200,120,${0.15 + 0.05 * Math.sin(t * 0.1 + k)})`;
    ctx.beginPath(); ctx.roundRect(-74 + k * 10, 14, 8, 8, 1); ctx.fill();
  }

  // Desk surface
  const deskG = ctx.createLinearGradient(-200, 45, 200, 75);
  deskG.addColorStop(0, '#0a1a12');
  deskG.addColorStop(1, '#050e08');
  ctx.fillStyle = deskG;
  ctx.strokeStyle = '#1a3322';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.rect(-200, 45, 400, 30); ctx.fill(); ctx.stroke();

  // Coffee cup
  ctx.fillStyle = '#1a0a00';
  ctx.strokeStyle = '#3a1a00';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(160, 20, 24, 28, 2); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = '#4a2a00';
  ctx.beginPath(); ctx.arc(174, 24, 8, 0.2, Math.PI * 0.9); ctx.stroke();
  // steam
  for (let s = 0; s < 3; s++) {
    ctx.globalAlpha = 0.2 + 0.15 * Math.sin(t * 0.08 + s);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(166 + s * 5, 18);
    ctx.bezierCurveTo(162 + s * 5, 10 + s * 2, 172 + s * 5, 5 + s, 168 + s * 5, -5 + s);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Person silhouette - analyst
  // Body
  ctx.fillStyle = '#0a1a14';
  ctx.strokeStyle = 'rgba(0,200,120,0.3)';
  ctx.lineWidth = 1.5;
  // chair
  ctx.fillStyle = '#0d1512';
  ctx.beginPath(); ctx.ellipse(0, 110, 45, 15, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillRect(-8, 55, 16, 60);
  // torso
  ctx.fillStyle = '#0f1f18';
  ctx.strokeStyle = 'rgba(0,150,100,0.4)';
  ctx.beginPath();
  ctx.moveTo(-25, 50); ctx.lineTo(-30, -20); ctx.lineTo(0, -40); ctx.lineTo(30, -20); ctx.lineTo(25, 50); ctx.closePath();
  ctx.fill(); ctx.stroke();
  // hoodie highlights
  ctx.strokeStyle = 'rgba(0,200,120,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(-25, 50); ctx.lineTo(-15, -10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(25, 50); ctx.lineTo(15, -10); ctx.stroke();
  // arms
  ctx.strokeStyle = 'rgba(0,150,100,0.5)';
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(-25, 0); ctx.lineTo(-80, 25); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(80, 25); ctx.stroke();
  // hands
  ctx.fillStyle = '#1a2a22';
  ctx.beginPath(); ctx.arc(-80, 25, 7, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(80, 25, 7, 0, Math.PI * 2); ctx.fill();
  // head
  ctx.fillStyle = '#1a2820';
  ctx.strokeStyle = 'rgba(0,200,120,0.35)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.ellipse(0, -60, 24, 28, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  // hair/hood
  ctx.fillStyle = '#0a120e';
  ctx.beginPath();
  ctx.moveTo(-24, -55); ctx.quadraticCurveTo(-25, -95, 0, -98);
  ctx.quadraticCurveTo(25, -95, 24, -55); ctx.closePath();
  ctx.fill();
  // eyes glow (reflecting screen)
  ctx.fillStyle = `rgba(0,255,150,${0.5 + 0.3 * Math.sin(t * 0.12)})`;
  ctx.beginPath(); ctx.ellipse(-8, -58, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(8, -58, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  // glasses reflection
  ctx.strokeStyle = `rgba(0,255,150,${0.2 + 0.1 * Math.sin(t * 0.08)})`;
  ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.ellipse(-8, -58, 9, 6, 0, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.ellipse(8, -58, 9, 6, 0, 0, Math.PI * 2); ctx.stroke();
  ctx.strokeStyle = 'rgba(0,200,120,0.3)';
  ctx.beginPath(); ctx.moveTo(-1, -58); ctx.lineTo(1, -58); ctx.stroke();

  ctx.restore();

  // Label
  ctx.save();
  ctx.textAlign = 'center';
  ctx.font = 'bold 12px monospace';
  ctx.fillStyle = '#00cc88';
  ctx.shadowColor = '#00ff88'; ctx.shadowBlur = 6;
  ctx.fillText('SRE', cx, cy + 95);
  ctx.shadowBlur = 0;
  ctx.font = '9px monospace';
  ctx.fillStyle = '#336644';
  ctx.fillText('Reverse Engineering in Progress', cx, cy + 110);
  ctx.restore();
}

// ── Connecting energy flows ───────────────────────────────
function drawConnections() {
  // Arrow 1: Security → Injection
  const t1x1 = 320, t1y1 = 350, t1x2 = 480, t1y2 = 340;
  drawEnergyArrow(t1x1, t1y1, t1x2, t1y2, '#ffaa00', t);

  // Arrow 2: Injection → Malware
  const t2x1 = 650, t2y1 = 340, t2x2 = 780, t2y2 = 340;
  drawEnergyArrow(t2x1, t2y1, t2x2, t2y2, '#ff3300', t);

  // Arrow 3: Malware → Reverser (analysis, curved up and over)
  const ax1 = 1000, ay1 = 280, ax2 = 1140, ay2 = 220;
  drawEnergyArrow(ax1, ay1, ax2, ay2, '#00ffaa', t, true);

  // Stage labels above arrows
  ctx.save();
  ctx.font = '8px monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,170,0,0.7)';
  ctx.fillText('바이너리 변이', (t1x1 + t1x2) / 2, t1y1 - 15);
  ctx.fillStyle = 'rgba(255,50,0,0.7)';
  ctx.fillText('악성코드 생성', (t2x1 + t2x2) / 2, t2y1 - 15);
  ctx.fillStyle = 'rgba(0,255,170,0.7)';
  ctx.fillText('리버싱 분석', (ax1 + ax2) / 2 + 30, ay1 - 30);
  ctx.restore();
}

function drawEnergyArrow(x1, y1, x2, y2, color, t) {
  const dx = x2 - x1, dy = y2 - y1;

  // Base line
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 6]);
  ctx.dashOffset = 0;
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
  ctx.setLineDash([]);

  // Animated energy particles on line
  for (let i = 0; i < 5; i++) {
    const prog = ((t * 0.025 + i / 5) % 1);
    const px = x1 + dx * prog, py = y1 + dy * prog;
    ctx.globalAlpha = Math.sin(prog * Math.PI) * 0.9;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI * 2); ctx.fill();
    // glow
    const pg = ctx.createRadialGradient(px, py, 0, px, py, 10);
    pg.addColorStop(0, color.replace(')', ',0.4)').replace('rgb', 'rgba').replace(/#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i, (_, r, g, b) => `rgba(${parseInt(r, 16)},${parseInt(g, 16)},${parseInt(b, 16)}`));
    pg.addColorStop(1, 'transparent');
    ctx.fillStyle = pg;
    ctx.beginPath(); ctx.arc(px, py, 10, 0, Math.PI * 2); ctx.fill();
  }

  // Arrowhead
  ctx.globalAlpha = 0.8;
  ctx.fillStyle = color;
  const angle = Math.atan2(dy, dx);
  ctx.save();
  ctx.translate(x2, y2);
  ctx.rotate(angle);
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-14, -7); ctx.lineTo(-14, 7); ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.globalAlpha = 1;
  ctx.restore();
}

// ── Glitch effect ────────────────────────────────────────
function drawGlitch() {
  glitchTimer++;
  if (glitchTimer > randInt(40, 120)) {
    glitchTimer = 0;
    glitchLines = Array.from({ length: randInt(2, 6) }, () => ({
      y: randInt(0, H), h: randInt(2, 8),
      x: randInt(0, W * 0.6), w: randInt(50, 300),
      alpha: randF(0.04, 0.12), col: Math.random() < 0.5 ? '#ff0022' : '#00ff88',
      dur: randInt(3, 8)
    }));
  }
  glitchLines.forEach(g => {
    if (g.dur-- > 0) {
      ctx.globalAlpha = g.alpha;
      ctx.fillStyle = g.col;
      ctx.fillRect(g.x, g.y, g.w, g.h);
    }
  });
  ctx.globalAlpha = 1;
}

// ── Title & labels ───────────────────────────────────────
function drawTitle() {
  // Top bar
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, W, 50);

  // Title
  ctx.save();
  ctx.font = 'bold 20px monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#00ffaa';
  ctx.shadowColor = '#00ff88'; ctx.shadowBlur = 15;
  ctx.fillText('▍ 보안솔루션 → 코드인젝션 → 악성코드 변환 메커니즘  ·  SRE ▍', W / 2, 30);
  ctx.shadowBlur = 0;
  ctx.restore();

  // Top line
  ctx.strokeStyle = 'rgba(0,255,150,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(W, 50); ctx.stroke();

  // Stage indicators
  const stages = [
    { x: 200, label: '① SECURITY SOL.', col: '#1a6aff' },
    { x: 560, label: '② INJECTION', col: '#ff8800' },
    { x: 920, label: '③ MALWARE', col: '#ff2244' },
    { x: 1260, label: '④ REVERSING', col: '#00cc88' }
  ];
  stages.forEach(s => {
    ctx.save();
    ctx.textAlign = 'center';
    ctx.font = 'bold 9px monospace';
    ctx.fillStyle = s.col;
    ctx.globalAlpha = 0.8 + 0.2 * Math.sin(t * 0.05);
    ctx.fillText(s.label, s.x, 65);
    ctx.restore();
  });

  // Bottom attribution
  ctx.save();
  ctx.font = '8px monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(0,200,100,0.25)';
  ctx.fillText('[ FOR SECURITY RESEARCH & EDUCATIONAL PURPOSES ONLY ]', 10, H - 8);
  ctx.restore();
}

// ── Magnifying glass overlay on malware (reversing) ──────
function drawMagnifier() {
  const mx = 1090, my = 310;
  const r = 55;

  // Glass circle
  ctx.save();
  ctx.beginPath(); ctx.arc(mx, my, r, 0, Math.PI * 2);
  ctx.clip();

  // Inside - zoomed view of code/hex
  ctx.fillStyle = 'rgba(0,10,5,0.92)';
  ctx.fillRect(mx - r, my - r, r * 2, r * 2);
  ctx.font = '6.5px monospace';
  const insideLines = [
    { c: '#ff4466', t: '4D 5A 90 00' },
    { c: '#ffaa00', t: 'E8 FF 00 00' },
    { c: '#ff2244', t: 'JMP [payload]' },
    { c: '#ff4466', t: 'XOR EAX,EAX' },
    { c: '#ffaa00', t: 'CALL shellcode' },
    { c: '#ff8800', t: 'PUSH 0xDEAD' }
  ];
  insideLines.forEach((ln, i) => {
    ctx.fillStyle = ln.c;
    ctx.fillText(ln.t, mx - r + 5, my - r + 14 + i * 14);
  });

  // Scan line inside lens
  const scanY = ((t * 1.5) % 110) - 5;
  ctx.fillStyle = 'rgba(0,255,100,0.08)';
  ctx.fillRect(mx - r, my - r + scanY, r * 2, 8);

  ctx.restore();

  // Glass rim
  ctx.strokeStyle = `rgba(0,200,150,${0.6 + 0.2 * Math.sin(t * 0.08)})`;
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(mx, my, r, 0, Math.PI * 2); ctx.stroke();
  // reflection
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(mx - 15, my - 15, 20, Math.PI * 1.2, Math.PI * 1.7); ctx.stroke();

  // Handle
  ctx.strokeStyle = 'rgba(0,180,120,0.7)';
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(mx + r * 0.7, my + r * 0.7);
  ctx.lineTo(mx + r * 1.5, my + r * 1.5);
  ctx.stroke();
}

// ── Main draw loop ────────────────────────────────────────
function draw() {
  ctx.clearRect(0, 0, W, H);
  drawBG();
  drawRain();
  drawHexParticles();
  drawStream();
  drawGlitch();
  drawSecuritySolution();
  drawInjectionZone();
  drawMalware();
  drawConnections();
  drawMagnifier();
  drawReverser();
  drawTitle();
  t++;
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
